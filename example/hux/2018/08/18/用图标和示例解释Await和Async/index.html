<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="google-site-verification" content="Xk9YWz2-rBE9P5__qdWz3nUr4zb9bIDSdANHpezjB04"><meta name="baidu-site-verification" content="aifbHeRmzy"><meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1"><meta name="description" content="Goals determine what you going to be!!"><meta name="keyword" content="hjb, csjiabin, csjiabin Blog, 黄佳滨的博客, huangjiabin, 黄佳滨, html, css, javascript, js, JavaScript, Node, node, nodejs, h5, html5, 小程序, vue"><title>用图标和示例解释Await和Async - CSjiabin的博客 | CSjiabin&#39;s Blog</title><link rel="canonical" href="https://csjiabin.github.io"><link rel="manifest" href="/hux/pwa/manifest.json"><link rel="shortcut icon" href="/hux/img/favicon.ico"><link rel="apple-touch-icon" href="/hux/img/apple-touch-icon.png"><link rel="stylesheet" href="/hux/css/bootstrap.min.css"><link rel="stylesheet" href="/hux/css/hux-blog.min.css"><link rel="stylesheet" href="/hux/css/highlight.css"><link rel="stylesheet" href="/hux/css/rocket.css"><link rel="stylesheet" href="/hux/css/signature.css"><link rel="stylesheet" href="/hux/css/toc.css"><link rel="stylesheet" type="text/css" href="https://c.mipcdn.com/static/v1/mip.css"><link href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"> <!--[if lt IE 9]><script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script><script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script><![endif]--><script>!function(e,t,o,c,i,d,a){e.DaoVoiceObject=i,e[i]=e[i]||function(){(e[i].q=e[i].q||[]).push(arguments)},e[i].l=1*new Date,d=t.createElement(o),a=t.getElementsByTagName(o)[0],d.async=1,d.src=c,d.charset="utf-8",a.parentNode.insertBefore(d,a)}(window,document,"script",("https:"==document.location.protocol?"https:":"http:")+"//widget.daovoice.io/widget/bdc5c12d.js","daovoice"),daovoice("init",{app_id:"bdc5c12d"}),daovoice("update")</script><script></script></head><body ontouchstart=""><style type="text/css">header.intro-header{background-image:url(/hux/img/home-bg-o.jpg)}#signature{background-image:url(/hux/img/signature/white.png)}</style><link rel="stylesheet" href="/hux/css/post-style.css"><header class="intro-header"><div id="signature"><div class="container"><div class="row"><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><div class="post-heading"><div class="tags"> <a class="tag" href="/hux/tags/#es7" title="es7">es7</a> <a class="tag" href="/hux/tags/#promise" title="promise">promise</a> <a class="tag" href="/hux/tags/#js" title="js">js</a> <a class="tag" href="/hux/tags/#request" title="request">request</a></div><h1>用图标和示例解释Await和Async</h1><h2 class="subheading"></h2> <span class="meta">Posted by CSjiabin on 2018-08-18</span></div></div></div></div></div></header><nav class="navbar navbar-default navbar-custom navbar-fixed-top"><div class="container-fluid"><div class="navbar-header page-scroll"> <button type="button" class="navbar-toggle"> <span class="sr-only">Toggle navigation</span><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button> <a class="navbar-brand" href="/hux/">CSjiabin&#39;s Blog</a></div><div id="huxblog_navbar"><div class="navbar-collapse"><ul class="nav navbar-nav navbar-right"><li> <a href="/hux/">Home</a></li><li> <a href="/hux/about/">About</a></li><li> <a href="/hux/archives/">Archives</a></li><li> <a href="/hux/tags/">Tags</a></li></ul></div></div></div></nav><script>var $body=document.body,$toggle=document.querySelector(".navbar-toggle"),$navbar=document.querySelector("#huxblog_navbar"),$collapse=document.querySelector(".navbar-collapse");function handleMagic(e){0<$navbar.className.indexOf("in")?($navbar.className=" ",setTimeout(function(){$navbar.className.indexOf("in")<0&&($collapse.style.height="0px")},400)):($collapse.style.height="auto",$navbar.className+=" in")}$toggle.addEventListener("click",handleMagic)</script><article><div class="container"><div class="row"><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1 post-container"><h1> <span id="简介">简介</span></h1><p>JavaScript ES7 中的 async / await 让多个异步 promise 协同工作起来更容易。如果要按一定顺序从多个数据库或者 API 异步获取数据，你可能会以一堆乱七八糟的 promise 和回调函数而告终。而 async / await 结构让我们能用可读性强、易维护的代码更加简洁地实现这些逻辑。</p><p>本教程用图表和简单示例讲解了 JavaScript 中 async / await 的语法和语义。</p><p>在深入之前，我们先简单回顾一下 promise. 如果你已经对 JS 的 promise 有所了解，可放心大胆地跳过这一部分。</p><h4> <span id="promises">Promises</span></h4><p>在 JavaScript 中，promise 代表非阻塞异步执行的抽象概念。如果你熟悉Java 的 Future、C# 的 Task, 你会发现 promise 跟它们很像。</p><p>Promise 一般用于网络和 I/O 操作，比如读取文件，或者创建 HTTP 请求。我们可以创建异步 promise，然后用 then 添加一个回调函数，当 promise 结束后会触发这个回调函数，而非阻塞住当前“线程”。回调函数本身也可以返回一个 promise 对象，所以我们能够链式调用 promise。</p><p>为了简单起见，我们假设后面所有示例都已经像这样安装并加载了 request-promise 类库：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rp = <span class="built_in">require</span>(<span class="string">'request-promise'</span>);</span><br></pre></td></tr></table></figure><p>现在我们就可以像这样创建一个返回 promise 对象的简易 HTTP GET 请求：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = rp(<span class="string">'http://example.com/'</span>)</span><br></pre></td></tr></table></figure><p>我们现在来看个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'Starting Execution'</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> promise = rp(<span class="string">'http://example.com/'</span>);</span><br><span class="line">promise.then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result));</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"Can't know if promise has finished yet..."</span>);</span><br></pre></td></tr></table></figure><p>我们在第3行创建了一个 promise 对象，在第4行给它加了个回调函数。Promise 是异步的，所以当执行到第6行时，我们并不知道 promise 是否已完成。如果把段这代码多执行几次，可能每次都得到不同的结果。一般地说，就是 promise 创建后的代码和 promise 是同时运行的。</p><p>直到 promise 执行完，才有办法阻塞当前操作序列。这不同于 Java 的 Future.get, 它让我们能够在 Future 结束之前就阻塞当前线程。对于 JavaScript，我们没法等待 promise 执行完。在 promise 后面编排代码的唯一方法是用 then 给它添加回调函数。</p><p>下图描述了本例的计算过程：</p><p><img src="post-async-await-0.jpg" alt=""></p><p>Promise 的计算过程。正在执行的“线程”无法等待 promise 执行完成。在 promise 后面编排代码的唯一方法是用 then 给它添加回调函数。</p><p>通过 then 添加的回调函数只有当 promise 成功时才会执行。如果它失败了（比如由于网络错误），回调函数不会执行。你可以用 catch 再附加一个回调函数来处理失败的 promise:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rp(<span class="string">'http://example.com/'</span>).</span><br><span class="line">    then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'Success'</span>)).</span><br><span class="line">    <span class="keyword">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`Failed: <span class="subst">$&#123;e&#125;</span>`</span>))</span><br></pre></td></tr></table></figure><p>最后，为了测试，我们可以用 Promise.resolve 和 Promise.reject 很容易地创建执行成功或失败的“傻瓜” promise:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> success = <span class="built_in">Promise</span>.resolve(<span class="string">'Resolved'</span>);</span><br><span class="line"><span class="comment">// 打印 "Successful result: Resolved"</span></span><br><span class="line">success.</span><br><span class="line">    then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`Successful result: <span class="subst">$&#123;result&#125;</span>`</span>)).</span><br><span class="line">    <span class="keyword">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`Failed with: <span class="subst">$&#123;e&#125;</span>`</span>))</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> fail = <span class="built_in">Promise</span>.reject(<span class="string">'Err'</span>);</span><br><span class="line"><span class="comment">// 打印 "Failed with: Err"</span></span><br><span class="line">fail.</span><br><span class="line">    then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`Successful result: <span class="subst">$&#123;result&#125;</span>`</span>)).</span><br><span class="line">    <span class="keyword">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`Failed with: <span class="subst">$&#123;e&#125;</span>`</span>))</span><br></pre></td></tr></table></figure><p>想要更详细的 promise 教程，可以参考这篇文章。</p><h4> <span id="问题来了组合-promise">问题来了——组合 promise</span></h4><p>只用一个 promise 很容易搞定。但是，当需要针对复杂异步逻辑编程时，我们很可能最后要同时用好几个 promise 对象。写一堆 then 语句和匿名回调很容易搞得难以控制。</p><p>例如，假设我们需要编程解决如下需求：</p><ol><li>创建 HTTP 请求，等待请求结束并打印出结果；</li><li>再创建两个并行 HTTP 请求；</li><li>等这两个请求结束后，打印出它们的结果。</li></ol><p>下面这段代码示范了如何解决此问题：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一次调用</span></span><br><span class="line"><span class="keyword">const</span> call1Promise = rp(<span class="string">'http://example.com/'</span>);</span><br><span class="line"> </span><br><span class="line">call1Promise.then(<span class="function"><span class="params">result1</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 第一个请求完成后会执行</span></span><br><span class="line">    <span class="built_in">console</span>.log(result1);</span><br><span class="line">    <span class="keyword">const</span> call2Promise = rp(<span class="string">'http://example.com/'</span>);</span><br><span class="line">    <span class="keyword">const</span> call3Promise = rp(<span class="string">'http://example.com/'</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.all([call2Promise, call3Promise]);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">arr</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 两个 promise 都结束后会执行</span></span><br><span class="line">    <span class="built_in">console</span>.log(arr[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">console</span>.log(arr[<span class="number">1</span>]);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>我们开头创建了第一个 HTTP 请求，并且加了个完成时候运行的回调（1-3行）。在这个回调函数里，我们为随后的 HTTP 请求创建了另外两个 promise（8-9行）。这两个 promise 同时执行，我们需要加一个能等它们都完成后才执行的回调函数。因此，我们需要用 Promise.all 将它们组合到同一个 promise 中（11 行），它们都结束后这个 promise 才算完成。这个回调返回的是 promise 对象，所以我们要再加一个 then 回调函数来打印结果（12-16行）。</p><p>下图描述了这一计算流程：</p><p><img src="post-async-await-1.jpg" alt=""></p><p>Promise 组合的计算过程。我们用 Promise.all 将两个并行的 promise 组合到一个 promise 中。</p><p>对于这个简单的例子，我们最后用了两个 then 回调方法，并且不得不用 Promise.all 来让两个并行的 promise 同时执行。如果我们必须执行更多异步操作，或者加上错误处理会怎么样呢？这种方法最后很容易产生一堆乱七八糟的 then, Promise.all 和回调函数。</p><h4> <span id="async-方法">Async 方法</span></h4><p>Async 是定义返回 promise 对象函数的快捷方法。</p><p>例如，下面这两种定义是等价的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="string">'TEST'</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// asyncF 和 f 是等价的</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncF</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'TEST'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类似地，抛出异常的 async 方法等价于返回拒绝 promise 的方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="string">'Error'</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// asyncF 和 f 是等价的</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncF</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">'Error'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4> <span id="await">Await</span></h4><p>我们创建了 promise 但不能同步等待它执行完成。我们只能通过 then 传一个回调函数。不允许等待 promise 是为了鼓励开发非阻塞代码。否则，开发者们总会忍不住执行阻塞操作，因为那比使用 promise 和回调更简单。</p><p>然而，为了让 promise 能同步执行，我们需要让他们等待彼此完成。换句话说，如果一个操作是异步的（即封装在 promise 中），它应该能够等待另一个异步操作执行完。但是 JavaScript 解释器怎么能知道一个操作是否在 promise 中运行呢？</p><p>答案就在 async 这个关键词中。每个 async 方法都返回一个 promise 对象。因此，JavaScript 解释器就明白所有 async 方法中的操作都被封装在 promise 里异步执行。所以解释器能够允许它们等待其他 promise 执行完。</p><p>下面引入 await 关键词。它只能被用在 async 方法中，让我们能同步等待 promise 执行完。如果在 async 函数外使用 promise, 我们仍然需要用 then 回调函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// response 就是 promise 执行成功的值</span></span><br><span class="line">    <span class="keyword">const</span> response = <span class="keyword">await</span> rp(<span class="string">'http://example.com/'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(response);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 不能在 async 方法外面用 await</span></span><br><span class="line"><span class="comment">// 需要使用 then 回调函数……</span></span><br><span class="line">f().then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'Finished'</span>));</span><br></pre></td></tr></table></figure><p>现在我们来看如何解决上一节的问题：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将解决方法封装到 async 函数中</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">solution</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 等待第一个 HTTP 请求并打印出结果</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">await</span> rp(<span class="string">'http://example.com/'</span>));</span><br><span class="line"> </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 创建两个 HTTP 请求，不等它们执行完 —— 让他们同时执行</span></span><br><span class="line">    <span class="keyword">const</span> call2Promise = rp(<span class="string">'http://example.com/'</span>);  <span class="comment">// Does not wait!</span></span><br><span class="line">    <span class="keyword">const</span> call3Promise = rp(<span class="string">'http://example.com/'</span>);  <span class="comment">// Does not wait!</span></span><br><span class="line"> </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建完以后 —— 等待它们都执行完</span></span><br><span class="line">    <span class="keyword">const</span> response2 = <span class="keyword">await</span> call2Promise;</span><br><span class="line">    <span class="keyword">const</span> response3 = <span class="keyword">await</span> call3Promise;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">console</span>.log(response2);</span><br><span class="line">    <span class="built_in">console</span>.log(response3);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 调用这一 async 函数</span></span><br><span class="line">solution().then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'Finished'</span>));</span><br></pre></td></tr></table></figure><p>上面这段代码中，我们把解决方法封装到 async 函数中。这让我们能直接对里面的 promise 使用 await 关键字，所以不再需要使用 then 回调函数。最后，调用这个 async 函数，它简单地创建了一个 promise 对象, 这个 promise 封装了调用其他 promise 的逻辑。</p><p>当然，在第一个例子（没有用 async / await）中，两个 promise会被同时触发。这段代码也一样（7-8 行）。注意，直到第 11-12 行我们才使用 await, 将程序一直阻塞到两个 promise 执行完成。然后我们就能断定上例中两个 promise 都成功执行了（和使用 Promise.all(…).then(…) 类似）。</p><p>这背后的计算过程跟上一节给出的基本相当。但是代码可读性更强、更易于理解。</p><p>实际上，async / await 在底层转换成了 promise 和 then 回调函数。也就是说，这是使用 promise 的语法糖。每次我们使用 await, 解释器都创建一个 promise 对象，然后把剩下的 async 函数中的操作放到 then 回调函数中。</p><p>我们再看看下面的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Starting F'</span>);</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> rp(<span class="string">'http://example.com/'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面给出了函数 f 底层运算过程。由于 f 是 async 的，所以它会跟它的调用方同时执行：</p><p><img src="post-async-await-2.jpg" alt=""></p><center>Await 的计算过程。</center><br><p>函数 f 开始运行并创建了一个 promise 对象。就在那一刻，函数中剩下的部分被封装到一个回调函数中，并在 promise 结束后执行。</p><h4> <span id="错误处理">错误处理</span></h4><p>前面大部分例子中，我们都假设 promise 执行成功。因此在 promise 上使用 await 会返回值。如果我们进行 await 的 promise 失败了，async 函数就会发生异常。我们可以用标准的 try / catch 来处理这种情况：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> promiseResult = <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">'Error'</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Async 函数不会处理异常，不管异常是由拒绝的 promise 还是其他 bug 引起的，它都会返回一个拒绝 promise:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Throws an exception</span></span><br><span class="line">    <span class="keyword">const</span> promiseResult = <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">'Error'</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Will print "Error"</span></span><br><span class="line">f().</span><br><span class="line">    then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'Success'</span>)).</span><br><span class="line">    <span class="keyword">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(err))</span><br><span class="line"> </span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">g</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">"Error"</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Will print "Error"</span></span><br><span class="line">g().</span><br><span class="line">    then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'Success'</span>)).</span><br><span class="line">    <span class="keyword">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(err))</span><br></pre></td></tr></table></figure><h4> <span id="结论">结论</span></h4><p>Async / await 是让 promise 更完美的语言结构。它让我们能用更少的代码使用 promise. 然而，async / await 并没有取代普通 promise. 例如，如果在普通函数中或者全局范围内调用 async 函数，我们就没办法使用 await 而要依赖于普通 promise:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fAsync</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// actual return value is Promise.resolve(5)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// can't call "await fAsync()". Need to use then/catch</span></span><br><span class="line">fAsync().then(<span class="function"><span class="params">r</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`result is <span class="subst">$&#123;r&#125;</span>`</span>));</span><br></pre></td></tr></table></figure><p>我通常会将大部分异步逻辑封装到一个或者几个 async 函数中，然后在非异步代码中调用。这让我尽可能少地写 try / catch 回调。</p><p>Async / await 结构是让使用 promise 更简练的语法糖。每一个 async / await 结构都可以写成普通 promise. 归根结底，这是一个编码风格和简洁的问题。</p><p>关于说明并发和并行有区别的资料，可以查看 Rob Pike 关于这个问题的讨论，或者我这篇文章。并发是指将独立进程（通常意义上的进程）组合在一起工作，而并行是指真正同时处理多个任务。并发关乎应用设计和架构，而并行关乎实实在在的执行。</p><p>我们拿一个多线程应用来举例。应用程序分离成线程明确了它的并发模型。这些线程在可用内核上的映射定义了其级别或并行性。并发系统可以在单个处理器上高效运行，在这种情况下，它并不是并行的。</p><p><img src="post-async-await-3.jpg" alt=""></p><h4> <span id="并发vs并行">并发VS并行</span></h4><p>从这个意义上说，promise 让我们能够将程序分解成并发模块，这些模块可能会也可能不会并行执行。Javascript 实际否并行执行取决于具体实现方法。例如，Node JS 是单线程的，如果 promise 是计算密集型（CPU bound）那就不会有并行处理。但是，如果你用 Nashorn 之类的东西把代码编译成 java 字节码，理论上可能能够将计算密集型的 promise 映射到不同 CPU 核上，从而达到并行效果。所以我认为，promise（不管是普通的还是用了 async / await 的）组成了 JavaScript 应用的并发模块。</p><hr><ul class="pager"><li class="previous"> <a href="/hux/2018/08/22/JavaScript有用的代码片段和trick/" data-toggle="tooltip" data-placement="top" title="JavaScript有用的代码片段和trick">&larr; Previous Post</a></li><li class="next"> <a href="/hux/2018/08/16/Hexo-创建属于你自己的博客/" data-toggle="tooltip" data-placement="top" title="Hexo,创建属于你自己的博客">Next Post &rarr;</a></li></ul><div class="comment"><div id="disqus_thread" class="disqus-thread"></div></div></div><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1 sidebar-container"><section><h5><a href="/hux/tags/">FEATURED TAGS</a></h5><div class="tags"> <a class="tag" href="/hux/tags/#es7" title="es7">es7</a> <a class="tag" href="/hux/tags/#promise" title="promise">promise</a> <a class="tag" href="/hux/tags/#js" title="js">js</a> <a class="tag" href="/hux/tags/#request" title="request">request</a></div></section><hr><h5>FRIENDS</h5><ul class="list-inline"><li><a href="https://csjiabin.github.io" target="_blank">CSjiabin&#39;s Blog</a></li><li><a href="http://zhengwuyang.com" target="_blank">WY</a></li><li><a href="https://www.jianshu.com/u/f7f87e65552a" target="_blank">简书·csjiabin</a></li></ul></div></div></div></article><script type="text/javascript">var disqus_shortname="csjiabin",disqus_identifier="https://csjiabin.github.io/2018/08/18/用图标和示例解释Await和Async/",disqus_url="https://csjiabin.github.io/2018/08/18/用图标和示例解释Await和Async/";!function(){var s=document.createElement("script");s.type="text/javascript",s.async=!0,s.src="//"+disqus_shortname+".disqus.com/embed.js",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(s)}()</script><script>function async(e,n){var t=document,a="script",r=t.createElement(a),c=t.getElementsByTagName(a)[0];r.src=e,n&&r.addEventListener("load",function(e){n(null,e)},!1),c.parentNode.insertBefore(r,c)}</script><script>async("https://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js",function(){anchors.options={visible:"always",placement:"right",icon:"#"},anchors.add().remove(".intro-header h1").remove(".subheading").remove(".sidebar-container h5")})</script><style>@media all and (min-width:800px){.anchorjs-link{position:absolute;left:-.75em;font-size:1.1em;margin-top:-.1em}}</style><footer><div class="container"><div class="row"><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><ul class="list-inline text-center"><li><a target="_blank" href="https://www.jianshu.com/u/f7f87e65552a"><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i> <i class="fa fa-stack-1x fa-inverse">简</i></span></a></li><li><a target="_blank" href="https://www.zhihu.com/people/csjiabin"><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i> <i class="fa fa-stack-1x fa-inverse">知</i></span></a></li><li><a target="_blank" href="https://github.com/csjiabin"><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i><i class="fa fa-github fa-stack-1x fa-inverse"></i></span></a></li></ul><p class="copyright text-muted"> Copyright &copy; CSjiabin&#39;s Blog 2018<br> Theme by <a href="http://huangxuan.me">Hux</a><span style="display:inline-block;margin:0 5px"><i class="fa fa-heart"></i></span> Ported by <a href="https://csjiabin.github.io">CSjiabin</a> |<iframe style="margin-left:2px;margin-bottom:-5px" frameborder="0" scrolling="0" width="91px" height="20px" src="https://ghbtns.com/github-btn.html?user=csjiabin&repo=csjiabin.github.io&type=star&count=true"></iframe></p></div></div></div></footer><script src="/hux/js/jquery.min.js"></script><script src="/hux/js/bootstrap.min.js"></script><script src="/hux/js/hux-blog.min.js"></script><script type="text/javascript">
        if(navigator.serviceWorker){
            // For security reasons, a service worker can only control the pages that are in the same directory level or below it. That's why we put sw.js at ROOT level.
            navigator.serviceWorker
                .register('/hux/sw.js')
                .then((registration) => {console.log('Service Worker Registered. ', registration)})
                .catch((error) => {console.log('ServiceWorker registration failed: ', error)})
        }
    </script><script>function async(e,n){var t=document,a="script",r=t.createElement(a),c=t.getElementsByTagName(a)[0];r.src=e,n&&r.addEventListener("load",function(e){n(null,e)},!1),c.parentNode.insertBefore(r,c)}</script><script>0!==$("#tag_cloud").length&&async("/hux/js/jquery.tagcloud.js",function(){$.fn.tagcloud.defaults={color:{start:"#bbbbee",end:"#0085a1"}},$("#tag_cloud a").tagcloud()})</script><script>async("https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js",function(){var c=document.querySelector("nav");c&&FastClick.attach(c)})</script><script>var _gaId="UA-124238838-1",_gaDomain="csjiabin.github.io";!function(a,e,g,n,t,i,c){a.GoogleAnalyticsObject="ga",a.ga=a.ga||function(){(a.ga.q=a.ga.q||[]).push(arguments)},a.ga.l=1*new Date,i=e.createElement(g),c=e.getElementsByTagName(g)[0],i.async=1,i.src="//www.google-analytics.com/analytics.js",c.parentNode.insertBefore(i,c)}(window,document,"script"),ga("create",_gaId,_gaDomain),ga("send","pageview")</script><script async src="https://www.googletagmanager.com/gtag/js?UA-124238838-1"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-124238838-1")</script><script>var _baId="2620e69674d25088f870bef114e8ff89",_hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="//hm.baidu.com/hm.js?"+_baId;var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script src="https://c.mipcdn.com/static/v1/mip.js"></script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script><a id="rocket" href="#top" class=""></a><script type="text/javascript" src="/hux/js/totop.js?v=1.0.0" async=""></script><script type="text/javascript" src="/hux/js/toc.js?v=1.0.0" async=""></script> <img src="/hux/img/apple-touch-icon.png" width="0" height="0"></body></html>