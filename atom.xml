<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CSjiabin&#39;s Blog</title>
  
  <subtitle>Goals determine what you going to be!!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://csjiabin.github.io/"/>
  <updated>2021-06-12T14:57:26.661Z</updated>
  <id>https://csjiabin.github.io/</id>
  
  <author>
    <name>csjiabin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>DayDart 具备 Day.js 一样API的时间处理库.</title>
    <link href="https://csjiabin.github.io/2021/06/12/DayDart%E5%85%B7%E5%A4%87Day-js%E4%B8%80%E6%A0%B7API%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%84%E7%90%86%E5%BA%93/"/>
    <id>https://csjiabin.github.io/2021/06/12/DayDart%E5%85%B7%E5%A4%87Day-js%E4%B8%80%E6%A0%B7API%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%84%E7%90%86%E5%BA%93/</id>
    <published>2021-06-12T14:40:29.000Z</published>
    <updated>2021-06-12T14:57:26.661Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Getting-Started"><a href="#Getting-Started" class="headerlink" title="Getting Started"></a>Getting Started</h2><p><a href="https://github.com/csjiabin/daydart" target="_blank" rel="noopener">DayDart</a> 具备 Day.js 一样 API 的时间处理库。</p><h3 id="Install"><a href="#Install" class="headerlink" title="Install"></a>Install</h3><p>在项目下运行此命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dart pub add daydart</span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">flutter pub add daydart</span><br></pre></td></tr></table></figure><p>这将在包的 <code>pubspec.yaml</code> 中添加这样的一行（并运行一个隐式 <code>dart pub get</code>）：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">dependencies:</span></span><br><span class="line">  <span class="attr">daydart:</span> <span class="string">^0.0.1</span></span><br></pre></td></tr></table></figure><p>也可以直接在 <code>pubspec.yaml</code> 中直接git路径引入，然后手动执行<code>dart pub get</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">dependencies:</span></span><br><span class="line">  <span class="attr">daydart:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">https://github.com/csjiabin/daydart.git</span></span><br><span class="line">    <span class="attr">ref:</span> <span class="string">main</span></span><br></pre></td></tr></table></figure><h3 id="导入-Import"><a href="#导入-Import" class="headerlink" title="导入 Import"></a>导入 Import</h3><p>现在在您的 Dart 代码中，您可以使用：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:daydart/daydart.dart'</span>;</span><br></pre></td></tr></table></figure><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><p><code>DayDart</code> 对象是不可变的，所有的调用都将返回一个新的 <code>DayDart</code> 对象。</p><ul><li><a href="#解析">解析</a><ul><li><a href="#默认值">当前时间</a></li><li><a href="#字符串">时间字符串</a></li><li><a href="#DateTime-对象">DateTime 对象</a></li><li><a href="#时间戳">时间戳</a></li><li><a href="#克隆">克隆</a></li><li><a href="#验证">验证</a></li></ul></li><li><a href="#获取">获取</a><ul><li><a href="#年">年</a></li><li><a href="#月">月</a></li><li><a href="#季度">季度</a></li><li><a href="#日">日</a></li><li><a href="#星期">星期</a></li><li><a href="#小时">小时</a></li><li><a href="#分钟">分钟</a></li><li><a href="#秒">秒</a></li><li><a href="#毫秒">毫秒</a></li></ul></li><li><a href="#操作">操作</a><ul><li><a href="#增加">增加</a></li><li><a href="#减少">减少</a></li></ul></li><li><a href="#查询">查询</a><ul><li><a href="#是否之前">是否之前</a></li><li><a href="#是否相同">是否相同</a></li><li><a href="#是否之后">是否之后</a></li><li><a href="#是否相同或之前">是否相同或之前</a></li><li><a href="#是否相同或之后">是否相同或之后</a></li><li><a href="#是否之间">是否之间</a></li><li><a href="#判断是否为-DayDart">判断是否为 DayDart</a></li><li><a href="#是否闰年">是否闰年</a></li></ul></li><li><a href="#显示">显示</a><ul><li><a href="#格式化">格式化</a></li><li><a href="#转-DateTime-对象">转 DateTime 对象</a></li><li><a href="#转-List">转 List</a></li><li><a href="#转-Map">转 Map</a></li><li><a href="#转-IOS-8601-字符串">转 IOS 8601 字符串</a></li><li><a href="#转字符串">转字符串</a></li></ul></li></ul><hr><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>在 <code>DayDart</code> 中传入支持的格式。</p><h4 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h4><p>不带参数调用 DayDart()将返回一个新的<code>DayDart</code>对象，其中包含当前日期和时间</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DayDart now = DayDart()</span><br></pre></td></tr></table></figure><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>以 <code>ISO 8601</code> 格式解析给定字符串并返回<code>DayDart</code>对象实例。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DayDart(<span class="string">'2018-04-04'</span>)</span><br></pre></td></tr></table></figure><h4 id="DateTime-对象"><a href="#DateTime-对象" class="headerlink" title="DateTime 对象"></a>DateTime 对象</h4><p>传入的一个 DateTime 对象。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DayDart(<span class="built_in">DateTime</span>.now());</span><br></pre></td></tr></table></figure><h4 id="时间戳-毫秒"><a href="#时间戳-毫秒" class="headerlink" title="时间戳(毫秒)"></a>时间戳(毫秒)</h4><p>通过一个毫秒的整数值来创建<code>DayDart</code></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DayDart(<span class="number">1623484401193</span>);</span><br></pre></td></tr></table></figure><h4 id="克隆"><a href="#克隆" class="headerlink" title="克隆"></a>克隆</h4><p>所有 DayDart 对象是不可变的。如果需要的话，DayDart#clone 仍然可以创建当前对象的一个克隆。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DayDart a = DayDart()</span><br><span class="line">DayDart b = a.clone()</span><br></pre></td></tr></table></figure><p>在<code>DayDart</code>对象上调用 DayDart()也会克隆它。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DayDart a = DayDart()</span><br><span class="line">DayDart b = DayDart(a)</span><br></pre></td></tr></table></figure><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>返回一个布尔值，指示<code>DayDart</code>对象是否包含有效日期。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DayDart().isValid()</span><br></pre></td></tr></table></figure><h3 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h3><h4 id="年"><a href="#年" class="headerlink" title="年"></a>年</h4><p>获取或设置年份。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DayDart().year();</span><br><span class="line">DayDart().year(<span class="number">2000</span>);</span><br></pre></td></tr></table></figure><h4 id="月"><a href="#月" class="headerlink" title="月"></a>月</h4><p>获取或设置月份。</p><p>接受 1 到 12 的数字。如果超过这个范围，将一直持续到年底。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DayDart().month();</span><br><span class="line">DayDart().month(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><h4 id="季度"><a href="#季度" class="headerlink" title="季度"></a>季度</h4><p>获取或设置季度。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DayDart(<span class="string">'2010-04-01'</span>).quarter() <span class="comment">// 2</span></span><br><span class="line">DayDart(<span class="string">'2010-04-01'</span>).quarter(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><h4 id="日"><a href="#日" class="headerlink" title="日"></a>日</h4><p>获取或设置月份的日期。</p><p>接受从 1 到 31 的数字。如果超过这个范围，将持续到日。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DayDart().day()</span><br><span class="line">DayDart().day(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h4 id="星期"><a href="#星期" class="headerlink" title="星期"></a>星期</h4><p>获取星期</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DayDart().week()</span><br></pre></td></tr></table></figure><h4 id="小时"><a href="#小时" class="headerlink" title="小时"></a>小时</h4><p>获取或设置小时。</p><p>接受 0 到 59 的数字。如果超过这个范围，将持续到日。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DayDart().hour()</span><br><span class="line">DayDart().hour(<span class="number">12</span>)</span><br></pre></td></tr></table></figure><h4 id="分钟"><a href="#分钟" class="headerlink" title="分钟"></a>分钟</h4><p>获取或设置分钟。</p><p>接受 0 到 59 的数字。如果超过这个范围，将持续到小时</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DayDart().minute()</span><br><span class="line">DayDart().minute(<span class="number">12</span>)</span><br></pre></td></tr></table></figure><h4 id="秒"><a href="#秒" class="headerlink" title="秒"></a>秒</h4><p>获取或设置秒。</p><p>接受 0 到 59 的数字。如果超过这个范围，将持续到分钟。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DayDart().second()</span><br><span class="line">DayDart().second(<span class="number">12</span>)</span><br></pre></td></tr></table></figure><h4 id="毫秒"><a href="#毫秒" class="headerlink" title="毫秒"></a>毫秒</h4><p>获取或设置毫秒。</p><p>接受 0 到 999 的数字。如果超过这个范围，将持续到秒。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DayDart().millisecond()</span><br><span class="line">DayDart().millisecond(<span class="number">12</span>)</span><br></pre></td></tr></table></figure><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><p>一旦有了 DayDart 对象，您可能希望以某种方式对其进行操作。</p><p>DayDart 支持这样的方法链接:</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DayDart(<span class="string">'2019-01-25'</span>)..add(<span class="number">1</span>, <span class="string">'day'</span>)..subtract(<span class="number">1</span>, <span class="string">'year'</span>)..year(<span class="number">2009</span>)..toString()</span><br></pre></td></tr></table></figure><p>所有可用单位列表</p><table><thead><tr><th>单位</th><th>缩写</th><th>描述</th></tr></thead><tbody><tr><td>day</td><td>D</td><td>天(1 到 31)</td></tr><tr><td>month</td><td>M</td><td>月份(1-12)</td></tr><tr><td>year</td><td>y</td><td>年</td></tr><tr><td>hour</td><td>h</td><td>小时</td></tr><tr><td>minute</td><td>m</td><td>分钟</td></tr><tr><td>second</td><td>s</td><td>秒</td></tr><tr><td>millisecond</td><td>ms</td><td>毫秒</td></tr></tbody></table><h4 id="增加"><a href="#增加" class="headerlink" title="增加"></a>增加</h4><p>返回一个克隆的 <code>DayDart</code> 对象，并添加指定的时间。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DayDart().add(<span class="number">7</span>, <span class="string">'day'</span>)</span><br></pre></td></tr></table></figure><p>单位不区分大小写，支持复数和缩写形式。</p><h4 id="减少"><a href="#减少" class="headerlink" title="减少"></a>减少</h4><p>返回克隆的<code>DayDart</code>对象，并减去指定的时间。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DayDart().subtract(<span class="number">7</span>, <span class="string">'day'</span>)</span><br></pre></td></tr></table></figure><p>单位不区分大小写，支持复数和缩写形式。</p><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p>所有可用单位列表</p><table><thead><tr><th>单位</th><th>缩写</th><th>描述</th></tr></thead><tbody><tr><td>day</td><td>D</td><td>天</td></tr><tr><td>month</td><td>M</td><td>月份</td></tr><tr><td>year</td><td>y</td><td>年</td></tr><tr><td>hour</td><td>h</td><td>小时</td></tr><tr><td>minute</td><td>m</td><td>分钟</td></tr><tr><td>second</td><td>s</td><td>秒</td></tr><tr><td>millisecond</td><td>ms</td><td>毫秒</td></tr></tbody></table><h4 id="是否之前"><a href="#是否之前" class="headerlink" title="是否之前"></a>是否之前</h4><p>这指示<code>DayDart</code>对象是否在另一个提供的 date-time 之前。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DayDart().isBefore(DayDart(<span class="string">'2011-01-01'</span>)) <span class="comment">// default milliseconds</span></span><br></pre></td></tr></table></figure><p>如果希望将粒度限制为单位而不是毫秒，则将其作为第二个参数传递。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DayDart().isBefore(<span class="string">'2011-01-01'</span>, <span class="string">'year'</span>)</span><br></pre></td></tr></table></figure><h4 id="是否相同"><a href="#是否相同" class="headerlink" title="是否相同"></a>是否相同</h4><p>这指示<code>DayDart</code>对象是否与另一个提供的 date-time 相同。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DayDart().isSame(DayDart(<span class="string">'2011-01-01'</span>)) <span class="comment">// default milliseconds</span></span><br></pre></td></tr></table></figure><p>如果希望将粒度限制为单位而不是毫秒，则将其作为第二个参数传递。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DayDart().isSame(<span class="string">'2011-01-01'</span>, <span class="string">'year'</span>)</span><br></pre></td></tr></table></figure><p>单位不区分大小写，支持复数和缩写形式。</p><h4 id="是否之后"><a href="#是否之后" class="headerlink" title="是否之后"></a>是否之后</h4><p>这指示<code>DayDart</code>对象是否在另一个提供的 date-time 之后。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DayDart().isAfter(DayDart(<span class="string">'2011-01-01'</span>)) <span class="comment">// default milliseconds</span></span><br></pre></td></tr></table></figure><p>如果希望将粒度限制为单位而不是毫秒，则将其作为第二个参数传递。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DayDart().isAfter(<span class="string">'2011-01-01'</span>, <span class="string">'year'</span>)</span><br></pre></td></tr></table></figure><p>单位不区分大小写，支持复数和缩写形式。</p><h4 id="是否相同或之前"><a href="#是否相同或之前" class="headerlink" title="是否相同或之前"></a>是否相同或之前</h4><p>这表明<code>DayDart</code>对象是相同的还是在另一个提供的 date-time 之前。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DayDart().isSameOrBefore(DayDart(<span class="string">'2011-01-01'</span>)) <span class="comment">// default milliseconds</span></span><br></pre></td></tr></table></figure><p>如果希望将粒度限制为单位而不是毫秒，则将其作为第二个参数传递。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DayDart().isSameOrBefore(<span class="string">'2011-01-01'</span>, <span class="string">'year'</span>)</span><br></pre></td></tr></table></figure><p>单位不区分大小写，支持复数和缩写形式。</p><h4 id="是否相同或之后"><a href="#是否相同或之后" class="headerlink" title="是否相同或之后"></a>是否相同或之后</h4><p>这指示<code>DayDart</code>对象是相同的还是在另一个提供的 date-time 之后。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DayDart().isSameOrAfter(DayDart(<span class="string">'2011-01-01'</span>)) <span class="comment">// default milliseconds</span></span><br></pre></td></tr></table></figure><p>如果希望将粒度限制为单位而不是毫秒，则将其作为第二个参数传递。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DayDart().isSameOrAfter(<span class="string">'2011-01-01'</span>, <span class="string">'year'</span>)</span><br></pre></td></tr></table></figure><p>单位不区分大小写，支持复数和缩写形式。</p><h4 id="是否之间"><a href="#是否之间" class="headerlink" title="是否之间"></a>是否之间</h4><p>这指示<code>DayDart</code>对象是否位于另外两个提供的 date-time 之间。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DayDart(<span class="string">'2010-10-20'</span>).isBetween(<span class="string">'2010-10-19'</span>, DayDart(<span class="string">'2010-10-25'</span>))<span class="comment">// default milliseconds</span></span><br></pre></td></tr></table></figure><p>如果希望将粒度限制为单位而不是毫秒，则将其作为第三个参数传递。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DayDart().isBetween(<span class="string">'2010-10-19'</span>, <span class="string">'2010-10-25'</span>, <span class="string">'year'</span>)</span><br></pre></td></tr></table></figure><p>单位不区分大小写，支持复数和缩写形式。</p><h4 id="判断是否为-DayDart"><a href="#判断是否为-DayDart" class="headerlink" title="判断是否为 DayDart"></a>判断是否为 DayDart</h4><p>这指示变量是否为 <code>DayDart</code> 对象。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DayDart.isDayjs(DayDart()) <span class="comment">// true</span></span><br><span class="line">DayDart.isDayjs(<span class="built_in">DateTime</span>.now()) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>也可以使用 <code>is</code> 操作符:</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DayDart() <span class="keyword">is</span> DayDart <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h4 id="是否闰年"><a href="#是否闰年" class="headerlink" title="是否闰年"></a>是否闰年</h4><p>这表明 Day.js 对象的年份是否为闰年。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DayDart(<span class="string">'2000-01-01'</span>).isLeapYear() <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="显示"><a href="#显示" class="headerlink" title="显示"></a>显示</h3><h4 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h4><p>根据传入的令牌字符串获取格式化的日期。</p><p>要对字符进行转义，请将它们括在方括号中(例如’MM’)。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DayDart().format()</span><br><span class="line"></span><br><span class="line">DayDart(<span class="string">'2019-01-25'</span>).format(<span class="string">'dd/MM/yyyy'</span>) <span class="comment">// '25/01/2019'</span></span><br></pre></td></tr></table></figure><p>所有可用解析标记的列表</p><table><thead><tr><th>标识</th><th>描述</th></tr></thead><tbody><tr><td>d</td><td>DAY</td></tr><tr><td>E</td><td>ABBR_WEEKDAY</td></tr><tr><td>EEEE</td><td>WEEKDAY</td></tr><tr><td>LLL</td><td>ABBR_STANDALONE_MONTH</td></tr><tr><td>LLLL</td><td>STANDALONE_MONTH</td></tr><tr><td>M</td><td>NUM_MONTH</td></tr><tr><td>Md</td><td>NUM_MONTH_DAY</td></tr><tr><td>MEd</td><td>NUM_MONTH_WEEKDAY_DAY</td></tr><tr><td>MMM</td><td>ABBR_MONTH</td></tr><tr><td>MMMd</td><td>ABBR_MONTH_DAY</td></tr><tr><td>MMMEd</td><td>ABBR_MONTH_WEEKDAY_DAY</td></tr><tr><td>MMMM</td><td>MONTH</td></tr><tr><td>MMMMd</td><td>MONTH_DAY</td></tr><tr><td>MMMMEEEEd</td><td>MONTH_WEEKDAY_DAY</td></tr><tr><td>QQQ</td><td>ABBR_QUARTER</td></tr><tr><td>QQQQ</td><td>QUARTER</td></tr><tr><td>y</td><td>YEAR</td></tr><tr><td>yM</td><td>YEAR_NUM_MONTH</td></tr><tr><td>yMd</td><td>YEAR_NUM_MONTH_DAY</td></tr><tr><td>yMEd</td><td>YEAR_NUM_MONTH_WEEKDAY_DAY</td></tr><tr><td>yMMM</td><td>YEAR_ABBR_MONTH</td></tr><tr><td>yMMMd</td><td>YEAR_ABBR_MONTH_DAY</td></tr><tr><td>yMMMEd</td><td>YEAR_ABBR_MONTH_WEEKDAY_DAY</td></tr><tr><td>yMMMM</td><td>YEAR_MONTH</td></tr><tr><td>yMMMMd</td><td>YEAR_MONTH_DAY</td></tr><tr><td>yMMMMEEEEd</td><td>YEAR_MONTH_WEEKDAY_DAY</td></tr><tr><td>yQQQ</td><td>YEAR_ABBR_QUARTER</td></tr><tr><td>yQQQQ</td><td>YEAR_QUARTER</td></tr><tr><td>H</td><td>HOUR24</td></tr><tr><td>Hm</td><td>HOUR24_MINUTE</td></tr><tr><td>Hms</td><td>HOUR24_MINUTE_SECOND</td></tr><tr><td>j</td><td>HOUR</td></tr><tr><td>jm</td><td>HOUR_MINUTE</td></tr><tr><td>jms</td><td>HOUR_MINUTE_SECOND</td></tr><tr><td>m</td><td>MINUTE</td></tr><tr><td>ms</td><td>MINUTE_SECOND</td></tr><tr><td>s</td><td>SECOND</td></tr></tbody></table><h4 id="转-DateTime-对象"><a href="#转-DateTime-对象" class="headerlink" title="转 DateTime 对象"></a>转 DateTime 对象</h4><p>要获得从<code>DayDart</code>对象解析的本地日期对象的副本，请使用 DayDart#toDate。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DayDart(<span class="string">'2019-01-25'</span>).toDate()</span><br></pre></td></tr></table></figure><h4 id="转-List"><a href="#转-List" class="headerlink" title="转 List"></a>转 List</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DayDart(<span class="string">'2019-01-25'</span>).toList() <span class="comment">// [ 2019, 0, 25, 0, 0, 0, 0 ]</span></span><br></pre></td></tr></table></figure><h4 id="转-Map"><a href="#转-Map" class="headerlink" title="转 Map"></a>转 Map</h4><p>返回具有日期属性的<code>Map</code>。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">DayDart(<span class="string">'2019-01-25'</span>).toMap()</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  years: 2019,</span></span><br><span class="line"><span class="comment">  months: 0,</span></span><br><span class="line"><span class="comment">  date: 25,</span></span><br><span class="line"><span class="comment">  hours: 0,</span></span><br><span class="line"><span class="comment">  minutes: 0,</span></span><br><span class="line"><span class="comment">  seconds: 0,</span></span><br><span class="line"><span class="comment">  milliseconds: 0</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="转-IOS-8601-字符串"><a href="#转-IOS-8601-字符串" class="headerlink" title="转 IOS 8601 字符串"></a>转 IOS 8601 字符串</h4><p>格式化为 ISO 8601 字符串。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DayDart(<span class="string">'2019-01-25'</span>).toISOString() <span class="comment">// 2019-01-25T00:00:00.000</span></span><br></pre></td></tr></table></figure><h4 id="转字符串"><a href="#转字符串" class="headerlink" title="转字符串"></a>转字符串</h4><p>返回日期的字符串表示形式。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DayDart(<span class="string">'2019-01-25'</span>).toString() <span class="comment">// 2019-01-25 00:00:00.000</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Getting-Started&quot;&gt;&lt;a href=&quot;#Getting-Started&quot; class=&quot;headerlink&quot; title=&quot;Getting Started&quot;&gt;&lt;/a&gt;Getting Started&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/csjiabin/daydart&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;DayDart&lt;/a&gt; 具备 Day.js 一样 API 的时间处理库。&lt;/p&gt;
&lt;h3 id=&quot;Install&quot;&gt;&lt;a href=&quot;#Install&quot; class=&quot;headerlink&quot; title=&quot;Install&quot;&gt;&lt;/a&gt;Install&lt;/h3&gt;
    
    </summary>
    
    
      <category term="dart" scheme="https://csjiabin.github.io/categories/dart/"/>
    
    
      <category term="dart" scheme="https://csjiabin.github.io/tags/dart/"/>
    
      <category term="dayjs" scheme="https://csjiabin.github.io/tags/dayjs/"/>
    
      <category term="flutter" scheme="https://csjiabin.github.io/tags/flutter/"/>
    
  </entry>
  
  <entry>
    <title>iTerm2 + Oh My Zsh 打造舒适终端体验</title>
    <link href="https://csjiabin.github.io/2020/07/24/iTerm2-OhMyZsh%E6%89%93%E9%80%A0%E8%88%92%E9%80%82%E7%BB%88%E7%AB%AF%E4%BD%93%E9%AA%8C/"/>
    <id>https://csjiabin.github.io/2020/07/24/iTerm2-OhMyZsh%E6%89%93%E9%80%A0%E8%88%92%E9%80%82%E7%BB%88%E7%AB%AF%E4%BD%93%E9%AA%8C/</id>
    <published>2020-07-24T02:53:08.000Z</published>
    <updated>2020-11-02T09:26:56.676Z</updated>
    
    <content type="html"><![CDATA[<h3 id="效果预览"><a href="#效果预览" class="headerlink" title="效果预览"></a>效果预览</h3><p><img data-src="/uploads/post/1595562710638.jpg" alt="效果图"><br>本文以<code>Mac</code>为例，因为 <code>powerline</code> 以及 <code>homebrew</code> 均需要安装 <code>command line tool</code>，网络条件优越的同学在执行本文下面内容之前，可以先安装 <code>XCode</code> 并打开运行一次（会初始化安装 components），省去以后在 <code>iterm2</code> 中的等待时间。</p><p>另外，<code>git</code> 也是必要的，各位可以自行下载安装，除了网络没有任何坑：<a href="https://git-scm.com" target="_blank" rel="noopener">https://git-scm.com</a></p><h3 id="下载安装-iTerm2"><a href="#下载安装-iTerm2" class="headerlink" title="下载安装 iTerm2"></a>下载安装 iTerm2</h3><p>下载地址：<a href="https://www.iterm2.com/downloads.html" target="_blank" rel="noopener">https://www.iterm2.com/downloads.html</a></p><p>下载的是压缩文件，解压后是执行程序文件，你可以直接双击，或者直接将它拖到 Applications 目录下。</p><p>或者你可以直接使用 Homebrew 进行安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew cask install iterm2</span><br></pre></td></tr></table></figure><h3 id="安装-Oh-my-zsh"><a href="#安装-Oh-my-zsh" class="headerlink" title="安装 Oh my zsh"></a>安装 Oh my zsh</h3><p>Oh my zsh 开源地址：<a href="https://github.com/ohmyzsh/ohmyzsh" target="_blank" rel="noopener">https://github.com/ohmyzsh/ohmyzsh</a><br>安装方法有两种，可以使用 curl 或 wget，看自己环境或喜好：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># curl 安装方式</span></span><br><span class="line">sh -c <span class="string">"<span class="variable">$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)</span>"</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># wget 安装方式</span></span><br><span class="line">sh -c <span class="string">"<span class="variable">$(wget -O- https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)</span>"</span></span><br></pre></td></tr></table></figure><blockquote><p>安装oh my zsh失败：curl: (7) Failed to connect to raw.githubusercontent.com port 443: Connection refused<br>解决方案参考地址：<a href="https://blog.csdn.net/huangpin815/article/details/105606135" target="_blank" rel="noopener">https://blog.csdn.net/huangpin815/article/details/105606135</a></p></blockquote><h3 id="安装-PowerLine"><a href="#安装-PowerLine" class="headerlink" title="安装 PowerLine"></a>安装 PowerLine</h3><p>Powerline 是 agnoster 主题的依赖。具体可以在 repo 里查询到：<a href="https://github.com/agnoster/agnoster-zsh-theme" target="_blank" rel="noopener">https://github.com/agnoster/agnoster-zsh-theme</a><br>powerline 官网：<a href="https://powerline.readthedocs.io/en/latest/installation.html" target="_blank" rel="noopener">https://powerline.readthedocs.io/en/latest/installation.html</a><br>安装 powerline 的方式依然简单，也只需要一条命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install powerline-status --user</span><br></pre></td></tr></table></figure><p>没有安装 pip 的同学可能会碰到 zsh: command not found: pip，则先执行安装 pip 指令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo easy_install pip</span><br></pre></td></tr></table></figure><h3 id="下载、安装库字体库"><a href="#下载、安装库字体库" class="headerlink" title="下载、安装库字体库"></a>下载、安装库字体库</h3><p>安装<a href="https://github.com/powerline/fonts" target="_blank" rel="noopener">字体库</a>需要首先将项目 git clone 至本地，然后执行源码中的 install.sh。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/powerline/fonts.git --depth=1</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> fonts</span><br><span class="line"></span><br><span class="line">./install.sh</span><br></pre></td></tr></table></figure><p>安装完成后提示所有字体均已下载到/Users/xxx/Library/Fonts 路径下</p><p>安装好字体库之后，我们来设置 iTerm2 的字体，具体的操作是 iTerm2 -&gt; Preferences -&gt; Profiles -&gt; Text，在 Font 区域选中 Change Font，然后找到 Meslo LG 字体。有 L、M、S 可选，看个人喜好：</p><p><img data-src="/uploads/post/7.png" alt="设置iTerm 2"></p><h3 id="安装配色方案"><a href="#安装配色方案" class="headerlink" title="安装配色方案"></a>安装配色方案</h3><p>配色方案在使用 VIM 或 Colorful Log 时会变得非常有用，同时界面也不会一片黑绿一样死板。</p><p>同样使用 git clone 的方式下载源码进行安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git://github.com/altercation/solarized.git</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> solarized/iterm2-colors-solarized</span><br><span class="line"></span><br><span class="line">open .</span><br></pre></td></tr></table></figure><p>在打开的 finder 窗口中，双击 Solarized Dark.itermcolors 和 Solarized Light.itermcolors 即可安装明暗两种配色：<br><img data-src="/uploads/post/8.png" alt="安装配色"><br>再次进入 iTerm2 -&gt; Preferences -&gt; Profiles -&gt; Colors -&gt; Color Presets 中根据个人喜好选择这两种配色中的一种即可：<br><img data-src="/uploads/post/9.png" alt="选择配色"></p><h3 id="安装主题"><a href="#安装主题" class="headerlink" title="安装主题"></a>安装主题</h3><ol><li>下载 agnoster 主题，执行脚本安装：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/fcamblor/oh-my-zsh-agnoster-fcamblor.git</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> oh-my-zsh-agnoster-fcamblor</span><br><span class="line"></span><br><span class="line">./install</span><br></pre></td></tr></table></figure><p>到下载的工程里面运行 install 文件,主题将安装到~/.oh-my-zsh/themes 目录下</p><ol start="2"><li>设置该主题</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi ~/.zshrc</span><br></pre></td></tr></table></figure><p>进入<code>~/.zshrc</code>编辑<code>.zshrc</code>文件，然后将<code>ZSH_THEME</code>后面的字段改为<code>agnoster</code>。<code>ZSH_THEME=&quot;agnoster&quot;</code>（agnoster 即为要设置的主题）执行</p><h3 id="增加指令高亮效果"><a href="#增加指令高亮效果" class="headerlink" title="增加指令高亮效果"></a>增加指令高亮效果</h3><p>指令高亮效果作用是当用户输入正确命令时指令会绿色高亮，错误时命令红色高亮.<br>这是 oh my zsh 的一个插件，安装方式与 theme 大同小异：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/.oh-my-zsh/custom/plugins/</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/zsh-users/zsh-syntax-highlighting.git</span><br><span class="line">vi ~/.zshrc</span><br></pre></td></tr></table></figure><p>这时我们再次打开 zshrc 文件进行编辑。找到 plugins，此时 plugins 中应该已经有了 git，我们需要把高亮插件也加上：<br><img data-src="/uploads/post/13.png" alt="plugins"></p><p>请务必保证插件顺序，zsh-syntax-highlighting 必须在最后一个。</p><p>然后在文件的最后一行添加：source ~/.oh-my-zsh/custom/plugins/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh</p><p>按一下 esc 调出 vi 命令，输入:wq 保存并退出 vi 模式。</p><p>执行命令使刚才的修改生效：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.zshrc</span><br></pre></td></tr></table></figure><h4 id="可选择、命令补全"><a href="#可选择、命令补全" class="headerlink" title="可选择、命令补全"></a>可选择、命令补全</h4><p>跟代码高亮的安装方式一样，这也是一个 zsh 的插件，叫做 zsh-autosuggestion，用于命令建议和补全。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/.oh-my-zsh/custom/plugins/</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/zsh-users/zsh-autosuggestions.git</span><br><span class="line">vi ~/.zshrc</span><br></pre></td></tr></table></figure><p>找到 plugins，加上这个插件即可：<br><img data-src="/uploads/post/15.png" alt="plugins"><br><img data-src="/uploads/post/16.png" alt="插件效果"><br>如果感觉补全命令的字体不太清晰，与背景颜色太过相近，其实可以自己调整一下字体颜色。</p><p>Preferences -&gt; Profiles -&gt; Colors 中有 Foreground 是标准字体颜色，ANSI Colors 中 Bright 的第一个是补全的字体颜色。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>Mac 系统默认使用 dash 作为终端，可以使用命令修改默认使用 zsh：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chsh -s /bin/zsh</span><br></pre></td></tr></table></figure><p>如果想修改回默认 dash，同样使用 chsh 命令即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chsh -s /bin/bash</span><br></pre></td></tr></table></figure><p>如果找不到.zshrc 文件问题，可以自己手动创建.zshrc</p><p>卸载<code>oh my zsh</code>，在命令行输入如下命令，回车即可：<code>uninstall_oh_my_zsh</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;效果预览&quot;&gt;&lt;a href=&quot;#效果预览&quot; class=&quot;headerlink&quot; title=&quot;效果预览&quot;&gt;&lt;/a&gt;效果预览&lt;/h3&gt;&lt;p&gt;&lt;img data-src=&quot;/uploads/post/1595562710638.jpg&quot; alt=&quot;效果图&quot;&gt;&lt;br&gt;本文以&lt;code&gt;Mac&lt;/code&gt;为例，因为 &lt;code&gt;powerline&lt;/code&gt; 以及 &lt;code&gt;homebrew&lt;/code&gt; 均需要安装 &lt;code&gt;command line tool&lt;/code&gt;，网络条件优越的同学在执行本文下面内容之前，可以先安装 &lt;code&gt;XCode&lt;/code&gt; 并打开运行一次（会初始化安装 components），省去以后在 &lt;code&gt;iterm2&lt;/code&gt; 中的等待时间。&lt;/p&gt;
&lt;p&gt;另外，&lt;code&gt;git&lt;/code&gt; 也是必要的，各位可以自行下载安装，除了网络没有任何坑：&lt;a href=&quot;https://git-scm.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://git-scm.com&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="工具" scheme="https://csjiabin.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="git" scheme="https://csjiabin.github.io/tags/git/"/>
    
      <category term="iTerm2" scheme="https://csjiabin.github.io/tags/iTerm2/"/>
    
      <category term="zsh" scheme="https://csjiabin.github.io/tags/zsh/"/>
    
      <category term="pip" scheme="https://csjiabin.github.io/tags/pip/"/>
    
      <category term="powerline" scheme="https://csjiabin.github.io/tags/powerline/"/>
    
  </entry>
  
  <entry>
    <title>Git的使用</title>
    <link href="https://csjiabin.github.io/2020/07/23/Git%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://csjiabin.github.io/2020/07/23/Git%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2020-07-23T05:52:30.000Z</published>
    <updated>2020-11-02T09:26:56.672Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常见操作"><a href="#常见操作" class="headerlink" title="常见操作"></a>常见操作</h2><h3 id="全局配置用户信息"><a href="#全局配置用户信息" class="headerlink" title="全局配置用户信息"></a>全局配置用户信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;username&quot;</span><br><span class="line"></span><br><span class="line">git config --global user.email &quot;email@email.com&quot;</span><br></pre></td></tr></table></figure><h2 id="分支的合并"><a href="#分支的合并" class="headerlink" title="分支的合并"></a>分支的合并</h2><h3 id="场景：基于-master-分支的代码，开发一个新的特性"><a href="#场景：基于-master-分支的代码，开发一个新的特性" class="headerlink" title="场景：基于 master 分支的代码，开发一个新的特性"></a>场景：基于 master 分支的代码，开发一个新的特性</h3><p>如果你直接在 master 分支上开发这个新特性，是不好的，万一你在开发<code>特性1</code>的时候，领导突然又要叫你去开发<code>特性2</code>，就不好处理了。难道开发的两个特性都提交到 master？一会儿提交特性 1 的 commit，一会儿提交特性 2 的 commit？这会导致 commit 记录很混乱。</p><p>所以，我给你的建议做法是：给每个特性都单独建一个的新的分支。</p><p>比如说，我专门给<code>特性1</code>建一个分支<code>feature_item_recommend</code>。具体做法如下：</p><p>（1）基于 master 分支，创建一个新的分支，起名为<code>feature_item_recommend</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b feature_item_recommend</span><br><span class="line"></span><br><span class="line">Switched to a new branch <span class="string">'feature_item_recommend'</span></span><br></pre></td></tr></table></figure><p>上面这行命令，相当于：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch feature_item_recommend    <span class="comment"># 创建新的分支</span></span><br><span class="line">git checkout feature_item_recommend  <span class="comment"># 切换到新的分支</span></span><br></pre></td></tr></table></figure><p>（2）在新的分支<code>feature_item_recommend</code>上，完成开发工作，并 commit 、push。</p><p>（3）将分支<code>feature_item_recommend</code>上的开发进度<strong>合并</strong>到 master 分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout master  <span class="comment">#切换到master分支</span></span><br><span class="line"></span><br><span class="line">git merge feature_item_recommend    <span class="comment">#将分支 feature_item_recommend 的开发进度合并到 master 分支</span></span><br></pre></td></tr></table></figure><p>合并之后，<code>master</code>分支和<code>feature_item_recommend</code>分支会指向同一个位置。</p><p>（3）删除分支<code>feature_item_recommend</code>：</p><blockquote><p>既然 特性 1 开发完了，也放心地提交到 master 了，那我们就可以将这个分支删除了。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d feature_item_recommend</span><br></pre></td></tr></table></figure><p>注意，我们当前是处于<code>master</code>分支的位置，来删除<code>feature_item_recommend</code>分支。如果当前是处于<code>feature_item_recommend</code>分支，是没办法删除它自己的。</p><p>同理，当我转身去开发<code>特性2</code>的时候，也是采用同样的步骤。</p><h3 id="合并分支时，如果存在分叉"><a href="#合并分支时，如果存在分叉" class="headerlink" title="合并分支时，如果存在分叉"></a>合并分支时，如果存在分叉</h3><p><img data-src="/uploads/post/20180610_1650.png" alt=""></p><p>比如说上面这张图中，最早的时候，master 分支是位于<code>C2</code>节点。我基于<code>C2</code>节点，new 出一个新的分支<code>iss53</code>，我在<code>iss53</code>上提交了好几个 commit。</p><p>现在，我准备把<code>iss53</code>上的几个 commit 合并到 master 上，此时发现，master 分支已经前进到 C4 了。那该怎么合并呢？</p><p>合并的命令仍然是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br><span class="line"></span><br><span class="line">git merge iss53</span><br></pre></td></tr></table></figure><p><strong>解释</strong>：</p><p>这次合并的实现，并不同于简单的并入方式。这一次，我的开发历史是从更早的地方开始分叉的。</p><p>由于当前 master 分支所指向的 commit (C4)并非想要并入分支（iss53）的直接祖先，Git 不得不进行一些处理。就此例而言，Git 会用两个分支的末端（C4 和 C5）和它们的共同祖先（C2）进行一次简单的三方合并计算。</p><p>Git 没有简单地把分支指针右移，而是对三方合并的结果作一新的快照，并自动创建一个指向它的 commit（C6）（如下图所示）。我们把这个特殊的 commit 称作合并提交（mergecommit），因为它的祖先不止一个。</p><p>值得一提的是 Git 可以自己裁决哪个共同祖先才是最佳合并基础；这和 CVS 或 Subversion（1.5 以后的版本）不同，它们需要开发者手工指定合并基础。所以此特性让 Git 的合并操作比其他系统都要简单不少。</p><p><img data-src="/uploads/post/20180610_1710.png" alt=""></p><h3 id="解决合并时发生的冲突"><a href="#解决合并时发生的冲突" class="headerlink" title="解决合并时发生的冲突"></a>解决合并时发生的冲突</h3><p><img data-src="/uploads/post/20180610_1740.png" alt=""></p><p>如果 feature1 和 feature2 修改的是同一个文件中<strong>代码的同一个位置</strong>，那么，把 feature1 合并到 feature2 时，就会产生冲突。这个冲突需要人工解决。步骤如下：</p><p>（1）手动修改文件：手动修改冲突的那个文件，决定到底要用哪个分支的代码。</p><p>（2）git add：解决好冲突后，输入<code>git status</code>，会提示<code>Unmerged paths</code>。这个时候，输入<code>git add</code>即可，表示：<strong>修改冲突成功，加入暂存区</strong>。</p><p>（3）git commit 提交。</p><p>然后，我们可以继续把 feature1 分支合并到 master 分支，最后删除 feature1、feature2。</p><p><strong>注意</strong>：两个分支的同一个文件的不同地方合并时，git 会自动合并，不会产生冲突。</p><p>比如分支 feture1 对 index.html 原来的第二行之前加入了一段代码。<br>分支 feature2 对 index.html 在原来的最后一行的后面加入了一段代码。<br>这个时候在对两个分支合并，git 不会产生冲突，因为两个分支是修改同一文件的不同位置。<br>git 自动合并成功。不管是 git 自动合并成功，还是在人工解决冲突下合并成功，提交之前，都要对代码进行测试。</p><h2 id="日常操作积累"><a href="#日常操作积累" class="headerlink" title="日常操作积累"></a>日常操作积累</h2><h3 id="修改密码（曲线救国）"><a href="#修改密码（曲线救国）" class="headerlink" title="修改密码（曲线救国）"></a>修改密码（曲线救国）</h3><blockquote><p>网上查了很久，没找到答案。最终，在 cld 童鞋的提示下，采取如下方式进行曲线救国。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置当前仓库的用户名为空</span></span><br><span class="line">git config  user.name <span class="string">""</span></span><br></pre></td></tr></table></figure><p>然后，当我们再输入<code>git pull</code>等命令行时，就会被要求重新输入<em>新的</em>账号密码。此时，密码就可以修改成功了。最后，我们还要输入如下命令，还原当前仓库的用户名：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config user.name &quot;smyhvae&quot;</span><br></pre></td></tr></table></figure><h3 id="修改已经-push-的某次-commit-的作者信息"><a href="#修改已经-push-的某次-commit-的作者信息" class="headerlink" title="修改已经 push 的某次 commit 的作者信息"></a>修改已经 push 的某次 commit 的作者信息</h3><p>已经 push 的记录，如果要修改作者信息的话，只能 通过–force 命令。我反正是查了很久，但最终还是不敢用公司的仓库尝试。</p><p>参考链接：</p><ul><li><a href="https://segmentfault.com/q/1010000006999861" target="_blank" rel="noopener">git 修改已提交的某一次的邮箱和用户信息</a></li></ul><p>看最后一条答案。</p><ul><li><a href="http://baurine.github.io/2015/08/22/git_update_author.html" target="_blank" rel="noopener">修改 git repo 历史提交的 author</a></li></ul><h3 id="将-branch1的某个commit1合并到branch2当中"><a href="#将-branch1的某个commit1合并到branch2当中" class="headerlink" title="将 branch1的某个commit1合并到branch2当中"></a>将 <code>branch1</code>的某个<code>commit1</code>合并到<code>branch2</code>当中</h3><p>切换到 branch2 中，然后执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git cherry-pick commit1</span><br></pre></td></tr></table></figure><h3 id="20190118-修改-GitHub-已提交的用户名和邮箱"><a href="#20190118-修改-GitHub-已提交的用户名和邮箱" class="headerlink" title="20190118-修改 GitHub 已提交的用户名和邮箱"></a>20190118-修改 GitHub 已提交的用户名和邮箱</h3><p>参考链接：（亲测有效）</p><ul><li><p><a href="https://cloud.tencent.com/developer/article/1352623" target="_blank" rel="noopener">修改 Git 全部 Commit 提交记录的用户名 Name 和邮箱 Email</a></p></li><li><p><a href="https://blog.csdn.net/yusufolu9/article/details/53706269" target="_blank" rel="noopener">Mac 运行 sh 文件，也就是传说中的 shell 脚本</a></p></li></ul><p>在执行<code>./email.sh</code>后，如果出现<code>permission denied</code>的错误，可以先执行<code>chmod 777 email.sh</code>，修改文件的权限。</p><h3 id="20200520-将-Git-项目迁移到另一个仓库"><a href="#20200520-将-Git-项目迁移到另一个仓库" class="headerlink" title="20200520-将 Git 项目迁移到另一个仓库"></a>20200520-将 Git 项目迁移到另一个仓库</h3><p>我们假设旧仓库的项目名称叫<code>old-repository</code>，新仓库的项目名称叫<code>new-repository</code>。操作如下：</p><p>（1）创建旧仓库的裸克隆：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --bare https://github.com/exampleuser/old-repository.git</span><br></pre></td></tr></table></figure><p>执行上述命令后，会在本地生成一个名叫 <code>old-repository.git</code>的文件夹。</p><p>（2）迁移到新仓库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> old-repository.git</span><br><span class="line"></span><br><span class="line">git push --mirror https://github.com/exampleuser/new-repository.git</span><br></pre></td></tr></table></figure><p>这样的话，项目就已经迁移到新仓库了。</p><p>注意，我们<strong>不需要</strong>手动新建一个空的新仓库，当我们执行上述命令之后，新仓库就已经自动创建好了。</p><p>参考链接：</p><ul><li><p><a href="https://help.github.com/cn/github/creating-cloning-and-archiving-repositories/duplicating-a-repository" target="_blank" rel="noopener">复制仓库</a></p></li><li><p><a href="https://moelove.info/2016/12/04/Git-%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E5%92%8C%E8%A3%B8%E4%BB%93%E5%BA%93/" target="_blank" rel="noopener">Git 本地仓库和裸仓库</a></p></li></ul><h2 id="git-客户端推荐"><a href="#git-客户端推荐" class="headerlink" title="git 客户端推荐"></a>git 客户端推荐</h2><p>市面上的 Git 客户端我基本都用过了，我最推荐的一款 Git 客户端是：<a href="https://www.git-tower.com" target="_blank" rel="noopener">Tower</a> 或者 <a href="https://git-fork.com" target="_blank" rel="noopener">Fork</a>。</p><ul><li>GitUp：<a href="https://gitup.co/" target="_blank" rel="noopener">https://gitup.co/</a></li></ul><p>20180623 时，网上看了下 Git 客户端的推荐排名：</p><p><img data-src="/uploads/post/20180623_1210.png" alt=""></p><p><strong>SmartGit</strong>：</p><p>商业用途收费， 个人用户免费：</p><p><img data-src="/uploads/post/20180623_1305.png" alt=""></p><h2 id="推荐书籍"><a href="#推荐书籍" class="headerlink" title="推荐书籍"></a>推荐书籍</h2><ul><li>《pro.git 中文版》</li></ul><h2 id="推荐连接"><a href="#推荐连接" class="headerlink" title="推荐连接"></a>推荐连接</h2><ul><li><a href="https://www.cnblogs.com/wangiqngpei557/p/6056624.html" target="_blank" rel="noopener">聊下 git pull –rebase</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;常见操作&quot;&gt;&lt;a href=&quot;#常见操作&quot; class=&quot;headerlink&quot; title=&quot;常见操作&quot;&gt;&lt;/a&gt;常见操作&lt;/h2&gt;&lt;h3 id=&quot;全局配置用户信息&quot;&gt;&lt;a href=&quot;#全局配置用户信息&quot; class=&quot;headerlink&quot; title=&quot;全局配置用户信息&quot;&gt;&lt;/a&gt;全局配置用户信息&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git config --global user.name &amp;quot;username&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git config --global user.email &amp;quot;email@email.com&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="工具" scheme="https://csjiabin.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="git" scheme="https://csjiabin.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>VS Code的使用</title>
    <link href="https://csjiabin.github.io/2020/04/24/VSCode%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://csjiabin.github.io/2020/04/24/VSCode%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2020-04-24T11:07:45.000Z</published>
    <updated>2020-11-02T09:26:56.675Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>VS Code  本来是前端人员专用，但由于它实在是太好用了，于是，各种开发方向的码农也正在用 VS Code 作为他们的主力编程工具。甚至是一些写作的同学，也把 VS Code 作为 markdown 写作工具。</p><p>写下这篇文章，是顺势而为。</p><h3 id="一、VS-Code-的介绍"><a href="#一、VS-Code-的介绍" class="headerlink" title="一、VS Code 的介绍"></a>一、VS Code 的介绍</h3><p>VS Code 的全称是 Visual Studio Code，是一款开源的、免费的、跨平台的、高性能的、轻量级的代码编辑器。它在性能、语言支持、开源社区方面，都做的很不错。</p><h3 id="编辑器-与-IDE"><a href="#编辑器-与-IDE" class="headerlink" title="编辑器 与 IDE"></a>编辑器 与 IDE</h3><p><code>IDE</code>和<code>编辑器</code>是有区别的：</p><ul><li><p><strong>IDE</strong> ：对代码会有较好的智能提示，同时侧重于工程项目，对项目的开发、调试工作有较好的图像化界面的支持，因此比较笨重。比如 Eclipse 的定位就是 IDE。</p></li><li><p><strong>编辑器</strong>：要相对轻量许多，侧重于文本的编辑。比如 Sublime Text 的定位就是编辑器。再比如 Windows 系统自带的「记事本」就是最简单的编辑器。</p></li></ul><p>需要注意的是，VS Code 的定位是<code>编辑器</code>，而非<code>IDE</code>。但 VS Code 又比一般的编辑器的功能要丰富许多。</p><h3 id="VS-Code的一些补充"><a href="#VS-Code的一些补充" class="headerlink" title="VS Code的一些补充"></a>VS Code的一些补充</h3><ul><li><p>VS Code 的使命，是让开发者在编辑器里拥有 IDE 那样的开发体验，比如代码的智能提示、语法检查、图形化的调试工具、插件扩展、版本管理等。</p></li><li><p>VS Code 的源代码以MIT协议开源。</p></li><li><p>VS Code 自带了 TypeScript 和 Node.js 的支持。也就是说，你在书写 JS 和 TS 时，是自带智能提示的。</p></li><li><p>有一点你可能不知道，VS Code 这个客户端软件是用 js 语言开发出来的（具体请自行查阅关键字<code>Electron</code>）。有句话说得好：能用 js 实现的功能，最终一定会用 js 实现。</p></li></ul><h3 id="前端利器之争：-VS-Code-与-WebStorm"><a href="#前端利器之争：-VS-Code-与-WebStorm" class="headerlink" title="前端利器之争： VS Code 与  WebStorm"></a>前端利器之争： VS Code 与  WebStorm</h3><p>前端小白最喜欢问的一个问题是：哪个编辑器/IDE 好用？是VS Code还是 WebStorm （WebStorm 其实是 IntelliJ IDEA的定制版）？我来做个对比：</p><ul><li><p><strong>哪个更酷</strong>：显然 VS Code 更酷。</p></li><li><p><strong>内存占用情况</strong>：根据我的观察，VS Code是很占内存的（尤其是当你打开多个窗口的时候），但如果你的内存条够用的话，使用起来是不会有任何卡顿的感觉的。相比之下，IDEA 不仅非常占内存，而且还非常卡顿。</p></li><li><p><strong>使用比例</strong>：当然是 VS Code 更胜一筹。先不说别的，我就拿数据说话，我目前所在的前端团队有100人左右，绝大部分前端同学都在用  VS Code，妥妥的。</p></li></ul><p>所以，如果你以后还问这个问题，那就真有些掉底了。</p><h3 id="VS-Code-的安装"><a href="#VS-Code-的安装" class="headerlink" title="VS Code 的安装"></a>VS Code 的安装</h3><ul><li>VS Code 官网：<a href="https://code.visualstudio.com" target="_blank" rel="noopener">https://code.visualstudio.com</a></li></ul><p>VS Code 的安装很简单，直接去官网下载安装包，然后双击安装即可。</p><p><img data-src="/uploads/post/20190313_1750_2.png" alt=""></p><p>上图中，直接点击 download 下载安装即可。</p><h2 id="二、VS-Code快捷键"><a href="#二、VS-Code快捷键" class="headerlink" title="二、VS Code快捷键"></a>二、VS Code快捷键</h2><p>VS Code用得熟不熟，首先就看你是否会用快捷键。以下列出的内容，都是常用快捷键，而加粗部分的快捷键，使用频率则非常高。</p><p>掌握10%的内容，足矣应对90%的工作。熟练使用它们，你就已经很牛了。</p><h3 id="移动光标"><a href="#移动光标" class="headerlink" title="移动光标"></a>移动光标</h3><table><thead><tr><th align="left">Mac快捷键</th><th align="left">Win快捷键</th><th align="left">作用</th><th align="left">备注</th></tr></thead><tbody><tr><td align="left"><strong>Cmd + ←</strong></td><td align="left"><strong>Fn + ←</strong></td><td align="left">将光标定位到当前行的最左侧</td><td align="left">很常用</td></tr><tr><td align="left"><strong>Cmd + →</strong></td><td align="left"><strong>Fn + →</strong></td><td align="left">将光标定位到当前行的最右侧</td><td align="left">很常用</td></tr><tr><td align="left">Cmd + ↑</td><td align="left">Ctrl + Home</td><td align="left">将光标定位到文章的第一行</td><td align="left"></td></tr><tr><td align="left">Cmd + ↓</td><td align="left">Ctrl + End</td><td align="left">将光标定位到文章的最后一行</td><td align="left"></td></tr></tbody></table><p>根据上面的快捷键，我们可以举一反三。补充如下：</p><ul><li><p>「方向键」：在<strong>单个字符</strong>之间移动光标</p></li><li><p>「option + 左右方向键」：在<strong>单词</strong>之间移动光标（很常用）。注：Win 快捷键是「Ctrl + 左右方向键」。</p></li><li><p>「Cmd + 左右方向键」：在<strong>整行</strong>之间移动光标（很常用）。注：Win 的快捷键是「Fn + 左右方向键」</p></li><li><p>「<code>Cmd + Shift + \</code>」：在<strong>代码块</strong>之间移动光标。</p></li></ul><h3 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h3><table><thead><tr><th align="left">Mac快捷键</th><th align="left">Win快捷键</th><th align="left">作用</th><th align="left">备注</th></tr></thead><tbody><tr><td align="left"><strong>option + Backspace</strong></td><td align="left"><strong>Ctrl + Backspace</strong></td><td align="left">删除光标之前的一个单词</td><td align="left">英文有效，很常用</td></tr><tr><td align="left">option + delete</td><td align="left">Ctrl + delete</td><td align="left">删除光标之后的一个单词</td><td align="left"></td></tr><tr><td align="left"><strong>Cmd + delete</strong></td><td align="left"></td><td align="left">删除光标之前的整行内容</td><td align="left">很常用</td></tr><tr><td align="left">Cmd + delete</td><td align="left"></td><td align="left">删除光标之后的整行内容</td><td align="left"></td></tr><tr><td align="left">Cmd + shift + K</td><td align="left">Ctrl + Shift + K</td><td align="left">删除整行</td><td align="left">「Cmd + X」的作用是剪切，但也可以删除整行</td></tr></tbody></table><p>备注：上面所讲到的移动光标、删除操作的快捷键，在其他编辑器里，也是同样的操作。</p><h3 id="编辑操作"><a href="#编辑操作" class="headerlink" title="编辑操作"></a>编辑操作</h3><table><thead><tr><th align="left">Mac快捷键</th><th align="left">Win快捷键</th><th align="left">作用</th><th align="left">备注</th></tr></thead><tbody><tr><td align="left"><strong>Cmd + Enter</strong></td><td align="left">Ctrl + Enter</td><td align="left">在当前行下面新增一行，然后跳至该行</td><td align="left">即使光标不在行尾，也能快速向下插入一行</td></tr><tr><td align="left"><strong>Option + ↑</strong></td><td align="left">Alt + ↑</td><td align="left">将代码向上移动</td><td align="left">很常用</td></tr><tr><td align="left"><strong>Option + ↓</strong></td><td align="left">Alt + ↓</td><td align="left">将代码向下移动</td><td align="left">很常用</td></tr><tr><td align="left"><strong>Option + Shift + ↑</strong></td><td align="left">Alt + Shift + ↑</td><td align="left">将代码向上复制</td><td align="left">很常用</td></tr><tr><td align="left"><strong>Option + Shift + ↓</strong></td><td align="left">Alt + Shift + ↓</td><td align="left">将代码向下复制</td><td align="left">很常用</td></tr></tbody></table><h3 id="JS语言相关"><a href="#JS语言相关" class="headerlink" title="JS语言相关"></a>JS语言相关</h3><table><thead><tr><th align="left">Mac快捷键</th><th align="left">Win快捷键</th><th align="left">作用</th><th align="left">备注</th></tr></thead><tbody><tr><td align="left">Cmd + /</td><td align="left">Ctrl + /</td><td align="left">添加单行注释</td><td align="left">很常用</td></tr><tr><td align="left"><strong>Option + Shift + F</strong></td><td align="left">Alt + shift + F</td><td align="left">代码格式化</td><td align="left">很常用</td></tr><tr><td align="left">Ctrl + J</td><td align="left"></td><td align="left">将多行代码合并为一行</td><td align="left">Win 用户可在命令面板搜索”合并行“</td></tr><tr><td align="left">Cmd +</td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">Cmd + U</td><td align="left">Ctrl + U</td><td align="left">将光标的移动回退到上一个位置</td><td align="left">撤销光标的移动和选择</td></tr></tbody></table><h3 id="跳转操作"><a href="#跳转操作" class="headerlink" title="跳转操作"></a>跳转操作</h3><table><thead><tr><th align="left">Mac快捷键</th><th align="left">Win快捷键</th><th align="left">作用</th><th align="left">备注</th></tr></thead><tbody><tr><td align="left"><strong>Ctrl + Tab</strong></td><td align="left"><strong>Ctrl + Tab</strong></td><td align="left">在已经打开的文件之间进行跳转</td><td align="left"></td></tr><tr><td align="left"><strong>Cmd + P</strong></td><td align="left">Ctrl + P</td><td align="left">在当前的项目工程里，<strong>全局</strong>搜索文件</td><td align="left">很常用</td></tr><tr><td align="left"><strong>Ctrl + G</strong></td><td align="left"><strong>Ctrl + G</strong></td><td align="left">跳转到指定行</td><td align="left"></td></tr><tr><td align="left">Cmd + Shift + O</td><td align="left">Ctrl + shift + O</td><td align="left">在当前文件的各种<strong>方法之间</strong>进行跳转</td><td align="left"></td></tr></tbody></table><h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><table><thead><tr><th align="left">Mac快捷键</th><th align="left">Win快捷键</th><th align="left">作用</th><th align="left">备注</th></tr></thead><tbody><tr><td align="left">Cmd + F</td><td align="left">Ctrl + F</td><td align="left">在当前文件中搜索，光标在搜索框里</td><td align="left"></td></tr><tr><td align="left"><strong>Cmd + G</strong></td><td align="left"><strong>F3</strong></td><td align="left">在当前文件中搜索，光标仍停留在编辑器里</td><td align="left">很巧妙</td></tr><tr><td align="left"><strong>Cmd + Shift + F</strong></td><td align="left">Ctrl + Shift +F</td><td align="left">全局搜索</td><td align="left">很常用</td></tr></tbody></table><h3 id="多光标的使用"><a href="#多光标的使用" class="headerlink" title="多光标的使用"></a>多光标的使用</h3><p><strong>技巧1</strong>：按住 「Option」键（windows 用户是按住「Alt」键） ，然后在页面中希望中现光标的位置点击鼠标。</p><p><strong>技巧2</strong>：选中某个文本，然后反复按住快捷键「 Cmd + D 」键（windows 用户是按住「Ctrl + D」键）， 即可将全文中与光标当前所在位置的词相同的词逐一加入选择。</p><p><strong>技巧3</strong>：选中一堆文本后，按住「Option + Shift + i」键（windows 用户是按住「Alt + Shift + I」键），既可在<strong>每一行的末尾</strong>都创建一个光标。</p><h3 id="工作区快捷键"><a href="#工作区快捷键" class="headerlink" title="工作区快捷键"></a>工作区快捷键</h3><table><thead><tr><th align="left">Mac快捷键</th><th align="left">Win快捷键</th><th align="left">作用</th><th align="left">备注</th></tr></thead><tbody><tr><td align="left"><strong>cmd +/-</strong></td><td align="left"><strong>ctrl +/-</strong></td><td align="left">将工作区放大/缩小（包括代码字体、左侧导航栏）</td><td align="left">在投影仪场景经常用到</td></tr><tr><td align="left"><strong>Cmd + B</strong></td><td align="left">Ctrl + B</td><td align="left">显示/隐藏侧边栏</td><td align="left">很实用</td></tr><tr><td align="left"><code>Cmd + \</code></td><td align="left"><code>Ctrl + \</code></td><td align="left">创建多个编辑器</td><td align="left">比较实用</td></tr><tr><td align="left"><strong>Cmd + Option + 左右方向键</strong></td><td align="left">Ctrl + Pagedown/Pageup</td><td align="left">在已经打开的文件之间进行<strong>切换</strong></td><td align="left">非常实用</td></tr><tr><td align="left">Ctrl + Tab</td><td align="left">Ctrl + Tab</td><td align="left">在已经打开的文件之间进行跳转</td><td align="left">不如上面的快捷键实用</td></tr><tr><td align="left">Cmd + J</td><td align="left">Ctrl + J</td><td align="left">显示/隐藏控制台</td><td align="left"></td></tr></tbody></table><h3 id="自定义快捷键"><a href="#自定义快捷键" class="headerlink" title="自定义快捷键"></a>自定义快捷键</h3><p>按住快捷键「Cmd + Shift + P」，弹出命令面板，在命令面板中输入“快捷键”，可以进入快捷键的设置。</p><p>当然，你也可以选择菜单栏「偏好设置 –&gt; 键盘快捷方式」，进入快捷键的设置：</p><p><img data-src="/uploads/post/20190329_2120.png" alt=""></p><h3 id="快捷键列表"><a href="#快捷键列表" class="headerlink" title="快捷键列表"></a>快捷键列表</h3><p>你可以点击 VS Code 左下角的齿轮按钮，效果如下：</p><p><img data-src="/uploads/post/20190418_1738.png" alt=""></p><p>上图中，在展开的菜单中选择「键盘快捷方式」，就可以查看和修改所有的快捷键列表了：</p><p><img data-src="/uploads/post/20190418_1739_2.png" alt=""></p><h2 id="四、命令面板的使用"><a href="#四、命令面板的使用" class="headerlink" title="四、命令面板的使用"></a>四、命令面板的使用</h2><p>Mac用户按住快捷键 <code>Cmd+Shift+P</code> （Windows用户按住快捷键<code>Ctrl+Shift+P</code>），可以打开命令面板。效果如下：</p><p><img data-src="/uploads/post/20190329_1750_2.png" alt=""></p><p>如果们需要修改一些设置项，可以通过「命令面板」来操作，效率会更高。这里列举一些。</p><h3 id="字体设置"><a href="#字体设置" class="headerlink" title="字体设置"></a>字体设置</h3><p>在命令面板输入“字体”，可以进行字体的设置，效果如下：</p><p><img data-src="/uploads/post/20190329_2110.png" alt=""></p><p>当然，你也可以在菜单栏，选择「首选项-设置-常用设置」，在这个设置项里修改字体大小。</p><h3 id="快捷键设置"><a href="#快捷键设置" class="headerlink" title="快捷键设置"></a>快捷键设置</h3><p>在命令面板输入“快捷键”，就可以进入快捷键的设置。</p><h3 id="大小写转换"><a href="#大小写转换" class="headerlink" title="大小写转换"></a>大小写转换</h3><p>选中文本后，在命令面板中输入<code>transfrom</code>，就可以修改文本的大小写了。</p><p><img data-src="/uploads/post/20190414_1751.png" alt=""></p><h3 id="使用命令行启动-VS-Code"><a href="#使用命令行启动-VS-Code" class="headerlink" title="使用命令行启动 VS Code"></a>使用命令行启动 VS Code</h3><p>（1）输入快捷键「Cmd + Shift + P 」，选择<code>install code command</code>：</p><p><img data-src="/uploads/post/20191103_1327.png" alt=""></p><p>（2）使用命令行：</p><ul><li><p><code>code</code>命令：启动 VS Code 软件</p></li><li><p><code>code pathName/fileName</code>命令：通过 VS Code 软件打开指定目录/指定文件。</p></li></ul><h2 id="五、VS-Code-的常见设置项"><a href="#五、VS-Code-的常见设置项" class="headerlink" title="五、VS Code 的常见设置项"></a>五、VS Code 的常见设置项</h2><h3 id="1、VS-Code-设置为中文语言"><a href="#1、VS-Code-设置为中文语言" class="headerlink" title="1、VS Code 设置为中文语言"></a>1、VS Code 设置为中文语言</h3><p>Mac用户按住快捷键 <code>Cmd+Shift+P</code> （Windows用户按住快捷键<code>Ctrl+Shift+P</code>），打开命令面板。</p><p>在命令面板中，输入<code>Configure Display Language</code>，选择<code>Install additional languages</code>，然后安装插件<code>Chinese (Simplified) Language Pack for Visual Studio Code</code>即可。</p><p>或者，我们可以直接安装插件<code>Chinese (Simplified) Language Pack for Visual Studio Code</code>，是一样的。</p><p>安装完成后，重启VS Code。</p><h3 id="2、面包屑（Breadcrumb）"><a href="#2、面包屑（Breadcrumb）" class="headerlink" title="2、面包屑（Breadcrumb）"></a>2、面包屑（Breadcrumb）</h3><p>打开 VS Code 的设置项，选择「用户设置 -&gt; 工作台 -&gt; 导航路径」，如下图所示：</p><p><img data-src="/uploads/post/20191108_1550.png" alt=""></p><p>上图中，将红框部分打钩即可。</p><p>设置成功后，我们就可以查看到当前文件的「层级结构」，非常方便。如下图所示：</p><p><img data-src="/uploads/post/20190415_2009.png" alt=""></p><h3 id="3、是否显示代码的行号"><a href="#3、是否显示代码的行号" class="headerlink" title="3、是否显示代码的行号"></a>3、是否显示代码的行号</h3><p>VS Code 默认显示代码的行号。你可以在设置项里搜索 <code>editor.lineNumbers</code>修改设置，配置项如下：</p><p><img data-src="/uploads/post/20190417_2140.png" alt=""></p><p>我建议保留这个设置项，无需修改。</p><h3 id="4、右侧是否显示代码的缩略图"><a href="#4、右侧是否显示代码的缩略图" class="headerlink" title="4、右侧是否显示代码的缩略图"></a>4、右侧是否显示代码的缩略图</h3><p>VS Code 会在代码的右侧，默认显示缩略图。你可以在设置项里搜索 <code>editor.minimap</code>进行设置，配置项如下：</p><p><img data-src="/uploads/post/20190417_2156.png" alt=""></p><h3 id="6、将当前行代码高亮显示（更改光标所在行的背景色）"><a href="#6、将当前行代码高亮显示（更改光标所在行的背景色）" class="headerlink" title="6、将当前行代码高亮显示（更改光标所在行的背景色）"></a>6、将当前行代码高亮显示（更改光标所在行的背景色）</h3><p>当我们把光标放在某一行时，这一行的背景色并没有发生变化。如果想<strong>高亮显示</strong>当前行的代码，需要设置两步：</p><p>（1）在设置项里搜索<code>editor.renderLineHighlight</code>，将选项值设置为<code>all</code>或者<code>line</code>。</p><p>（2）在设置项里增加如下内容：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">"workbench.colorCustomizations": &#123;</span><br><span class="line">    "editor.lineHighlightBackground": "#00000090",</span><br><span class="line">    "editor.lineHighlightBorder": "#00000000"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面两行代码的意思是，修改光标所在行的背景色（背景色设置为全黑，透明度90%），修改光标所在行的边框色。</p><h3 id="7、改完代码后立即自动保存"><a href="#7、改完代码后立即自动保存" class="headerlink" title="7、改完代码后立即自动保存"></a>7、改完代码后立即自动保存</h3><p><strong>方式一</strong>：</p><p>改完代码后，默认不会自动保存。你可以在设置项里搜索<code>files.autoSave</code>，修改配置项如下：</p><p><img data-src="/uploads/post/20190417_2216.png" alt=""></p><p>上图中，我们将配置项修改为<code>onFocusChange</code>之后，那么，当光标离开该文件后，这个文件就会自动保存了。<strong>非常方便</strong>。</p><p><strong>方式二</strong>：</p><p>当然，你也可以直接在菜单栏选择「文件-自动保存」。勾选年后，当你写完代码后，文件会立即实时保存。</p><h3 id="8、保存代码后，是否立即格式化"><a href="#8、保存代码后，是否立即格式化" class="headerlink" title="8、保存代码后，是否立即格式化"></a>8、保存代码后，是否立即格式化</h3><p>保存代码后，默认<strong>不会立即</strong>进行代码的格式化。你可以在设置项里搜索<code>editor.formatOnSave</code>查看该配置项：</p><p><img data-src="/uploads/post/20190417_2213.png" alt=""></p><p>我觉得这个配置项保持默认就好，不用打钩。</p><h3 id="9、空格-or-制表符"><a href="#9、空格-or-制表符" class="headerlink" title="9、空格 or 制表符"></a>9、空格 or 制表符</h3><p>VS Code 会根据你所打开的文件来决定该使用空格还是制表。也就是说，如果你的项目中使用的都是制表符，那么，当你在写新的代码时，按下tab 键后，编辑器就会识别成制表符。</p><p>常见的设置项如下：</p><ul><li><strong>editor.detectIndentation</strong>：自动检测（默认开启）。截图如下：</li></ul><p><img data-src="/uploads/post/20190417_2205.png" alt=""></p><ul><li><strong>editor.insertSpaces</strong>：按 Tab 键时插入空格（默认）。截图如下：</li></ul><p><img data-src="/uploads/post/20190417_2207.png" alt=""></p><ul><li><strong>editor.tabSize</strong>：一个制表符默认等于四个空格。截图如下：</li></ul><p><img data-src="/uploads/post/20190417_2209.png" alt=""></p><h3 id="10、新建文件后的默认文件类型"><a href="#10、新建文件后的默认文件类型" class="headerlink" title="10、新建文件后的默认文件类型"></a>10、新建文件后的默认文件类型</h3><p>当我们按下快捷键「Cmd + N」新建文件时，VS Code 默认无法识别这个文件到底是什么类型的，因此也就无法识别相应的语法高亮。如果你想修改默认的文件类型，可以在设置项里搜索<code>files.defaultLanguage</code>，设置项如下：</p><p><img data-src="/uploads/post/20190417_2221.png" alt=""></p><p>上图中的红框部分，填入你期望的默认文件类型。我填的是<code>html</code>类型，你也可以填写成 <code>javascript</code> 或者 <code>markdown</code>，或者其他的语言类型。</p><h3 id="11、删除文件时，是否弹出确认框"><a href="#11、删除文件时，是否弹出确认框" class="headerlink" title="11、删除文件时，是否弹出确认框"></a>11、删除文件时，是否弹出确认框</h3><p>当我们在 VS Code 中删除文件时，默认会弹出确认框。如果你想修改设置，可以在设置项里搜索<code>xplorer.confirmDelete</code>。截图如下：</p><p><img data-src="/uploads/post/20190418_1758.png" alt=""></p><p>我建议这个设置项保持默认的打钩就好，不用修改。删除文件前的弹窗提示，也是为了安全考虑，万一手贱不小心删了呢？</p><h2 id="六、VS-Code-设置-高级进阶"><a href="#六、VS-Code-设置-高级进阶" class="headerlink" title="六、VS Code 设置-高级进阶"></a>六、VS Code 设置-高级进阶</h2><h3 id="1、文件对比"><a href="#1、文件对比" class="headerlink" title="1、文件对比"></a>1、文件对比</h3><p>VS Code 默认支持<strong>对比两个文件的内容</strong>。选中两个文件，然后右键选择「将已选项进行比较」即可，效果如下：</p><p><img data-src="/uploads/post/20190329_1756.png" alt=""></p><p>VS Code自带的对比功能并不够强大，我们可以安装插件<code>compareit</code>，进行更丰富的对比。比如说，安装完插件<code>compareit</code>之后，我们可以将「当前文件」与「剪切板」里的内容进行对比：</p><p><img data-src="/uploads/post/20190329_1757.png" alt=""></p><h3 id="2、查找某个函数在哪些地方被调用了"><a href="#2、查找某个函数在哪些地方被调用了" class="headerlink" title="2、查找某个函数在哪些地方被调用了"></a>2、查找某个函数在哪些地方被调用了</h3><p>比如我已经在<code>a.js</code>文件里调用了 <code>foo()</code>函数。那么，如果我想知道<code>foo()</code>函数在其他文件中是否也被调用了，该怎么做呢？</p><p>做法如下：在 <code>a.js</code> 文件里，选中<code>foo()</code>函数（或者将光标放置在<code>foo()</code>函数上），然后按住快捷键「Shift + F12」，就能看到 <code>foo()</code>函数在哪些地方被调用了，比较实用。</p><h3 id="3、鼠标操作"><a href="#3、鼠标操作" class="headerlink" title="3、鼠标操作"></a>3、鼠标操作</h3><ul><li><p>在当前行的位置，鼠标三击，可以选中当前行。</p></li><li><p>用鼠标单击文件的<strong>行号</strong>，可以选中当前行。</p></li><li><p>在某个<strong>行号</strong>的位置，<strong>上下移动鼠标，可以选中多行</strong>。</p></li></ul><h3 id="4、重构"><a href="#4、重构" class="headerlink" title="4、重构"></a>4、重构</h3><p>重构分很多种，我们来举几个例子。</p><p><strong>1、命名重构</strong>：</p><p>当我们尝试去修改某个函数（或者变量名）时，我们可以把光标放在上面，然后按下「F2」键，那么，这个函数（或者变量名）出现的地方都会被修改。</p><p><strong>2、方法重构</strong>：</p><p>选中某一段代码，这个时候，代码的左侧会出现一个「灯泡图标」，点击这个图标，就可以把这段代码提取为一个单独的函数。</p><h3 id="5、在当前文件中搜索"><a href="#5、在当前文件中搜索" class="headerlink" title="5、在当前文件中搜索"></a>5、在当前文件中搜索</h3><p>在上面的快捷键列表中，我们已经知道如下快捷键：</p><ul><li><p>Cmd + F（Win用户是Ctrl + F）：在当前文件中搜索，光标在搜索框里</p></li><li><p>Cmd + G（Win用户是 F3）：在当前文件中搜索，光标仍停留在编辑器里</p></li></ul><p>另外，你可能会注意到，搜索框里有很多按钮，每个按钮都对应着不同的功能，如下图所示：</p><p><img data-src="/uploads/post/20190415_2052.png" alt=""></p><p>上图中，你可以通过「Tab」键和「Shift + Tab」键在输入框和替换框之间进行切换。</p><p>「在选定内容中查找」这个功能还是比较实用的。你也可以在设置项里搜索 <code>editor.find.autoFindInSelection</code>，勾选该设置项后，那么，当你选中指定内容后，然后按住「Cmd + F」，就可以<strong>自动</strong>只在这些内容里进行查找。该设置项如下图所示：</p><p><img data-src="/uploads/post/20191108_1655.png" alt=""></p><h3 id="6、全局搜索"><a href="#6、全局搜索" class="headerlink" title="6、全局搜索"></a>6、全局搜索</h3><p>在上面的快捷键列表中，我们已经知道如下快捷键：</p><ul><li>Cmd + Shift + F（Win用户是Ctrl + Shift +F）：在全局的文件夹中进行搜索。效果如下：</li></ul><p><img data-src="/uploads/post/20190415_2107.png" alt=""></p><p>上图中，你可以点击红框部分，展开更多的配置项。</p><h3 id="7、Git版本管理"><a href="#7、Git版本管理" class="headerlink" title="7、Git版本管理"></a>7、Git版本管理</h3><p>VS Code 自带了 Git 版本管理，如下图所示：</p><p><img data-src="/uploads/post/20190418_1850.png" alt=""></p><p>上图中，我们可以在这里进行常见的git 命令操作。如果你还不熟悉 <strong>Git版本管理</strong>，先去补补课吧。</p><p>与此同时，我建议安装插件<code>GitLens</code>，它是 VS Code 中我最推荐的一个插件，简直是Git神器，码农必备。</p><h3 id="8、将工作区放大-缩小"><a href="#8、将工作区放大-缩小" class="headerlink" title="8、将工作区放大/缩小"></a>8、将工作区放大/缩小</h3><p>我们在上面的设置项里修改字体大小后，仅仅只是修改了代码的字体大小。</p><p>如果你想要缩放整个工作区（包括代码的字体、左侧导航栏的字体等），可以按下快捷键「<strong>cmd +/-</strong>」。windows用户是按下「ctrl +/-」</p><p><strong>当我们在给别人演示代码的时候，这一招十分管用</strong>。</p><p>如果你想恢复默认的工作区大小，可以在命令面板输入<code>重置缩放</code>（英文是<code>reset zoom</code>）</p><h3 id="9、创建多层子文件夹"><a href="#9、创建多层子文件夹" class="headerlink" title="9、创建多层子文件夹"></a>9、创建多层子文件夹</h3><p>我们可以在新建文件夹的时候，如果直接输入<code>aa/bb/cc</code>，比如：</p><p><img data-src="/uploads/post/20190418_2022.png" alt=""></p><p>那么，就可以创建多层子文件夹，效果如下：</p><p><img data-src="/uploads/post/20190418_2023.png" alt=""></p><h3 id="10、-vscode-文件夹的作用"><a href="#10、-vscode-文件夹的作用" class="headerlink" title="10、.vscode 文件夹的作用"></a>10、.vscode 文件夹的作用</h3><p>如果你发现项目的根目录下有一个<code>.vscode</code>文件夹，说明这个文件夹代表的是当前项目的配置。</p><p>这个文件夹里可能包含以下集中文件：</p><ul><li><p><code>settings.json</code>：工作空间设置。只针对当前项目有效。比如说，我可以在这里面要求当前项目的代码统一使用制表符，而不需要要求每一位码农去修改各自的配置文件。</p></li><li><p><code>sftp.json</code>：ftp文件传输的配置。</p></li></ul><h3 id="11、自带终端"><a href="#11、自带终端" class="headerlink" title="11、自带终端"></a>11、自带终端</h3><p>我们可以按下「Ctrl + `」打开 VS Code 自带的终端。我认为内置终端并没有那么好用，我更建议你使用第三方的终端 <strong>item2</strong>。</p><h3 id="12、markdown语法支持"><a href="#12、markdown语法支持" class="headerlink" title="12、markdown语法支持"></a>12、markdown语法支持</h3><p>VS Code自带 markdown 语法高亮，写完 md 文件之后，你可以点击右上角的按钮进行预览，如下图所示：</p><p><img data-src="/uploads/post/20190418_1907.png" alt=""></p><p>你也可以在控制面板输入<code>Markdown: 打开预览</code>，直接全屏预览 markdown文件。</p><h3 id="13、Emmet-in-VS-Code"><a href="#13、Emmet-in-VS-Code" class="headerlink" title="13、Emmet in VS Code"></a>13、Emmet in VS Code</h3><p><code>Emmet</code>可以极大的提高 html 和 css 的编写效率，它提供了一种非常简练的语法规则。</p><p>举个例子，我们在编辑器中输入缩写代码：<code>ul&gt;li*6</code> ，然后按下 Tab 键，即可得到如下代码片段：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p>VS Code 默认支持 Emmet。更多 Emmet 语法规则，请自行查阅。</p><h2 id="七、VS-Code-插件推荐"><a href="#七、VS-Code-插件推荐" class="headerlink" title="七、VS Code 插件推荐"></a>七、VS Code 插件推荐</h2><p>VS Code 有一个很强大的功能就是支持插件扩展。</p><p><img data-src="/uploads/post/20191108_1553_2.png" alt=""></p><p>上图中，点击红框部分，即可在输入框里，查找你想要的插件名，然后进行安装。</p><p>我来列举几个常见的插件，这些插件都很实用。</p><h3 id="GitLens-【荐】"><a href="#GitLens-【荐】" class="headerlink" title="GitLens 【荐】"></a>GitLens 【荐】</h3><p>我强烈建议你安装插件<code>GitLens</code>，它是 VS Code 中我最推荐的一个插件，简直是Git神器，码农必备。如果你不知道，那真是out了。</p><p>GitLens 在 Git 管理上有很多强大的功能，比如：</p><ul><li><p>将光标放置在代码的当前行，可以看到这样代码的提交者是谁，以及提交时间。这一点，是 GitLens 最便捷的功能。</p></li><li><p>查看某个 commit 的代码改动记录</p></li><li><p>查看不同的分支</p></li><li><p>可以将两个 commit 进行代码对比</p></li><li><p>甚至可以将两个 branch 分支进行整体的代码对比。这一点，简直是 GitLens 最强大的功能。当我们在不同分支review代码的时候，就可以用到这一招。</p></li></ul><h3 id="Bracket-Pair-Colorizer-2：突出显示成对的括号【荐】"><a href="#Bracket-Pair-Colorizer-2：突出显示成对的括号【荐】" class="headerlink" title="Bracket Pair Colorizer 2：突出显示成对的括号【荐】"></a>Bracket Pair Colorizer 2：突出显示成对的括号【荐】</h3><p><code>Bracket Pair Colorizer 2</code>插件：以不同颜色显示成对的括号，并用连线标注括号范围。</p><p>另外，还有个<code>Rainbow Brackets</code>插件，也可以突出显示成对的括号。</p><h3 id="sftp：文件传输"><a href="#sftp：文件传输" class="headerlink" title="sftp：文件传输"></a>sftp：文件传输</h3><p>如果你需要将本地文件通过 ftp 的形式上传到局域网的服务器，可以安装<code>sftp</code>这个插件，很好用。在公司会经常用到。</p><p>步骤如下：</p><p>（1）安装插件<code>sftp</code>。</p><p>（2）配置 <code>sftp.json</code>文件。 插件安装完成后，输入快捷键「cmd+shift+P」弹出命令面板，然后输入<code>sftp:config</code>，回车，当前工程的<code>.vscode</code>文件夹下就会自动生成一个<code>sftp.json</code>文件，我们需要在这个文件里配置的内容可以是：</p><ul><li><p><code>host</code>：服务器的IP地址</p></li><li><p><code>username</code>：工作站自己的用户名</p></li><li><p><code>privateKeyPath</code>：存放在本地的已配置好的用于登录工作站的密钥文件（也可以是ppk文件）</p></li><li><p><code>remotePath</code>：工作站上与本地工程同步的文件夹路径，需要和本地工程文件根目录同名，且在使用sftp上传文件之前，要手动在工作站上mkdir生成这个根目录</p></li><li><p><code>ignore</code>：指定在使用sftp: sync to remote的时候忽略的文件及文件夹，注意每一行后面有逗号，最后一行没有逗号</p></li></ul><p>举例如下：(注意，其中的注释需要去掉)</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"host"</span>: <span class="string">"192.168.xxx.xxx"</span>,     <span class="comment">//服务器ip</span></span><br><span class="line">    <span class="attr">"port"</span>: <span class="number">22</span>,     <span class="comment">//端口，sftp模式是22</span></span><br><span class="line">    <span class="attr">"username"</span>: <span class="string">""</span>, <span class="comment">//用户名</span></span><br><span class="line">    <span class="attr">"password"</span>: <span class="string">""</span>, <span class="comment">//密码</span></span><br><span class="line">    <span class="attr">"protocol"</span>: <span class="string">"sftp"</span>, <span class="comment">//模式</span></span><br><span class="line">    <span class="attr">"agent"</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">"privateKeyPath"</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">"passphrase"</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">"passive"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"interactiveAuth"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"remotePath"</span>: <span class="string">"/root/node/build/"</span>,  <span class="comment">//服务器上的文件地址</span></span><br><span class="line">    <span class="attr">"context"</span>: <span class="string">"./server/build"</span>,        <span class="comment">//本地的文件地址</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">"uploadOnSave"</span>: <span class="literal">true</span>,   <span class="comment">//监听保存并上传</span></span><br><span class="line">    <span class="attr">"syncMode"</span>: <span class="string">"update"</span>,</span><br><span class="line">    <span class="attr">"watcher"</span>: &#123;            <span class="comment">//监听外部文件</span></span><br><span class="line">        <span class="attr">"files"</span>: <span class="literal">false</span>,     <span class="comment">//外部文件的绝对路径</span></span><br><span class="line">        <span class="attr">"autoUpload"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">"autoDelete"</span>: <span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"ignore"</span>: [             <span class="comment">//忽略项</span></span><br><span class="line">        <span class="string">"**/.vscode/**"</span>,</span><br><span class="line">        <span class="string">"**/.git/**"</span>,</span><br><span class="line">        <span class="string">"**/.DS_Store"</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）在 VS Code的当前文件里，选择「右键 -&gt; upload」，就可以将本地的代码上传到 指定的 ftp 服务器上（也就是在上方 <code>host</code> 中配置的服务器ip）。</p><p>我们还可以选择「右键 -&gt; Diff with Remote」，就可以将本地的代码和 ftp 服务器上的代码做对比。</p><h3 id="Project-Manager"><a href="#Project-Manager" class="headerlink" title="Project Manager"></a>Project Manager</h3><p>工作中，我们经常会来回切换多个项目，每次都要找到对应项目的目录再打开，比较麻烦。Project Manager插件可以解决这样的烦恼，它提供了专门的视图来展示你的项目，我们可以把常用的项目保存在这里，需要时一键切换，十分方便。</p><h3 id="open-in-browser"><a href="#open-in-browser" class="headerlink" title="open in browser"></a>open in browser</h3><p>安装<code>open in browser</code>插件后，在 HTML 文件中「右键选择 –&gt; Open in Default Browser」，即可在浏览器中预览网页。</p><h3 id="highlight-icemode：选中相同的代码时，让高亮显示更加明显【荐】"><a href="#highlight-icemode：选中相同的代码时，让高亮显示更加明显【荐】" class="headerlink" title="highlight-icemode：选中相同的代码时，让高亮显示更加明显【荐】"></a>highlight-icemode：选中相同的代码时，让高亮显示更加明显【荐】</h3><p>VSCode自带的高亮显示，实在是不够显眼。用插件支持一下吧。</p><p>所用了这个插件之后，VS Code自带的高亮就可以关掉了：</p><p>在用户设置里添加<code>&quot;editor.selectionHighlight&quot;: false</code>即可。</p><p>参考链接：<a href="https://blog.csdn.net/palmer_kai/article/details/79548164" target="_blank" rel="noopener">vscode 选中后相同内容高亮插件推荐</a></p><h3 id="Color-Manager"><a href="#Color-Manager" class="headerlink" title="Color Manager"></a>Color Manager</h3><p>css 颜色管理。</p><h3 id="TODO-Highlight"><a href="#TODO-Highlight" class="headerlink" title="TODO Highlight"></a>TODO Highlight</h3><p>写代码过程中，突然发现一个Bug，但是又不想停下来手中的活，以免打断思路，怎么办？按照代码规范，我们一般是在代码中加个TODO注释。比如：（注意，一定要写成大写<code>TODO</code>，而不是小写的<code>todo</code>）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;TODO:这里有个bug，我一会儿再收拾你</span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;FIXME:我也不知道为啥， but it works only that way.</span><br></pre></td></tr></table></figure><p>安装了插件 <code>TODO Highlight</code>之后，按住「Cmd + Shift + P」打开命令面板，输入「Todohighlist」，选择相关的命令，我们就可以看到一个 todoList 的清单。</p><h3 id="WakaTime-【荐】"><a href="#WakaTime-【荐】" class="headerlink" title="WakaTime 【荐】"></a>WakaTime 【荐】</h3><p>统计写代码的时间。</p><h3 id="Code-Time"><a href="#Code-Time" class="headerlink" title="Code Time"></a>Code Time</h3><p><code>Code Time</code>插件：记录编程时间，统计代码行数。</p><p>安装该插件后，VS Code 底部的状态栏右下角可以看到时间统计。点击那个位置之后，选择「Code Time Dashboard」，即可查看统计结果。</p><p>备注：团长试了一下这个 code time 插件，发现统计结果不是很准。</p><h3 id="Markdown-Preview-Github-Styling-【荐】"><a href="#Markdown-Preview-Github-Styling-【荐】" class="headerlink" title="Markdown Preview Github Styling 【荐】"></a>Markdown Preview Github Styling 【荐】</h3><p>以 GitHub 风格预览 Markdown 样式。</p><h3 id="Markdown-Preview-Enhanced"><a href="#Markdown-Preview-Enhanced" class="headerlink" title="Markdown Preview Enhanced"></a>Markdown Preview Enhanced</h3><p>预览 Markdown 样式。</p><h3 id="Settings-Sync"><a href="#Settings-Sync" class="headerlink" title="Settings Sync"></a>Settings Sync</h3><ul><li><p>地址：<a href="https://github.com/shanalikhan/code-settings-sync" target="_blank" rel="noopener">https://github.com/shanalikhan/code-settings-sync</a></p></li><li><p>作用：多台设备之间，同步 VS Code 配置。通过登录 GitHub 账号来使用这个同步工具。</p></li></ul><h3 id="vscode-syncing"><a href="#vscode-syncing" class="headerlink" title="vscode-syncing"></a>vscode-syncing</h3><ul><li><p>地址：<a href="https://github.com/nonoroazoro/vscode-syncing" target="_blank" rel="noopener">https://github.com/nonoroazoro/vscode-syncing</a></p></li><li><p>作用：多台设备之间，同步 VS Code 配置。</p></li></ul><h3 id="indent-rainbow：突出显示缩进"><a href="#indent-rainbow：突出显示缩进" class="headerlink" title="indent-rainbow：突出显示缩进"></a>indent-rainbow：突出显示缩进</h3><p><code>indent-rainbow</code>插件：突出显示缩进。</p><p>安装完成后，效果如下图所示：</p><p><img data-src="/uploads/post/20190418_1958.png" alt=""></p><h3 id="RemoteHub"><a href="#RemoteHub" class="headerlink" title="RemoteHub"></a>RemoteHub</h3><p>不要惊讶，RemoteHub 和 GitLens 是同一个作者开发出来的。</p><p><code>RemoteHub</code>插件的作用是：可以在本地查看 GitHub 网站上的代码，而不需要将代码下载到本地。</p><p><img data-src="/uploads/post/20190418_1937.png" alt=""></p><p>这个插件目前使用的人还不多，赶紧安装起来尝尝鲜吧。</p><h3 id="Live-Share：实时编码分享"><a href="#Live-Share：实时编码分享" class="headerlink" title="Live Share：实时编码分享"></a>Live Share：实时编码分享</h3><p><code>Live Share</code>这个神奇的插件是由微软官方出品，它的作用是：<strong>实时编码分享</strong>。也就是说，它可以实现你和你的同伴一起写代码。这绝对就是<strong>结对编程</strong>的神器啊。</p><p>安装方式：</p><p>打开插件管理，搜索“live share”，安装。安装后重启 VS Code，在左侧会多出一个按钮：</p><p><img data-src="/uploads/post/QQ20200424-191121.png" alt="搜索“live share”"></p><p>上图中，点击红框部分，登录后就可以分享你的工作空间了。</p><p><img data-src="/uploads/post/20190418_2005.png" alt=""></p><h3 id="vscode-pigments"><a href="#vscode-pigments" class="headerlink" title="vscode-pigments"></a>vscode-pigments</h3><p>css颜色高亮显示。</p><h2 id="八、主题插件"><a href="#八、主题插件" class="headerlink" title="八、主题插件"></a>八、主题插件</h2><ul><li><p><a href="https://marketplace.visualstudio.com/items?itemName=zhuangtongfa.Material-theme" target="_blank" rel="noopener">One Dark Pro</a></p></li><li><p><a href="https://marketplace.visualstudio.com/items?itemName=akarlsten.vscode-snazzy-akarlsten" target="_blank" rel="noopener">Snazzy Plus</a></p></li><li><p><a href="https://marketplace.visualstudio.com/items?itemName=alexanderte.dainty-vscode" target="_blank" rel="noopener">Dainty</a></p></li><li><p><code>SynthWave &#39;84</code></p></li></ul><h2 id="最后一段"><a href="#最后一段" class="headerlink" title="最后一段"></a>最后一段</h2><p>如果你有什么推荐的 VS Code 插件，欢迎留言。</p><!-- 同时，你也可以关注我在 GitHub 上的 [前端入门项目](https://github.com/qianguyihao/Web)，超级详细和真诚。 --><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><p><a href="https://juejin.im/post/5d74eb5c51882525017787d9" target="_blank" rel="noopener">VS Code 折腾记 - (16) 推荐一波实用的插件集</a></p></li><li><p><a href="https://juejin.im/post/5db66672f265da4d0e009aad" target="_blank" rel="noopener">VSCode前端必备插件，有可能你装了却不知道如何使用？</a></p></li><li><p><a href="https://juejin.im/post/5a08d1d6f265da430f31950e" target="_blank" rel="noopener">能让你开发效率翻倍的 VSCode 插件配置（上）</a></p></li><li><p><a href="https://segmentfault.com/a/1190000012811886" target="_blank" rel="noopener">https://segmentfault.com/a/1190000012811886</a></p></li><li><p><a href="https://idoubi.cc/2019/07/08/vscode-sublime-theme/" target="_blank" rel="noopener">「Vscode」打造类sublime的高颜值编辑器</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;VS Code  本来是前端人员专用，但由于它实在是太好用了，于是，各种开发方向的码农也正在用 VS Code 作为他们的主力编程工具。甚至是一些写作的同学，也把 VS Code 作为 markdown 写作工具。&lt;/p&gt;
&lt;p&gt;写下这篇文章，是顺势而为。&lt;/p&gt;
    
    </summary>
    
    
      <category term="工具" scheme="https://csjiabin.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="VS Code" scheme="https://csjiabin.github.io/tags/VS-Code/"/>
    
      <category term="IDE" scheme="https://csjiabin.github.io/tags/IDE/"/>
    
      <category term="编辑器" scheme="https://csjiabin.github.io/tags/%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>linux下tar.gz、tar、bz2、zip等解压缩、压缩命令小结</title>
    <link href="https://csjiabin.github.io/2019/05/09/linux%E4%B8%8Btar-gz%E3%80%81tar%E3%80%81bz2%E3%80%81zip%E7%AD%89%E8%A7%A3%E5%8E%8B%E7%BC%A9%E3%80%81%E5%8E%8B%E7%BC%A9%E5%91%BD%E4%BB%A4%E5%B0%8F%E7%BB%93/"/>
    <id>https://csjiabin.github.io/2019/05/09/linux%E4%B8%8Btar-gz%E3%80%81tar%E3%80%81bz2%E3%80%81zip%E7%AD%89%E8%A7%A3%E5%8E%8B%E7%BC%A9%E3%80%81%E5%8E%8B%E7%BC%A9%E5%91%BD%E4%BB%A4%E5%B0%8F%E7%BB%93/</id>
    <published>2019-05-09T02:35:02.000Z</published>
    <updated>2020-11-02T09:26:56.676Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍了 linux 下的压缩程式 tar、gzip、gunzip、bzip2、bunzip2、compress 、uncompress、 zip、 unzip、rar、unrar 等程式，以及如何使用它们对.tar、.gz 、.tar.gz、.tgz、.bz2、.tar.bz2、.Z、. tar.Z、.zip、.rar 这 10 种压缩文件进行操作</p><p>Linux 下最常用的打包程序就是 tar 了，使用 tar 程序打出来的包我们常称为 tar 包，tar 包文件的命令通常都是以.tar 结尾的。生成 tar 包后，就可以用其它的程序来进行压缩了，所以首先就来讲讲 tar 命令的基本用法：</p><p>tar 命令的选项有很多(用 man tar 可以查看到)，但常用的就那么几个选项，下面来举例说明一下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -cf all.tar *.jpg</span><br></pre></td></tr></table></figure><p>这条命令是将所有.jpg 的文件打成一个名为 all.tar 的包。-c 是表示产生新的包 ，-f 指定包的文件名。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -uf all.tar logo.gif</span><br></pre></td></tr></table></figure><p>这条命令是将所有.gif 的文件增加到 all.tar 的包里面去。-r 是表示增加文件的意思。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -uf all.tar logo.gif</span><br></pre></td></tr></table></figure><p>这条命令是更新原来 tar 包 all.tar 中 logo.gif 文件，-u 是表示更新文件的意思。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -tf all.tar</span><br></pre></td></tr></table></figure><p>这条命令是列出 all.tar 包中所有文件，-t 是列出文件的意思</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xf all.tar</span><br></pre></td></tr></table></figure><p>这条命令是解出 all.tar 包中所有文件，-x 是解开的意思</p><p>以上就是 tar 的最基本的用法。为了方便用户在打包解包的同时可以压缩或解压文件，tar 提供了一种特殊的功能。这就是 tar 可以在打包或解包的同时调用其它的压缩程序，比如调用 gzip、bzip2 等。</p><h2 id="tar-调用"><a href="#tar-调用" class="headerlink" title="tar 调用"></a>tar 调用</h2><p>gzip 是 GNU 组织开发的一个压缩程序，.gz 结尾的文件就是 gzip 压缩的结果。与 gzip 相对的解压程序是 gunzip。tar 中使用-z 这个参数来调用 gzip。下面来举例说明一下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -czf all.tar.gz *.jpg</span><br></pre></td></tr></table></figure><p>这条命令是将所有.jpg 的文件打成一个 tar 包，并且将其用 gzip 压缩，生成一个 gzip 压缩过的包，包名为 all.tar.gz</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xzf all.tar.gz</span><br></pre></td></tr></table></figure><p>这条命令是将上面产生的包解开。</p><h3 id="tar-调用-bzip2"><a href="#tar-调用-bzip2" class="headerlink" title="tar 调用 bzip2"></a>tar 调用 bzip2</h3><p>bzip2 是一个压缩能力更强的压缩程序，.bz2 结尾的文件就是 bzip2 压缩的结果。</p><p>与 bzip2 相对的解压程序是 bunzip2。tar 中使用-j 这个参数来调用 gzip。下面来举例说明一下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -cjf all.tar.bz2 *.jpg</span><br></pre></td></tr></table></figure><p>这条命令是将所有.jpg 的文件打成一个 tar 包，并且将其用 bzip2 压缩，生成一个 bzip2 压缩过的包，包名为 all.tar.bz2</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xjf all.tar.bz2</span><br></pre></td></tr></table></figure><p>这条命令是将上面产生的包解开。</p><h3 id="tar-调用-compress"><a href="#tar-调用-compress" class="headerlink" title="tar 调用 compress"></a>tar 调用 compress</h3><p>compress 也是一个压缩程序，但是好象使用 compress 的人不如 gzip 和 bzip2 的人多。.Z 结尾的文件就是 bzip2 压缩的结果。与 compress 相对的解压程序是 uncompress。tar 中使用-Z 这个参数来调用 compress。下面来举例说明一下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -cZf all.tar.Z *.jpg</span><br></pre></td></tr></table></figure><p>这条命令是将所有.jpg 的文件打成一个 tar 包，并且将其用 compress 压缩，生成一个 uncompress 压缩过的包，包名为 all.tar.Z</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xZf all.tar.Z</span><br></pre></td></tr></table></figure><p>这条命令是将上面产生的包解开</p><p><strong>有了上面的知识，你应该可以解开多种压缩文件了，下面对于 tar 系列的压缩文件作一个小结：</strong></p><ol><li>对于.tar 结尾的文件</li></ol><p>tar -xf all.tar</p><ol start="2"><li>对于.gz 结尾的文件</li></ol><p>gzip -d all.gz</p><p>gunzip all.gz</p><ol start="3"><li>对于.tgz 或.tar.gz 结尾的文件</li></ol><p>tar -xzf all.tar.gz</p><p>tar -xzf all.tgz</p><ol start="4"><li>对于.bz2 结尾的文件</li></ol><p>bzip2 -d all.bz2</p><p>bunzip2 all.bz2</p><ol start="5"><li>对于 tar.bz2 结尾的文件</li></ol><p>tar -xjf all.tar.bz2</p><ol start="6"><li>对于.Z 结尾的文件</li></ol><p>uncompress all.Z</p><ol start="7"><li>对于.tar.Z 结尾的文件</li></ol><p>tar -xZf all.tar.z</p><p>另外对于 Window 下的常见压缩文件.zip 和.rar，Linux 也有相应的方法来解压它们：</p><h2 id="对于-zip"><a href="#对于-zip" class="headerlink" title="对于.zip"></a>对于.zip</h2><p>linux 下提供了 zip 和 unzip 程序，zip 是压缩程序，unzip 是解压程序。它们的参数选项很多，这里只做简单介绍，依旧举例说明一下其用法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zip all.zip *.jpg</span><br></pre></td></tr></table></figure><p>这条命令是将所有.jpg 的文件压缩成一个 zip 包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip all.zip</span><br></pre></td></tr></table></figure><p>这条命令是将 all.zip 中的所有文件解压出来</p><h2 id="对于-rar"><a href="#对于-rar" class="headerlink" title="对于.rar"></a>对于.rar</h2><p>要在 linux 下处理.rar 文件，需要安装 RAR for Linux，可以从网上下载，但要记住，RAR for Linux 不是免费的；可从<a href="http://www.rarsoft.com/download.htm下载RARfor" target="_blank" rel="noopener">http://www.rarsoft.com/download.htm下载RARfor</a> Linux 3.2.0，然后安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tar -xzpvf rarlinux-3.2.0.tar.gz</span><br><span class="line"><span class="built_in">cd</span> rar</span><br><span class="line">make</span><br></pre></td></tr></table></figure><p>这样就安装好了，安装后就有了 rar 和 unrar 这两个程序，rar 是压缩程序，unrar 是解压程序。它们的参数选项很多，这里只做简单介绍，依旧举例说明一下其用法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rar a all *.jpg</span><br></pre></td></tr></table></figure><p>这条命令是将所有.jpg 的文件压缩成一个 rar 包，名为 all.rar，该程序会将.rar 扩展名将自动附加到包名后。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unrar e all.rar</span><br></pre></td></tr></table></figure><p>这条命令是将 all.rar 中的所有文件解压出来</p><p>到此为至，我们已经介绍过 linux 下的 tar、gzip、gunzip、bzip2、bunzip2、compress 、 uncompress、 zip、unzip、rar、unrar 等程式，你应该已经能够使用它们对.tar 、.gz、.tar.gz、.tgz、.bz2、.tar.bz2、. Z、.tar.Z、.zip、.rar 这 10 种压缩文<br>件进行解压了，以后应该不需要为下载了一个软件而不知道如何在 Linux 下解开而烦恼了。而且以上方法对于 Unix 也基本有效。</p><p>本文介绍了 linux 下的压缩程式 tar、gzip、gunzip、bzip2、bunzip2、compress 、uncompress、 zip、 unzip、rar、unrar 等程式，以及如何使用它们对.tar、.gz 、.tar.gz、.tgz、.bz2、.tar.bz2、.Z、. tar.Z、.zip、.rar 这 10 种压缩文件进行<br>操作。</p><h2 id="以下补充"><a href="#以下补充" class="headerlink" title="以下补充"></a>以下补充</h2><h3 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h3><p>-c: 建立压缩档案<br>-x：解压<br>-t：查看内容<br>-r：向压缩归档文件末尾追加文件<br>-u：更新原压缩包中的文件</p><p>这五个是独立的命令，压缩解压都要用到其中一个，可以和别的命令连用但只能用其中一个。下面的参数是根据需要在压缩或解压档案时可选的。</p><p>-z：有 gzip 属性的<br>-j：有 bz2 属性的<br>-Z：有 compress 属性的<br>-v：显示所有过程<br>-O：将文件解开到标准输出</p><p>下面的参数-f 是必须的</p><p>-f: 使用档案名字，切记，这个参数是最后一个参数，后面只能接档案名。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar -cf all.tar *.jpg <span class="comment"># 这条命令是将所有.jpg的文件打成一个名为all.tar的包。-c是表示产生新的包，-f指定包的文件名。</span></span><br><span class="line">tar -rf all.tar *.gif</span><br></pre></td></tr></table></figure><p>这条命令是将所有.gif 的文件增加到 all.tar 的包里面去。-r 是表示增加文件的意思。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -uf all.tar logo.gif</span><br></pre></td></tr></table></figure><p>这条命令是更新原来 tar 包 all.tar 中 logo.gif 文件，-u 是表示更新文件的意思。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -tf all.tar</span><br></pre></td></tr></table></figure><p>这条命令是列出 all.tar 包中所有文件，-t 是列出文件的意思</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xf all.tar</span><br></pre></td></tr></table></figure><p>这条命令是解出 all.tar 包中所有文件，-x 是解开的意思</p><h3 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tar –cvf jpg.tar *.jpg <span class="comment"># 将目录里所有jpg文件打包成tar.jpg</span></span><br><span class="line">tar –czf jpg.tar.gz *.jpg <span class="comment"># 将目录里所有jpg文件打包成jpg.tar后，并且将其用gzip压缩，生成一个gzip压缩过的包，命名为jpg.tar.gz</span></span><br><span class="line">tar –cjf jpg.tar.bz2 *.jpg <span class="comment"># 将目录里所有jpg文件打包成jpg.tar后，并且将其用bzip2压缩，生成一个bzip2压缩过的包，命名为jpg.tar.bz2</span></span><br><span class="line">tar –cZf jpg.tar.Z *.jpg <span class="comment"># 将目录里所有jpg文件打包成jpg.tar后，并且将其用compress压缩，生成一个umcompress压缩过的包，命名为jpg.tar.Z</span></span><br><span class="line">rar a jpg.rar *.jpg <span class="comment"># rar格式的压缩，需要先下载rar for linux</span></span><br><span class="line">zip jpg.zip *.jpg <span class="comment"># zip格式的压缩，需要先下载zip for linux</span></span><br></pre></td></tr></table></figure><h3 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tar –xvf file.tar <span class="comment"># 解压 tar包</span></span><br><span class="line">tar -xzvf file.tar.gz <span class="comment"># 解压tar.gz</span></span><br><span class="line">tar -xjvf file.tar.bz2 <span class="comment"># 解压 tar.bz2</span></span><br><span class="line">tar –xZvf file.tar.Z <span class="comment"># 解压tar.Z</span></span><br><span class="line">unrar e file.rar <span class="comment"># 解压rar</span></span><br><span class="line">unzip file.zip <span class="comment"># 解压zip</span></span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>*.tar 用 tar –xvf 解压</li><li>*.gz 用 gzip -d 或者 gunzip 解压</li><li>*.tar.gz 和_.tgz 用 tar –xzf 解压</li><li>*.bz2 用 bzip2 -d 或者用 bunzip2 解压</li><li>*.tar.bz2 用 tar –xjf 解压</li><li>*.Z 用 uncompress 解压</li><li>*.tar.Z 用 tar –xZf 解压</li><li>*.rar 用 unrar e 解压</li><li>*.zip 用 unzip 解压</li></ol><h2 id="Linux-下解压-RAR-软件下载和解压-zip-和-rar-文件"><a href="#Linux-下解压-RAR-软件下载和解压-zip-和-rar-文件" class="headerlink" title="Linux 下解压 RAR 软件下载和解压.zip 和.rar 文件"></a>Linux 下解压 RAR 软件下载和解压.zip 和.rar 文件</h2><p>下载地址：<a href="http://www.rarsoft.com/download.htm" target="_blank" rel="noopener">http://www.rarsoft.com/download.htm</a>（目前最新为 RAR *.** for Linux）</p><p>以最新的为准。</p><p>对于 Window 下的常见压缩文件.zip 和.rar，Linux 也有相应的方法来解压它们：</p><h3 id="对于-zip-1"><a href="#对于-zip-1" class="headerlink" title="对于.zip"></a>对于.zip</h3><p>linux 下提供了 zip 和 unzip 程序，zip 是压缩程序，unzip 是解压程序。它们的参数选项很多，这里只做简单介绍，举例说明一下其用法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zip all.zip *.jpg <span class="comment"># (这条命令是将所有.jpg的文件压缩成一个zip包)</span></span><br><span class="line">unzip all.zip <span class="comment"># (这条命令是将all.zip中的所有文件解压出来)</span></span><br></pre></td></tr></table></figure><h3 id="对于-rar-1"><a href="#对于-rar-1" class="headerlink" title="对于.rar"></a>对于.rar</h3><p>要在 linux 下处理.rar 文件，需要安装 RAR for Linux，可以从网上下载，但要记住，RAR for Linux 不是免费的；可从<a href="http://www.rarsoft.com/download.htm" target="_blank" rel="noopener">http://www.rarsoft.com/download.htm</a>下载 RAR *.** for Linux ，然后安装其安装操作如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tar -xzpvf rarlinux-*.**.tar.gz</span><br><span class="line"><span class="built_in">cd</span> rar</span><br><span class="line">make</span><br></pre></td></tr></table></figure><p>这样就安装好了，安装后就有了 rar 和 unrar 这两个程序，rar 是压缩程序，unrar 是解压程序。它们的参数选项很多，举例说明一下其用法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rar a all *.jpg</span><br></pre></td></tr></table></figure><p>这条命令是将所有.jpg 的文件压缩成一个 rar 包，名为 all.rar，该程序会将.rar 扩展名将自动附加到包名后。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unrar e all.rar</span><br></pre></td></tr></table></figure><p>这条命令是将 all.rar 中的所有文件解压出来。</p><p>xxxx.tar.gz 文件使用 tar 带 zxvf 参数，可以一次解压开。XXXX 为文件名。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar zxvf xxxx.tar.gz</span><br></pre></td></tr></table></figure><h2 id="gzip-d"><a href="#gzip-d" class="headerlink" title="gzip -d"></a>gzip -d</h2><p><strong>语 法：</strong> <code>gzip [-acdfhlLnNqrtvV][-S &lt;压缩字尾字符串&gt;][-&lt;压缩效率&gt;][--best/fast][文件...] 或 gzip [-acdfhlLnNqrtvV][-S &lt;压缩字尾字符串&gt;][-&lt;压缩效率&gt;][--best/fast][目录]</code></p><p><strong>补充说明：</strong> gzip 是个使用广泛的压缩程序，文件经它压缩过后，其名称后面会多出”.gz”的扩展名。</p><p><strong>参 数：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">-a或--ascii 使用ASCII文字模式。</span><br><span class="line">-c或--stdout或--to-stdout 把压缩后的文件输出到标准输出设备，不去更动原始文件。</span><br><span class="line">-d或--decompress或----uncompress 解开压缩文件。</span><br><span class="line">-f或--force 强行压缩文件。不理会文件名称或硬连接是否存在以及该文件是否为符号连接。</span><br><span class="line">-h或--help 在线帮助。</span><br><span class="line">-l或--list 列出压缩文件的相关信息。</span><br><span class="line">-L或--license 显示版本与版权信息。</span><br><span class="line">-n或--no-name 压缩文件时，不保存原来的文件名称及时间戳记。</span><br><span class="line">-N或--name 压缩文件时，保存原来的文件名称及时间戳记。</span><br><span class="line">-q或--quiet 不显示警告信息。</span><br><span class="line">-r或--recursive 递归处理，将指定目录下的所有文件及子目录一并处理。</span><br><span class="line">-S&lt;压缩字尾字符串&gt;或----suffix&lt;压缩字尾字符串&gt; 更改压缩字尾字符串。</span><br><span class="line">-t或--test 测试压缩文件是否正确无误。</span><br><span class="line">-v或--verbose 显示指令执行过程。</span><br><span class="line">-V或--version 显示版本信息。</span><br><span class="line">-&lt;压缩效率&gt; 压缩效率是一个介于1－9的数值，预设值为&quot;6&quot;，指定愈大的数值，压缩效率就会愈高。</span><br><span class="line">--best 此参数的效果和指定&quot;-9&quot;参数相同。</span><br><span class="line">--fast 此参数的效果和指定&quot;-1&quot;参数相同。</span><br></pre></td></tr></table></figure><ol><li>*.tar 用 tar –xvf 解压</li><li>*.gz 用 gzip -d 或者 gunzip 解压</li><li>*.tar.gz 和_.tgz 用 tar –xzf 解压</li><li>*.bz2 用 bzip2 -d 或者用 bunzip2 解压</li><li>*.tar.bz2 用 tar –xjf 解压</li><li>*.Z 用 uncompress 解压</li><li>*.tar.Z 用 tar –xZf 解压</li><li>*.rar 用 unrar e 解压</li><li>*.zip 用 unzip 解压</li></ol><p><strong>Linux 下*.tar.gz 文件解压缩命令</strong></p><h3 id="压缩命令"><a href="#压缩命令" class="headerlink" title="压缩命令"></a>压缩命令</h3><p><strong>命令格式：</strong> <code>tar -zcvf 压缩文件名.tar.gz 被压缩文件名</code></p><p>可先切换到当前目录下。压缩文件名和被压缩文件名都可加入路径。</p><h3 id="解压缩命令"><a href="#解压缩命令" class="headerlink" title="解压缩命令"></a>解压缩命令</h3><p><strong>命令格式：</strong> <code>tar -zxvf 压缩文件名.tar.gz</code></p><p>解压缩后的文件只能放在当前的目录。</p><p>你可以使用 zip 命令同时处理多个文件和目录，方法是将它们逐一列出，并用空格间隔：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zip -r filename.zip file1 file2 file3 /usr/work/school</span><br></pre></td></tr></table></figure><p>压缩单个目录命令 <code>zip -r filename.zip filename</code></p><p>上面的命令把 file1、file2、 file3、以及 /usr/work/school 目录的内容（假设这个目录存在）压缩起来，然后放入 filename.zip 文件中。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍了 linux 下的压缩程式 tar、gzip、gunzip、bzip2、bunzip2、compress 、uncompress、 zip、 unzip、rar、unrar 等程式，以及如何使用它们对.tar、.gz 、.tar.gz、.tgz、.bz2、.tar.bz2、.Z、. tar.Z、.zip、.rar 这 10 种压缩文件进行操作&lt;/p&gt;
&lt;p&gt;Linux 下最常用的打包程序就是 tar 了，使用 tar 程序打出来的包我们常称为 tar 包，tar 包文件的命令通常都是以.tar 结尾的。生成 tar 包后，就可以用其它的程序来进行压缩了，所以首先就来讲讲 tar 命令的基本用法：&lt;/p&gt;
&lt;p&gt;tar 命令的选项有很多(用 man tar 可以查看到)，但常用的就那么几个选项，下面来举例说明一下：&lt;/p&gt;
    
    </summary>
    
    
      <category term="linux" scheme="https://csjiabin.github.io/categories/linux/"/>
    
    
      <category term="linux" scheme="https://csjiabin.github.io/tags/linux/"/>
    
      <category term="shell" scheme="https://csjiabin.github.io/tags/shell/"/>
    
      <category term="tar" scheme="https://csjiabin.github.io/tags/tar/"/>
    
      <category term="zip" scheme="https://csjiabin.github.io/tags/zip/"/>
    
  </entry>
  
  <entry>
    <title>Nginx负载均衡配置与负载策略</title>
    <link href="https://csjiabin.github.io/2019/02/15/Nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E9%85%8D%E7%BD%AE%E4%B8%8E%E8%B4%9F%E8%BD%BD%E7%AD%96%E7%95%A5/"/>
    <id>https://csjiabin.github.io/2019/02/15/Nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E9%85%8D%E7%BD%AE%E4%B8%8E%E8%B4%9F%E8%BD%BD%E7%AD%96%E7%95%A5/</id>
    <published>2019-02-15T07:43:27.000Z</published>
    <updated>2020-11-02T09:26:56.675Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>负载均衡的目的是为了解决单个节点压力过大，造成 Web 服务响应过慢，严重的情况下导致服务瘫痪，无法正常提供服务。</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>春节期间在 12306 网站上买过火车票的朋友应该深有体会，有时查询一张火车票都会很慢，甚至整个网页都卡住不动了。通常一个访问量非常大的 Web 网站（比如：淘宝、京东、12306 等），由于一个 Web 服务同时能处理的用户并发请求的数量有限，同时还有机器故障的情况，所以一个 Web 站点通常会在 N 台机器上各部署一套同样的程序。当某一个服务挂掉的时候，还有第二个、第三个、第 N 个服务。。。继续为用户提供服务，给用户的感觉，你的服务还在正常的运行！在这些提供同样服务的机器当中，在硬件配置方面也各不一样，这样就会存在部份机器性能非常好，能快速计算并响应用户的请求，另外一部份机器可能配置差点，响应用户的请求的时间会长一些。</p><p>这就需要我们思考一个问题？如果有一个服务正在同时处理 1000 个用户的请求，这个服务的上限可能最多能同时处理 1000 个用户的请求，这时它已经很忙了，如果此时又有一个新请求过来，我们仍然把这个请求分配给这台机器，这时候这个请求就只能在干等着，等这个服务处理完那些请求后，再继续处理它。这样在浏览器中的反应就像 12306 我们在春节买票一样，卡在那不动了，让用户眼巴巴的干着急。而能提供同样服务的其它机器，这时确很空闲。这样不仅是对服务器资源的浪费，也充分发挥不出弄多台服务器装同一个服务的最高价值。<br>我们通常称对某一台机器的访问量称为负载量，如何将一个用户的请求，合理的分配到一台能快速响应用户请求的服务器上，我们就需要用到一些负载策略。也就体现出了文章主题的用意了：<br>负载均衡，将用户的所有 HTTP 请求均衡的分配到每一台机器上，充分发挥所有机器的性能，提高服务的质量和用户体验。<br>负载均衡可以通过负载均衡网络硬件设备和 Web 服务器软件来实现，前者设备成本较高，小公司通常负担不起，所以后者一般是我们的首选。<br>实现负载均衡常用的 Web 服务器软件有 Nginx、HAProxy、LVS、Apache，本文主要介绍 Nginx 的负载均衡策略。</p><h2 id="一、内置负载策略"><a href="#一、内置负载策略" class="headerlink" title="一、内置负载策略"></a>一、内置负载策略</h2><p>Nginx 负载均衡是通过 upstream 模块来实现的，内置实现了三种负载策略，配置还是比较简单的。</p><ul><li>轮循（默认）<br>Nginx 根据请求次数，将每个请求均匀分配到每台服务器</li><li>最少连接<br>将请求分配给连接数最少的服务器。Nginx 会统计哪些服务器的连接数最少。</li><li>IP Hash<br>绑定处理请求的服务器。第一次请求时，根据该客户端的 IP 算出一个 HASH 值，将请求分配到集群中的某一台服务器上。后面该客户端的所有请求，都将通过 HASH 算法，找到之前处理这台客户端请求的服务器，然后将请求交给它来处理。</li></ul><p><strong>轮循</strong></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">http</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># ... 省略其它配置</span></span><br><span class="line"></span><br><span class="line">    <span class="attribute">upstream</span> tomcats &#123;</span><br><span class="line">        <span class="attribute">server</span> <span class="number">192.168.0.100:8080</span>;</span><br><span class="line">        <span class="attribute">server</span> <span class="number">192.168.0.101:8080</span>;</span><br><span class="line">        <span class="attribute">server</span> example.com:<span class="number">8080</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">            <span class="attribute">proxy_pass</span> http://tomcats;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># ... 省略其它配置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>proxy_pass <a href="http://tomcats：">http://tomcats：</a></strong> 表示将所有请求转发到 tomcats 服务器组中配置的某一台服务器上。</li><li><strong>upstream 模块：</strong> 配置反向代理服务器组，Nginx 会根据配置，将请求分发给组里的某一台服务器。tomcats 是服务器组的名称。</li><li><strong>upstream 模块下的 server 指令：</strong> 配置处理请求的服务器 IP 或域名，端口可选，不配置默认使用 80 端口。通过上面的配置，Nginx 默认将请求依次分配给 100，101，102 来处理，可以通过修改下面这些参数来改变默认的分配策略：</li><li><strong>weight</strong><br>默认为 1，将请求平均分配给每台 server</li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> tomcats &#123;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.0.100:8080</span> weight=<span class="number">2</span>;  <span class="comment"># 2/6次</span></span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.0.101:8080</span> weight=<span class="number">3</span>;  <span class="comment"># 3/6次</span></span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.0.102:8080</span> weight=<span class="number">1</span>;  <span class="comment"># 1/6次</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上例配置，表示 6 次请求中，100 分配 2 次，101 分配 3 次，102 分配 1 次</p></blockquote><ul><li><strong>max_fails</strong><br>默认为 1。某台 Server 允许请求失败的次数，超过最大次数后，在 fail_timeout 时间内，新的请求将不会分配给这台机器。如果设置为 0，Nginx 会将这台 Server 置为永久无效状态，然后将请求发给定义了 proxy_next_upstream, fastcgi_next_upstream, uwsgi_next_upstream, scgi_next_upstream, and memcached_next_upstream 指令来处理这次错误的请求。</li><li><strong>fail_timeout</strong><br>默认为 10 秒。某台 Server 达到 max_fails 次失败请求后，在 fail_timeout 期间内，nginx 会认为这台 Server 暂时不可用，不会将请求分配给它</li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> tomcats &#123;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.0.100:8080</span> weight=<span class="number">2</span> max_fails=<span class="number">3</span> fail_timeout=<span class="number">15</span>;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.0.101:8080</span> weight=<span class="number">3</span>;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.0.102:8080</span> weight=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>192.168.0.100 这台机器，如果有 3 次请求失败，nginx 在 15 秒内，不会将新的请求分配给它。</p></blockquote><ul><li><strong>backup</strong><br>备份机，所有服务器挂了之后才会生效</li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> tomcats &#123;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.0.100:8080</span> weight=<span class="number">2</span> max_fails=<span class="number">3</span> fail_timeout=<span class="number">15</span>;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.0.101:8080</span> weight=<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.0.102:8080</span> backup;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在 100 和 101 都挂了之前，102 为不可用状态，不会将请求分配给它。只有当 100 和 101 都挂了，102 才会被启用。</p></blockquote><ul><li><strong>down</strong><br>标识某一台 server 不可用。可能能通过某些参数动态的激活它吧，要不真没啥用。</li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> tomcats &#123;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.0.100:8080</span> weight=<span class="number">2</span> max_fails=<span class="number">3</span> fail_timeout=<span class="number">15</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.0.101:8080</span> down;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.0.102:8080</span> backup;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>表示 101 这台 Server 为无效状态，不会将请求分配给它。</p></blockquote><ul><li><strong>max_conns</strong><br>限制分配给某台 Server 处理的最大连接数量，超过这个数量，将不会分配新的连接给它。默认为 0，表示不限制。注意：1.5.9 之后的版本才有这个配置</li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> tomcats &#123;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.0.100:8080</span> max_conns=<span class="number">1000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>表示最多给 100 这台 Server 分配 1000 个请求，如果这台 Server 正在处理 1000 个请求，nginx 将不会分配新的请求给到它。假如有一个请求处理完了，还剩下 999 个请求在处理，这时 nginx 也会将新的请求分配给它。</p></blockquote><ul><li><strong>resolve</strong><br>将 server 指令配置的域名，指定域名解析服务器。需要在 http 模块下配置 resolver 指令，指定域名解析服务</li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">resolver</span> <span class="number">10.0.0.1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">upstream</span> u &#123;</span><br><span class="line">        <span class="attribute">zone</span> ...;</span><br><span class="line">        ...</span><br><span class="line">        <span class="attribute">server</span> example.com resolve;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>表示 example.com 域名，由 10.0.0.1 服务器来负责解析。</p></blockquote><h2 id="二、第三方负载策略"><a href="#二、第三方负载策略" class="headerlink" title="二、第三方负载策略"></a>二、第三方负载策略</h2><h3 id="fair"><a href="#fair" class="headerlink" title="fair"></a>fair</h3><p>根据服务器的响应时间来分配请求，响应时间短的优先分配，即负载压力小的优先会分配。<br>由于 fair 模块是第三方提供的，所以在编译 nginx 源码的时候，需要将 fair 添加到 nginx 模块中。</p><blockquote><p>假设我的 nginx 是通过源码安装的，安装在/opt/nginx 目录下，而且安装时没有添加 fair 模块</p></blockquote><ol><li>下载 fair 模块源码</li></ol><p>下载地址：<a href="https://github.com/csjiabin/nginx-upstream-fair" target="_blank" rel="noopener">https://github.com/csjiabin/nginx-upstream-fair</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /opt</span><br><span class="line">wget https://github.com/csjiabin/nginx-upstream-fair/archive/master.zip</span><br><span class="line">unzip master.zip</span><br></pre></td></tr></table></figure><blockquote><p>解压后的目录名为：nginx-upstream-fair-master</p></blockquote><ol start="2"><li>重新编译 nginx，将 fair 模块添加到编译参数</li></ol><p>我的 nginx 源码目录在/opt/nginx-1.10.0</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /opt/nginx-nginx-1.10.0</span><br><span class="line">./configure --prefix=/opt/nginx --add-module=/opt/nginx-upstream-fair-master</span><br><span class="line">make</span><br></pre></td></tr></table></figure><blockquote><p>注意：不要执行 <code>make install</code>，这样会覆盖之前 nginx 的配置</p></blockquote><ol start="3"><li>将新编译的 nginx 可执行程序拷贝到/opt/nginx/sbin/目录下，覆盖之前安装的 nginx</li></ol><p>编译后的 nginx 执行程序，放在 nginx 源码的 objs 目录下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ps -aux | grep nginx</span><br><span class="line"><span class="built_in">kill</span> -9 nginx进程ID  <span class="comment"># 停止nginx服务</span></span><br><span class="line">cp /opt/nginx-1.10.0/objs/nginx /opt/nginx/sbin/  <span class="comment"># 覆盖旧的nginx</span></span><br><span class="line">nginx <span class="comment"># 启动服务</span></span><br></pre></td></tr></table></figure><p>配置使用 fair 负载策略模块：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> tomcats &#123;</span><br><span class="line">    fair;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.0.100:8080</span>;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.0.101:8080</span>;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.0.102:8080</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>由于采用 fair 负载策略，配置 weigth 参数改变负载权重将无效。</p></blockquote><h3 id="url-hash"><a href="#url-hash" class="headerlink" title="url_hash"></a>url_hash</h3><p>按请求url的hash结果来分配请求，使每个url定向到同一个后端服务器，服务器做缓存时比较有效。</p><p>1.7.2版本以后，url_hash模块已经集成到了nginx源码当中，不需要单独安装。之前的版本仍需要单独安装，下载地址：<a href="https://github.com/evanmiller/nginx_upstream_hash" target="_blank" rel="noopener">https://github.com/evanmiller/nginx_upstream_hash</a><br>安装方法和fair模块一样，先下载url_hash源码，然后重新编译nginx源码，将url_hash模块添加到编译配置参数当中，最后将编译后生成的nginx二进制文件替换之前安装的nginx二进制文件即可。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> tomcats &#123;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.0.100:8080</span>;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.0.101:8080</span>;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.0.102:8080</span>;</span><br><span class="line">    <span class="attribute">hash</span> <span class="variable">$request_uri</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原理&lt;/h2&gt;&lt;p&gt;负载均衡的目的是为了解决单个节点压力过大，造成 Web 服务响应过慢，严重的情况下导致服务瘫痪，无法正常提供服务。&lt;/p&gt;
&lt;h2 id=&quot;应用场景&quot;&gt;&lt;a href=&quot;#应用场景&quot; class=&quot;headerlink&quot; title=&quot;应用场景&quot;&gt;&lt;/a&gt;应用场景&lt;/h2&gt;
    
    </summary>
    
    
      <category term="nginx" scheme="https://csjiabin.github.io/categories/nginx/"/>
    
    
      <category term="nginx" scheme="https://csjiabin.github.io/tags/nginx/"/>
    
      <category term="负载均衡" scheme="https://csjiabin.github.io/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    
  </entry>
  
  <entry>
    <title>js数组详细操作方法及解析合集</title>
    <link href="https://csjiabin.github.io/2019/01/15/js%E6%95%B0%E7%BB%84%E8%AF%A6%E7%BB%86%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95%E5%8F%8A%E8%A7%A3%E6%9E%90%E5%90%88%E9%9B%86/"/>
    <id>https://csjiabin.github.io/2019/01/15/js%E6%95%B0%E7%BB%84%E8%AF%A6%E7%BB%86%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95%E5%8F%8A%E8%A7%A3%E6%9E%90%E5%90%88%E9%9B%86/</id>
    <published>2019-01-15T08:43:09.000Z</published>
    <updated>2020-11-02T09:26:56.676Z</updated>
    
    <content type="html"><![CDATA[<h2 id="创建一个数组"><a href="#创建一个数组" class="headerlink" title="创建一个数组"></a>创建一个数组</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字面量方式:</span></span><br><span class="line"><span class="comment">// 这个方法也是我们最常用的，在初始化数组的时候 相当方便</span></span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">3</span>, <span class="number">11</span>, <span class="number">8</span>]; <span class="comment">// [3,11,8];</span></span><br><span class="line"><span class="comment">// 构造器:</span></span><br><span class="line"><span class="comment">// 实际上 new Array === Array,加不加new 一点影响都没有。</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="built_in">Array</span>(); <span class="comment">// []</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="built_in">Array</span>(<span class="number">3</span>); <span class="comment">// [undefined,undefined,undefined]</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="built_in">Array</span>(<span class="number">3</span>, <span class="number">11</span>, <span class="number">8</span>); <span class="comment">// [ 3,11,8 ]</span></span><br></pre></td></tr></table></figure><h3 id="ES6-Array-of-返回由所有参数值组成的数组"><a href="#ES6-Array-of-返回由所有参数值组成的数组" class="headerlink" title="ES6 Array.of() 返回由所有参数值组成的数组"></a>ES6 Array.of() 返回由所有参数值组成的数组</h3><p>定义: 返回由所有参数值组成的数组，如果没有参数，就返回一个空数组。<br>目的: Array.of() 出现的目的是为了解决上述构造器因参数个数不同，导致的行为有差异的问题。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="built_in">Array</span>.of(<span class="number">3</span>, <span class="number">11</span>, <span class="number">8</span>); <span class="comment">// [3,11,8]</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="built_in">Array</span>.of(<span class="number">3</span>); <span class="comment">// [3]</span></span><br></pre></td></tr></table></figure><h3 id="ES6-Arrar-from-将两类对象转为真正的数组"><a href="#ES6-Arrar-from-将两类对象转为真正的数组" class="headerlink" title="ES6 Arrar.from() 将两类对象转为真正的数组"></a>ES6 Arrar.from() 将两类对象转为真正的数组</h3><p>定义: 用于将两类对象转为真正的数组（不改变原对象，返回新的数组）。<br>参数:</p><ul><li>第一个参数(必需): 要转化为真正数组的对象。</li><li>第二个参数(可选): 类似数组的 map 方法，对每个元素进行处理，将处理后的值放入返回的数组。</li><li>第三个参数(可选): 用来绑定 this。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 对象拥有length属性</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="number">0</span>: <span class="string">"a"</span>, <span class="number">1</span>: <span class="string">"b"</span>, <span class="number">2</span>: <span class="string">"c"</span>, <span class="attr">length</span>: <span class="number">3</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> arr = <span class="built_in">Array</span>.from(obj); <span class="comment">// ['a','b','c'];</span></span><br><span class="line"><span class="comment">// 2. 部署了 Iterator接口的数据结构 比如:字符串、Set、NodeList对象</span></span><br><span class="line"><span class="keyword">let</span> arr = <span class="built_in">Array</span>.from(<span class="string">"hello"</span>); <span class="comment">// ['h','e','l','l']</span></span><br><span class="line"><span class="keyword">let</span> arr = <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">"a"</span>, <span class="string">"b"</span>])); <span class="comment">// ['a','b']</span></span><br></pre></td></tr></table></figure><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>数组原型提供了非常多的方法，这里分为三类来讲，一类会改变原数组的值，一类是不会改变原数组，以及数组的遍历方法。</p><h3 id="改变原数组的方法-9-个"><a href="#改变原数组的方法-9-个" class="headerlink" title="改变原数组的方法(9 个)"></a>改变原数组的方法(9 个)</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5:</span></span><br><span class="line"><span class="comment">// a.pop() / a.shift()/ a.push() / a.unshift() / a.reverse() / a.splice() / a.sort()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//   ES6:</span></span><br><span class="line"><span class="comment">//  a.copyWithin() / a.fill()</span></span><br></pre></td></tr></table></figure><blockquote><p>对于这些能够改变原数组的方法，要注意避免在循环遍历中改变原数组的选项，比如: 改变数组的长度，导致遍历的长度出现问题。</p></blockquote><h4 id="pop-删除一个数组中的最后的一个元素"><a href="#pop-删除一个数组中的最后的一个元素" class="headerlink" title="pop() 删除一个数组中的最后的一个元素"></a>pop() 删除一个数组中的最后的一个元素</h4><p>定义: pop() 方法删除一个数组中的最后的一个元素，并且返回这个元素。<br>参数: 无。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> item = a.pop(); <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// [1,2]</span></span><br></pre></td></tr></table></figure><h4 id="shift-删除数组的第一个元素"><a href="#shift-删除数组的第一个元素" class="headerlink" title="shift() 删除数组的第一个元素"></a>shift() 删除数组的第一个元素</h4><p>定义: shift()方法删除数组的第一个元素，并返回这个元素。<br>参数: 无。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> item = a.shift(); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// [2,3]</span></span><br></pre></td></tr></table></figure><h4 id="push-向数组的末尾添加元素"><a href="#push-向数组的末尾添加元素" class="headerlink" title="push() 向数组的末尾添加元素"></a>push() 向数组的末尾添加元素</h4><p>定义: push() 方法可向数组的末尾添加一个或多个元素，并返回新的长度。<br>参数: item1, item2, …, itemX ,要添加到数组末尾的元素</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> item = a.push(<span class="string">"末尾"</span>); <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// [1,2,3,'末尾']</span></span><br></pre></td></tr></table></figure><h4 id="unshift-向数组的开头添加元素"><a href="#unshift-向数组的开头添加元素" class="headerlink" title="unshift() 向数组的开头添加元素"></a>unshift() 向数组的开头添加元素</h4><p>定义: unshift() 方法可向数组的开头添加一个或更多元素，并返回新的长度。<br>参数: item1, item2, …, itemX ,要添加到数组开头的元素</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> item = a.unshift(<span class="string">"开头"</span>); <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// ['开头',1,2,3]</span></span><br></pre></td></tr></table></figure><h4 id="reverse-颠倒数组中元素的顺序"><a href="#reverse-颠倒数组中元素的顺序" class="headerlink" title="reverse() 颠倒数组中元素的顺序"></a>reverse() 颠倒数组中元素的顺序</h4><p>定义: reverse() 方法用于颠倒数组中元素的顺序。</p><p>参数: 无</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">a.reverse();</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// [3,2,1]</span></span><br></pre></td></tr></table></figure><h4 id="splice-添加-删除数组元素"><a href="#splice-添加-删除数组元素" class="headerlink" title="splice() 添加/删除数组元素"></a>splice() 添加/删除数组元素</h4><p>定义: splice() 方法向/从数组中添加/删除项目，然后返回被删除的项目<br>语法: <code>array.splice(index,howmany,item1,.....,itemX)</code><br>参数:</p><ul><li>index: 必需。整数，规定添加/删除项目的位置，使用负数可从数组结尾处规定位置。</li><li>howmany: 必需。要删除的项目数量。如果设置为 0，则不会删除项目。</li><li>item1, …, itemX: 可选。向数组添加的新项目。</li></ul><p>返回值: 如果有元素被删除,返回包含被删除项目的新数组。</p><p><strong>例 1:</strong> 删除元素</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>];</span><br><span class="line"><span class="keyword">let</span> item = a.splice(<span class="number">0</span>, <span class="number">3</span>); <span class="comment">// [1,2,3]</span></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// [4,5,6,7]</span></span><br><span class="line"><span class="comment">// 从数组下标0开始，删除3个元素</span></span><br><span class="line"><span class="keyword">let</span> item = a.splice(<span class="number">-1</span>, <span class="number">3</span>); <span class="comment">// [7]</span></span><br><span class="line"><span class="comment">// 从最后一个元素开始删除3个元素，因为最后一个元素，所以只删除了7</span></span><br></pre></td></tr></table></figure><p><strong>例 2:</strong> 删除并添加</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>];</span><br><span class="line"><span class="keyword">let</span> item = a.splice(<span class="number">0</span>, <span class="number">3</span>, <span class="string">"添加"</span>); <span class="comment">// [1,2,3]</span></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// ['添加',4,5,6,7]</span></span><br><span class="line"><span class="comment">// 从数组下标0开始，删除3个元素，并添加元素'添加'</span></span><br><span class="line"><span class="keyword">let</span> b = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>];</span><br><span class="line"><span class="keyword">let</span> item = b.splice(<span class="number">-2</span>, <span class="number">3</span>, <span class="string">"添加1"</span>, <span class="string">"添加2"</span>); <span class="comment">// [6,7]</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// [1,2,3,4,5,'添加1','添加2']</span></span><br><span class="line"><span class="comment">// 从数组最后第二个元素开始，删除3个元素，并添加两个元素'添加1'、'添加2'</span></span><br></pre></td></tr></table></figure><p><strong>例 3:</strong> 不删除只添加</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>];</span><br><span class="line"><span class="keyword">let</span> item = a.splice(<span class="number">0</span>, <span class="number">0</span>, <span class="string">"添加1"</span>, <span class="string">"添加2"</span>); <span class="comment">// [] 没有删除元素，返回空数组</span></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// ['添加1','添加2',1,2,3,4,5,6,7]</span></span><br><span class="line"><span class="keyword">let</span> b = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>];</span><br><span class="line"><span class="keyword">let</span> item = b.splice(<span class="number">-1</span>, <span class="number">0</span>, <span class="string">"添加1"</span>, <span class="string">"添加2"</span>); <span class="comment">// [] 没有删除元素，返回空数组</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// [1,2,3,4,5,6,'添加1','添加2',7] 在最后一个元素的前面添加两个元素</span></span><br></pre></td></tr></table></figure><p>从上述三个例子可以得出:</p><ol><li>数组如果元素不够，会删除到最后一个元素为止</li><li>操作的元素，包括开始的那个元素</li><li>可以添加很多个元素</li><li>添加是在开始的元素前面添加的</li></ol><h4 id="sort-数组排序"><a href="#sort-数组排序" class="headerlink" title="sort() 数组排序"></a>sort() 数组排序</h4><p>定义: sort()方法对数组元素进行排序，并返回这个数组。<br>参数（可选）: 规定排序顺序的比较函数。<br>默认情况下 sort()方法没有传比较函数的话，默认按字母升序，如果不是元素不是字符串的话，会调用<code>toString()</code>方法将元素转化为字符串的 Unicode(万国码)位点，然后再比较字符。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串排列 看起来很正常</span></span><br><span class="line"><span class="keyword">let</span> a = [<span class="string">"Banana"</span>, <span class="string">"Orange"</span>, <span class="string">"Apple"</span>, <span class="string">"Mango"</span>];</span><br><span class="line">a.sort(); <span class="comment">// ["Apple","Banana","Mango","Orange"]</span></span><br><span class="line"><span class="comment">// 数字排序的时候 因为转换成Unicode字符串之后，有些数字会比较大会排在后面 这显然不是我们想要的</span></span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">10</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">20</span>, <span class="number">25</span>, <span class="number">8</span>];</span><br><span class="line"><span class="built_in">console</span>.log(a.sort()); <span class="comment">// [1,10,20,25,3,8];</span></span><br></pre></td></tr></table></figure><h5 id="比较函数的两个参数"><a href="#比较函数的两个参数" class="headerlink" title="比较函数的两个参数"></a>比较函数的两个参数</h5><p>sort 的比较函数有两个默认参数，要在函数中接收这两个参数，这两个参数是数组中两个要比较的元素，通常我们用 a 和 b 接收两个将要比较的元素:</p><ul><li>若比较函数返回值&lt;0，那么 a 将排到 b 的前面;</li><li>若比较函数返回值=0，那么 a 和 b 相对位置不变；</li><li>若比较函数返回值&gt;0，那么 b 排在 a 将的前面；</li></ul><!-- 对于 sort()方法更深层级的内部实现以及处理机制可以看一下这篇文章深入了解 javascript 的 sort 方法 --><h5 id="sort-排序常见用法"><a href="#sort-排序常见用法" class="headerlink" title="sort 排序常见用法"></a>sort 排序常见用法</h5><ol><li>数组元素为数字的升序、降序:</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> array = [<span class="number">10</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">20</span>, <span class="number">4</span>, <span class="number">25</span>, <span class="number">8</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 升序 a-b &lt; 0   a将排到b的前面，按照a的大小来排序的</span></span><br><span class="line"><span class="comment">// 比如被减数a是10，减数是20  10-20 &lt; 0   被减数a(10)在减数b(20)前面</span></span><br><span class="line">array.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(array); <span class="comment">// [1,3,4,4,8,10,20,25];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 降序 被减数和减数调换了  20-10&gt;0 被减数b(20)在减数a(10)的前面</span></span><br><span class="line">array.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> b - a;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(array); <span class="comment">// [25,20,10,8,4,4,3,1];</span></span><br></pre></td></tr></table></figure><ol start="2"><li>数组多条件排序</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> array = [</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">10</span>, <span class="attr">age</span>: <span class="number">2</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">5</span>, <span class="attr">age</span>: <span class="number">4</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">6</span>, <span class="attr">age</span>: <span class="number">10</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">9</span>, <span class="attr">age</span>: <span class="number">6</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">age</span>: <span class="number">8</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">10</span>, <span class="attr">age</span>: <span class="number">9</span> &#125;</span><br><span class="line">];</span><br><span class="line">array.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (a.id === b.id) &#123;</span><br><span class="line">    <span class="comment">// 如果id的值相等，按照age的值降序</span></span><br><span class="line">    <span class="keyword">return</span> b.age - a.age;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果id的值不相等，按照id的值升序</span></span><br><span class="line">    <span class="keyword">return</span> a.id - b.id;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(array); <span class="comment">// [&#123;"id":2,"age":8&#125;,&#123;"id":5,"age":4&#125;,&#123;"id":6,"age":10&#125;,&#123;"id":9,"age":6&#125;,&#123;"id":10,"age":9&#125;,&#123;"id":10,"age":2&#125;]</span></span><br></pre></td></tr></table></figure><ol start="3"><li>自定义比较函数，天空才是你的极限<br>类似的: 运用好返回值，我们可以写出任意符合自己需求的比较函数</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> array = [</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"Koro1"</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"Koro1"</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"OB"</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"Koro1"</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"OB"</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"OB"</span> &#125;</span><br><span class="line">];</span><br><span class="line">array.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (a.name === <span class="string">"Koro1"</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果name是'Koro1' 返回-1 ，-1&lt;0 a排在b的前面</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果不是的话，a排在b的后面</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(array); <span class="comment">// [&#123;"name":"Koro1"&#125;,&#123;"name":"Koro1"&#125;,&#123;"name":"Koro1"&#125;,&#123;"name":"OB"&#125;,&#123;"name":"OB"&#125;,&#123;"name":"OB"&#125;]</span></span><br></pre></td></tr></table></figure><h4 id="ES6-copyWithin-指定位置的成员复制到其他位置"><a href="#ES6-copyWithin-指定位置的成员复制到其他位置" class="headerlink" title="ES6: copyWithin() 指定位置的成员复制到其他位置"></a>ES6: copyWithin() 指定位置的成员复制到其他位置</h4><p>定义: 在当前数组内部，将指定位置的成员复制到其他位置,并返回这个数组。<br>语法: <code>array.copyWithin(target, start = 0, end = this.length)</code></p><p>参数: 三个参数都是数值，如果不是，会自动转为数值。</p><ul><li>target（必需）: 从该位置开始替换数据。如果为负值，表示倒数。</li><li>start（可选）: 从该位置开始读取数据，默认为 0。如果为负值，表示倒数。</li><li>end（可选）: 到该位置前停止读取数据，默认等于数组长度。使用负数可从数组结尾处规定位置。</li></ul><p>浏览器兼容(MDN): <code>chrome 45</code>,<code>Edge 12</code>,<code>Firefox32</code>,<code>Opera 32</code>,<code>Safari 9</code>, <code>IE</code> 不支持</p><p>例:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -2相当于3号位，-1相当于4号位</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].copyWithin(<span class="number">0</span>, <span class="number">-2</span>, <span class="number">-1</span>);</span><br><span class="line"><span class="comment">// [4, 2, 3, 4, 5]</span></span><br><span class="line"><span class="keyword">let</span> a = [</span><br><span class="line">  <span class="string">"OB1"</span>,</span><br><span class="line">  <span class="string">"Koro1"</span>,</span><br><span class="line">  <span class="string">"OB2"</span>,</span><br><span class="line">  <span class="string">"Koro2"</span>,</span><br><span class="line">  <span class="string">"OB3"</span>,</span><br><span class="line">  <span class="string">"Koro3"</span>,</span><br><span class="line">  <span class="string">"OB4"</span>,</span><br><span class="line">  <span class="string">"Koro4"</span>,</span><br><span class="line">  <span class="string">"OB5"</span>,</span><br><span class="line">  <span class="string">"Koro5"</span></span><br><span class="line">];</span><br><span class="line"><span class="comment">// 2位置开始被替换,3位置开始读取要替换的 5位置前面停止替换</span></span><br><span class="line">a.copyWithin(<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line"><span class="comment">// ["OB1","Koro1","Koro2","OB3","OB3","Koro3","OB4","Koro4","OB5","Koro5"]</span></span><br></pre></td></tr></table></figure><p>从上述例子:</p><ol><li>第一个参数是开始被替换的元素位置</li><li>要替换数据的位置范围:从第二个参数是开始读取的元素，在第三个参数前面一个元素停止读取</li><li>数组的长度不会改变</li><li>读了几个元素就从开始被替换的地方替换几个元素</li></ol><h4 id="ES6-fill-填充数组"><a href="#ES6-fill-填充数组" class="headerlink" title="ES6: fill() 填充数组"></a>ES6: fill() 填充数组</h4><p>定义: 使用给定值，填充一个数组。<br>参数:</p><ul><li>第一个元素(必须): 要填充数组的值</li><li>第二个元素(可选): 填充的开始位置,默认值为 0</li><li>第三个元素(可选): 填充的结束位置，默认是为 this.length</li></ul><p>MDN 浏览器兼容</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> array1 = [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>];</span><br><span class="line"></span><br><span class="line">array1.fill(<span class="number">7</span>); <span class="comment">// [7, 7, 7]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> array2 = [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>];</span><br><span class="line">array2.fill(<span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>); <span class="comment">// ['a', 7, 'c']</span></span><br></pre></td></tr></table></figure><h3 id="不改变原数组的方法-8-个"><a href="#不改变原数组的方法-8-个" class="headerlink" title="不改变原数组的方法(8 个)"></a>不改变原数组的方法(8 个)</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5:</span></span><br><span class="line">join()、toLocateString()、toStrigin()、slice()、cancat()、indexOf()、lastIndexOf()、</span><br><span class="line"><span class="comment">// ES7:</span></span><br><span class="line">includes()</span><br></pre></td></tr></table></figure><h4 id="join-数组转字符串"><a href="#join-数组转字符串" class="headerlink" title="join() 数组转字符串"></a>join() 数组转字符串</h4><p>定义: join() 方法用于把数组中的所有元素通过指定的分隔符进行分隔放入一个字符串，返回生成的字符串。<br>语法: <code>array.join(str)</code><br>参数:</p><ul><li>str(可选): 指定要使用的分隔符，默认使用逗号作为分隔符。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="string">"hello"</span>, <span class="string">"world"</span>];</span><br><span class="line"><span class="keyword">let</span> str = a.join(); <span class="comment">// 'hello,world'</span></span><br><span class="line"><span class="keyword">let</span> str2 = a.join(<span class="string">"+"</span>); <span class="comment">// 'hello+world'</span></span><br></pre></td></tr></table></figure><p>使用 join 方法或者下文说到的 toString 方法时，当数组中的元素也是数组或者是对象时会出现什么情况？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [[<span class="string">"OBKoro1"</span>, <span class="string">"23"</span>], <span class="string">"test"</span>];</span><br><span class="line"><span class="keyword">let</span> str1 = a.join(); <span class="comment">// OBKoro1,23,test</span></span><br><span class="line"><span class="keyword">let</span> b = [&#123; <span class="attr">name</span>: <span class="string">"OBKoro1"</span>, <span class="attr">age</span>: <span class="string">"23"</span> &#125;, <span class="string">"test"</span>];</span><br><span class="line"><span class="keyword">let</span> str2 = b.join(); <span class="comment">// [object Object],test</span></span><br><span class="line"><span class="comment">// 对象转字符串推荐JSON.stringify(obj);</span></span><br></pre></td></tr></table></figure><p>所以，<code>join()</code>/<code>toString()</code>方法在数组元素是数组的时候，会将里面的数组也调用<code>join()</code>/<code>toString()</code>,如果是对象的话，对象会被转为<code>[object Object]</code>字符串。</p><h4 id="toLocaleString-数组转字符串"><a href="#toLocaleString-数组转字符串" class="headerlink" title="toLocaleString() 数组转字符串"></a>toLocaleString() 数组转字符串</h4><p>定义: 返回一个表示数组元素的字符串。该字符串由数组中的每个元素的 toLocaleString() 返回值经调用 join() 方法连接（由逗号隔开）组成。<br>语法: <code>array.toLocaleString()</code><br>参数: 无。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [&#123; <span class="attr">name</span>: <span class="string">"OBKoro1"</span> &#125;, <span class="number">23</span>, <span class="string">"abcd"</span>, <span class="keyword">new</span> <span class="built_in">Date</span>()];</span><br><span class="line"><span class="keyword">let</span> str = a.toLocaleString(); <span class="comment">// [object Object],23,abcd,2018/5/28 下午1:52:20</span></span><br></pre></td></tr></table></figure><p>如上述例子: 调用数组的<code>toLocaleString</code>方法，数组中的每个元素都会调用自身的<code>toLocaleString</code>方法，对象调用对象的<code>toLocaleString</code>,Date 调用 Date 的<code>toLocaleString</code>。</p><h4 id="toString-数组转字符串-不推荐"><a href="#toString-数组转字符串-不推荐" class="headerlink" title="toString() 数组转字符串 (不推荐)"></a>toString() 数组转字符串 (不推荐)</h4><p>定义: toString() 方法可把数组转换为由逗号链接起来的字符串。<br>语法: <code>array.toString()</code><br>参数: 无。</p><p>该方法的效果和 join 方法一样，都是用于数组转字符串的，但是与 join 方法相比没有优势，也不能自定义字符串的分隔符，因此不推荐使用。</p><p><strong>值得注意的是:</strong> 当数组和字符串操作的时候，js 会调用这个方法将数组自动转换成字符串</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> b = [<span class="string">"toString"</span>, <span class="string">"演示"</span>].toString(); <span class="comment">// toString,演示</span></span><br><span class="line"><span class="keyword">let</span> a = [<span class="string">"调用toString"</span>, <span class="string">"连接在我后面"</span>] + <span class="string">"啦啦啦"</span>; <span class="comment">// 调用toString,连接在我后面啦啦啦</span></span><br></pre></td></tr></table></figure><h4 id="slice-浅拷贝数组的元素"><a href="#slice-浅拷贝数组的元素" class="headerlink" title="slice() 浅拷贝数组的元素"></a>slice() 浅拷贝数组的元素</h4><p>定义: 方法返回一个从开始到结束（不包括结束）选择的数组的一部分浅拷贝到一个新数组对象，且原数组不会被修改。<br>注意: 字符串也有一个 slice() 方法是用来提取字符串的，不要弄混了。<br>语法: <code>array.slice(begin, end)</code><br>参数:</p><ul><li>begin(可选): 索引数值,接受负值，从该索引处开始提取原数组中的元素,默认值为 0。</li><li>end(可选):索引数值(不包括),接受负值，在该索引处前结束提取原数组元素，默认值为数组末尾(包括最后一个元素)。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="string">"hello"</span>, <span class="string">"world"</span>];</span><br><span class="line"><span class="keyword">let</span> b = a.slice(<span class="number">0</span>, <span class="number">1</span>); <span class="comment">// ['hello']</span></span><br><span class="line">a[<span class="number">0</span>] = <span class="string">"改变原数组"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a, b); <span class="comment">// ['改变原数组','world'] ['hello']</span></span><br><span class="line">b[<span class="number">0</span>] = <span class="string">"改变拷贝的数组"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a, b); <span class="comment">// ['改变原数组','world'] ['改变拷贝的数组']</span></span><br></pre></td></tr></table></figure><p><strong>如上:</strong> 新数组是浅拷贝的，元素是简单数据类型，改变之后不会互相干扰。<br>如果是复杂数据类型(对象,数组)的话，改变其中一个，另外一个也会改变。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [&#123; <span class="attr">name</span>: <span class="string">"OBKoro1"</span> &#125;];</span><br><span class="line"><span class="keyword">let</span> b = a.slice();</span><br><span class="line"><span class="built_in">console</span>.log(b, a); <span class="comment">// [&#123;"name":"OBKoro1"&#125;]  [&#123;"name":"OBKoro1"&#125;]</span></span><br><span class="line"><span class="comment">// a[0].name='改变原数组';</span></span><br><span class="line"><span class="comment">// console.log(b,a); // [&#123;"name":"改变原数组"&#125;] [&#123;"name":"改变原数组"&#125;]</span></span><br><span class="line"><span class="comment">// b[0].name='改变拷贝数组',b[0].koro='改变拷贝数组';</span></span><br><span class="line"><span class="comment">//  [&#123;"name":"改变拷贝数组","koro":"改变拷贝数组"&#125;] [&#123;"name":"改变拷贝数组","koro":"改变拷贝数组"&#125;]</span></span><br></pre></td></tr></table></figure><p>原因在定义上面说过了的:slice()是浅拷贝，对于复杂的数据类型浅拷贝，拷贝的只是指向原数组的指针，所以无论改变原数组，还是浅拷贝的数组，都是改变原数组的数据。</p><h4 id="cancat-数组合并"><a href="#cancat-数组合并" class="headerlink" title="cancat() 数组合并"></a>cancat() 数组合并</h4><p>定义: 方法用于合并两个或多个数组，返回一个新数组。<br>语法: <code>let newArr = oldArray.concat(arrayX,arrayX,......,arrayX)</code><br>参数:</p><ul><li>arrayX（必须）: 该参数可以是具体的值，也可以是数组对象。可以是任意多个。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> b = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="comment">//连接两个数组</span></span><br><span class="line"><span class="keyword">let</span> newVal = a.concat(b); <span class="comment">// [1,2,3,4,5,6]</span></span><br><span class="line"><span class="comment">// 连接三个数组</span></span><br><span class="line"><span class="keyword">let</span> c = [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>];</span><br><span class="line"><span class="keyword">let</span> newVal2 = a.concat(b, c); <span class="comment">// [1,2,3,4,5,6,7,8,9]</span></span><br><span class="line"><span class="comment">// 添加元素</span></span><br><span class="line"><span class="keyword">let</span> newVal3 = a.concat(<span class="string">"添加元素"</span>, b, c, <span class="string">"再加一个"</span>);</span><br><span class="line"><span class="comment">// [1,2,3,"添加元素",4,5,6,7,8,9,"再加一个"]</span></span><br><span class="line"><span class="comment">// 合并嵌套数组  会浅拷贝嵌套数组</span></span><br><span class="line"><span class="keyword">let</span> d = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">let</span> f = [<span class="number">3</span>, [<span class="number">4</span>]];</span><br><span class="line"><span class="keyword">let</span> newVal4 = d.concat(f); <span class="comment">// [1,2,3,[4]]</span></span><br></pre></td></tr></table></figure><h4 id="ES6-扩展运算符-合并数组"><a href="#ES6-扩展运算符-合并数组" class="headerlink" title="ES6 扩展运算符...合并数组"></a>ES6 扩展运算符<code>...</code>合并数组</h4><p>因为 ES6 的语法更简洁易懂，所以现在合并数组我大部分采用<code>...</code>来处理，<code>...</code>运算符可以实现<code>cancat</code>的每个例子，且更简洁和具有高度自定义数组元素位置的效果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> b = [<span class="number">4</span>, ...a, <span class="number">4</span>, <span class="number">4</span>];</span><br><span class="line"><span class="built_in">console</span>.log(a, b); <span class="comment">//  [2, 3, 4, 5] [4,2,3,4,5,4,4]</span></span><br></pre></td></tr></table></figure><p>更多关于扩展符的详细内容移步阮一峰大神的<a href="http://es6.ruanyifeng.com/#docs/array#%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6" target="_blank" rel="noopener">ECMAScript 6 入门</a></p><h4 id="indexOf-查找数组是否存在某个元素，返回下标"><a href="#indexOf-查找数组是否存在某个元素，返回下标" class="headerlink" title="indexOf() 查找数组是否存在某个元素，返回下标"></a>indexOf() 查找数组是否存在某个元素，返回下标</h4><p>定义: 返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1。<br>语法: <code>array.indexOf(searchElement,fromIndex)</code><br>参数:</p><ul><li>searchElement(必须): 被查找的元素</li><li>fromIndex(可选): 开始查找的位置(不能大于等于数组的长度，返回-1)，接受负值，默认值为 0。</li></ul><blockquote><p>严格相等的搜索: 数组的 indexOf 搜索跟字符串的 indexOf 不一样,数组的 indexOf 使用严格相等<code>===</code>搜索元素，即<strong>数组元素要完全匹配</strong>才能搜索成功。</p></blockquote><p><strong>注意:</strong>indexOf()不能识别 <code>NaN</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="string">"啦啦"</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">24</span>, <span class="literal">NaN</span>];</span><br><span class="line"><span class="built_in">console</span>.log(a.indexOf(<span class="string">"啦"</span>)); <span class="comment">// -1</span></span><br><span class="line"><span class="built_in">console</span>.log(a.indexOf(<span class="string">"NaN"</span>)); <span class="comment">// -1</span></span><br><span class="line"><span class="built_in">console</span>.log(a.indexOf(<span class="string">"啦啦"</span>)); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><p>使用场景:</p><ol><li>数组去重</li><li>根据获取的数组下标执行操作，改变数组中的值等。</li><li>判断是否存在，执行操作。</li></ol><h4 id="lastIndexOf-查找指定元素在数组中的最后一个位置"><a href="#lastIndexOf-查找指定元素在数组中的最后一个位置" class="headerlink" title="lastIndexOf() 查找指定元素在数组中的最后一个位置"></a>lastIndexOf() 查找指定元素在数组中的最后一个位置</h4><p>定义: 方法返回指定元素,在数组中的最后一个的索引，如果不存在则返回 -1。（从数组后面往前查找）<br>语法: <code>arr.lastIndexOf(searchElement,fromIndex)</code><br>参数:</p><ul><li>searchElement(必须): 被查找的元素</li><li>fromIndex(可选): 逆向查找开始位置，默认值数组的长度-1，即查找整个数组。</li><li>关于 fromIndex 有三个规则:<ul><li>正值。如果该值大于或等于数组的长度，则整个数组会被查找。</li><li>负值。将其视为从数组末尾向前的偏移。(比如-2，从数组最后第二个元素开始往前查找)</li><li>负值。其绝对值大于数组长度，则方法返回 -1，即数组不会被查找。</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组长度为10</span></span><br><span class="line"><span class="keyword">let</span> a = [<span class="string">"OB"</span>, <span class="number">4</span>, <span class="string">"Koro1"</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="string">"Koro1"</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="string">"Koro1"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从下标4开始往前找 返回下标2</span></span><br><span class="line"><span class="built_in">console</span>.log(a.lastIndexOf(<span class="string">"Koro1"</span>, <span class="number">4</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//  大于或数组的长度 查找整个数组 返回9</span></span><br><span class="line"><span class="built_in">console</span>.log(a.lastIndexOf(<span class="string">"Koro1"</span>, <span class="number">100</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// -1 数组不会被查找</span></span><br><span class="line"><span class="built_in">console</span>.log(a.lastIndexOf(<span class="string">"Koro1"</span>, <span class="number">-11</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从第二个元素4往前查找，没有找到 返回-1</span></span><br><span class="line"><span class="built_in">console</span>.log(a.lastIndexOf(<span class="string">"Koro1"</span>, <span class="number">-9</span>));</span><br></pre></td></tr></table></figure><h4 id="ES7-includes-查找数组是否包含某个元素-返回布尔"><a href="#ES7-includes-查找数组是否包含某个元素-返回布尔" class="headerlink" title="ES7: includes() 查找数组是否包含某个元素 返回布尔"></a>ES7: includes() 查找数组是否包含某个元素 返回布尔</h4><p>定义: 返回一个布尔值，表示某个数组是否包含给定的值</p><p>语法: <code>array.includes(searchElement,fromIndex=0)</code><br>参数:</p><ul><li>searchElement(必须):被查找的元素</li><li>fromIndex(可选):默认值为 0，参数表示搜索的起始位置，接受负值。正值超过数组长度，数组不会被搜索，返回 false。负值绝对值超过长数组度，重置从 0 开始搜索。</li></ul><p><strong>includes 方法是为了弥补 indexOf 方法的缺陷而出现的</strong>:</p><ol><li>indexOf 方法不能识别 <code>NaN</code></li><li>indexOf 方法检查是否包含某个值不够语义化，需要判断是否不等于<code>-1</code>，表达不够直观</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="string">"OB"</span>, <span class="string">"Koro1"</span>, <span class="number">1</span>, <span class="literal">NaN</span>];</span><br><span class="line"><span class="built_in">console</span>.log(a.includes(<span class="literal">NaN</span>)); <span class="comment">// true 识别NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(a.includes(<span class="string">"Koro1"</span>, <span class="number">100</span>)); <span class="comment">// false 超过数组长度 不搜索</span></span><br><span class="line"><span class="built_in">console</span>.log(a.includes(<span class="string">"Koro1"</span>, <span class="number">-3</span>)); <span class="comment">// true 从倒数第三个元素开始搜索</span></span><br><span class="line"><span class="built_in">console</span>.log(a.includes(<span class="string">"Koro1"</span>, <span class="number">-100</span>)); <span class="comment">// true 负值绝对值超过数组长度，搜索整个数组</span></span><br></pre></td></tr></table></figure><p>兼容性(MDN): <code>chrome47</code>, <code>Firefox 43</code>,<code>Edge 14</code>,<code>Opera 34</code>, <code>Safari 9</code>,<code>IE</code> 未实现。</p><h3 id="遍历方法-12-个"><a href="#遍历方法-12-个" class="headerlink" title="遍历方法(12 个)"></a>遍历方法(12 个)</h3><p>js 中遍历数组并不会改变原始数组的方法总共有 12 个:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5:</span></span><br><span class="line">forEach()、every() 、some()、 fliter()、map()、reduce()、reduceRight()</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6:</span></span><br><span class="line">find()、findIndex()、keys()、values()、entries()</span><br></pre></td></tr></table></figure><p><strong>关于遍历:</strong></p><ul><li>关于遍历的效率，可以看一下这篇详解 JS 遍历</li><li>尽量不要在遍历的时候，修改后面要遍历的值</li><li>尽量不要在遍历的时候修改数组的长度（删除/添加）</li></ul><h4 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h4><p>定义: 按升序为数组中含有效值的每一项执行一次回调函数。<br>语法: <code>array.forEach(function(currentValue, index, arr), thisValue)</code><br>参数:</p><ul><li>function(必须): 数组中每个元素需要调用的函数<ul><li>currentValue(必须),数组当前元素的值</li><li>index(可选), 当前元素的索引值</li><li>arr(可选),数组对象本身</li></ul></li><li>thisValue (可选): 当执行回调函数时 this 绑定对象的值，默认值为<code>undefined</code></li></ul><p><strong>关于 forEach()你要知道:</strong></p><ul><li>无法中途退出循环，只能用 <code>return</code> 退出本次回调，进行下一次回调。</li><li>它总是返回 <code>undefined</code> 值,即使你 <code>return</code> 了一个值。</li></ul><p><strong>下面类似语法同样适用这些规则:</strong></p><ol><li>对于空数组是不会执行回调函数的</li><li>对于已在迭代过程中删除的元素，或者空元素会跳过回调函数</li><li>遍历次数再第一次循环前就会确定，再添加到数组中的元素不会被遍历。</li><li>如果已经存在的值被改变，则传递给 callback 的值是遍历到他们那一刻的值。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, , <span class="number">3</span>]; <span class="comment">// 最后第二个元素是空的，不会遍历(undefined、null会遍历)</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">name</span>: <span class="string">"OBKoro1"</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> result = a.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">value, index, array</span>) </span>&#123;</span><br><span class="line">  a[<span class="number">3</span>] = <span class="string">"改变元素"</span>;</span><br><span class="line">  a.push(<span class="string">"添加到尾端，不会被遍历"</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(value, <span class="string">"forEach传递的第一个参数"</span>); <span class="comment">// 分别打印 1 ,2 ,改变元素</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name); <span class="comment">// OBKoro1 打印三次 this绑定在obj对象上</span></span><br><span class="line">  <span class="comment">// break; // break会报错</span></span><br><span class="line">  <span class="keyword">return</span> value; <span class="comment">// return只能结束本次回调 会执行下次回调</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"不会执行，因为return 会执行下一次循环回调"</span>);</span><br><span class="line">&#125;, obj);</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// 即使return了一个值,也还是返回undefined</span></span><br><span class="line"><span class="comment">// 回调函数也接受接头函数写法</span></span><br></pre></td></tr></table></figure><h4 id="every-检测数组所有元素是否都符合判断条件"><a href="#every-检测数组所有元素是否都符合判断条件" class="headerlink" title="every 检测数组所有元素是否都符合判断条件"></a>every 检测数组所有元素是否都符合判断条件</h4><p>定义: 方法用于检测数组所有元素是否都符合函数定义的条件<br>语法: <code>array.every(function(currentValue, index, arr), thisValue)</code><br>参数: (这几个方法的参数，语法都类似)</p><ul><li>function(必须): 数组中每个元素需要调用的函数。<ul><li>currentValue(必须),数组当前元素的值</li><li>index(可选), 当前元素的索引值</li><li>arr(可选),数组对象本身</li></ul></li><li>thisValue(可选): 当执行回调函数时 this 绑定对象的值，默认值为<code>undefined</code></li></ul><p>方法返回值规则:</p><ol><li>如果数组中检测到有一个元素不满足，则整个表达式返回 false，且剩余的元素不会再进行检测。</li><li>如果所有元素都满足条件，则返回 true。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isBigEnough</span>(<span class="params">element, index, array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> element &gt;= <span class="number">10</span>; <span class="comment">// 判断数组中的所有元素是否都大于10</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> result = [<span class="number">12</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">130</span>, <span class="number">44</span>].every(isBigEnough); <span class="comment">// false</span></span><br><span class="line"><span class="keyword">let</span> result = [<span class="number">12</span>, <span class="number">54</span>, <span class="number">18</span>, <span class="number">130</span>, <span class="number">44</span>].every(isBigEnough); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 接受箭头函数写法</span></span><br><span class="line">[<span class="number">12</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">130</span>, <span class="number">44</span>].every(<span class="function"><span class="params">x</span> =&gt;</span> x &gt;= <span class="number">10</span>); <span class="comment">// false</span></span><br><span class="line">[<span class="number">12</span>, <span class="number">54</span>, <span class="number">18</span>, <span class="number">130</span>, <span class="number">44</span>].every(<span class="function"><span class="params">x</span> =&gt;</span> x &gt;= <span class="number">10</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h4 id="some-数组中的是否有满足判断条件的元素"><a href="#some-数组中的是否有满足判断条件的元素" class="headerlink" title="some 数组中的是否有满足判断条件的元素"></a>some 数组中的是否有满足判断条件的元素</h4><p>定义: 数组中的是否有满足判断条件的元素<br>语法: <code>array.some(function(currentValue, index, arr), thisValue)</code><br>参数: (这几个方法的参数，语法都类似)</p><ul><li>function(必须): 数组中每个元素需要调用的函数。<ul><li>currentValue(必须),数组当前元素的值</li><li>index(可选), 当前元素的索引值</li><li>arr(可选),数组对象本身</li></ul></li><li>thisValue(可选): 当执行回调函数时 this 绑定对象的值，默认值为<code>undefined</code></li></ul><p>方法返回值规则:</p><ol><li>如果有一个元素满足条件，则表达式返回 true, 剩余的元素不会再执行检测。</li><li>如果没有满足条件的元素，则返回 false。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isBigEnough</span>(<span class="params">element, index, array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> element &gt;= <span class="number">10</span>; <span class="comment">//数组中是否有一个元素大于 10</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> result = [<span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">4</span>].some(isBigEnough); <span class="comment">// false</span></span><br><span class="line"><span class="keyword">let</span> result = [<span class="number">12</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">4</span>].some(isBigEnough); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h4 id="filter-过滤原始数组，返回新数组"><a href="#filter-过滤原始数组，返回新数组" class="headerlink" title="filter 过滤原始数组，返回新数组"></a>filter 过滤原始数组，返回新数组</h4><p>定义: 返回一个新数组, 其包含通过所提供函数实现的测试的所有元素。<br>语法: <code>let new_array = arr.filter(function(currentValue, index, arr), thisArg)</code><br>参数: (这几个方法的参数，语法都类似)</p><ul><li>function(必须): 数组中每个元素需要调用的函数。<ul><li>currentValue(必须),数组当前元素的值</li><li>index(可选), 当前元素的索引值</li><li>arr(可选),数组对象本身</li></ul></li><li>thisArg(可选): 当执行回调函数时 this 绑定对象的值，默认值为<code>undefined</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">32</span>, <span class="number">33</span>, <span class="number">16</span>, <span class="number">40</span>];</span><br><span class="line"><span class="keyword">let</span> result = a.filter(<span class="function"><span class="keyword">function</span>(<span class="params">value, index, array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value &gt;= <span class="number">18</span>; <span class="comment">// 返回a数组中所有大于18的元素</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(result, a); <span class="comment">// [32,33,40] [32,33,16,40]</span></span><br></pre></td></tr></table></figure><h4 id="map-对数组中的每个元素进行处理，返回新的数组"><a href="#map-对数组中的每个元素进行处理，返回新的数组" class="headerlink" title="map 对数组中的每个元素进行处理，返回新的数组"></a>map 对数组中的每个元素进行处理，返回新的数组</h4><p>定义: 创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。<br>语法: <code>let new_array = arr.map(function(currentValue, index, arr), thisArg)</code><br>参数: (这几个方法的参数，语法都类似)</p><ul><li>function(必须): 数组中每个元素需要调用的函数。<ul><li>currentValue(必须),数组当前元素的值</li><li>index(可选), 当前元素的索引值</li><li>arr(可选),数组对象本身</li></ul></li><li>thisArg(可选): 当执行回调函数时 this 绑定对象的值，默认值为<code>undefined</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="string">'1'</span>,<span class="string">'2'</span>,<span class="string">'3'</span>,<span class="string">'4'</span>];</span><br><span class="line"><span class="keyword">let</span> result = a.map(<span class="function"><span class="keyword">function</span> (<span class="params">value, index, array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value + <span class="string">'新数组的新元素'</span></span><br><span class="line"><span class="built_in">console</span>.log(result, a);</span><br><span class="line"><span class="comment">// ["1新数组的新元素","2新数组的新元素","3新数组的新元素","4新数组的新元素"] ["1","2","3","4"]</span></span><br></pre></td></tr></table></figure><h4 id="reduce-为数组提供累加器，合并为一个值"><a href="#reduce-为数组提供累加器，合并为一个值" class="headerlink" title="reduce 为数组提供累加器，合并为一个值"></a>reduce 为数组提供累加器，合并为一个值</h4><p>定义: reduce() 方法对累加器和数组中的每个元素（从左到右）应用一个函数，最终合并为一个值。<br>语法: <code>array.reduce(function(total, currentValue, currentIndex, arr), initialValue)</code><br>参数:</p><ul><li>function(必须): 数组中每个元素需要调用的函数。<ul><li>total(必须)，初始值, 或者上一次调用回调返回的值</li><li>currentValue(必须),数组当前元素的值</li><li>index(可选), 当前元素的索引值</li><li>arr(可选),数组对象本身</li></ul></li><li>initialValue(可选): 指定第一次回调 的第一个参数。<br>回调第一次执行时:<ul><li>如果 initialValue 在调用 reduce 时被提供，那么第一个 total 将等于 initialValue，此时 currentValue 等于数组中的第一个值；</li><li>如果 initialValue 未被提供，那么 total 等于数组中的第一个值，currentValue 等于数组中的第二个值。此时如果数组为空，那么将抛出 TypeError。</li><li>如果数组仅有一个元素，并且没有提供 initialValue，或提供了 initialValue 但数组为空，那么回调不会被执行，数组的唯一值将被返回。</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组求和</span></span><br><span class="line"><span class="keyword">let</span> sum = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].reduce(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 6</span></span><br><span class="line"><span class="comment">// 将二维数组转化为一维 将数组元素展开</span></span><br><span class="line"><span class="keyword">let</span> flattened = [[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>]].reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a.concat(b), []);</span><br><span class="line"><span class="comment">// [0, 1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure><h4 id="reduceRight-从右至左累加"><a href="#reduceRight-从右至左累加" class="headerlink" title="reduceRight 从右至左累加"></a>reduceRight 从右至左累加</h4><p>这个方法除了与 reduce 执行方向相反外，其他完全与其一致，请参考上述 reduce 方法介绍。</p><h4 id="ES6-find-amp-findIndex-根据条件找到数组成员"><a href="#ES6-find-amp-findIndex-根据条件找到数组成员" class="headerlink" title="ES6: find() &amp; findIndex() 根据条件找到数组成员"></a>ES6: find() &amp; findIndex() 根据条件找到数组成员</h4><p>find()定义: 用于找出第一个符合条件的数组成员，并返回该成员，如果没有符合条件的成员，则返回 undefined。<br>findIndex()定义: 返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。<br>这两个方法<br>语法:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// find</span></span><br><span class="line"><span class="keyword">let</span> new_array = arr.find(<span class="function"><span class="keyword">function</span>(<span class="params">currentValue, index, arr</span>), <span class="title">thisArg</span>);</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// findIndex</span></span><br><span class="line"><span class="keyword">let</span> new_array_index = arr.findIndex(<span class="function"><span class="keyword">function</span>(<span class="params">currentValue, index, arr</span>), <span class="title">thisArg</span>);</span></span><br></pre></td></tr></table></figure><p>参数:(这几个方法的参数，语法都类似)</p><ul><li>function(必须): 数组中每个元素需要调用的函数。<ul><li>currentValue(必须),数组当前元素的值</li><li>index(可选), 当前元素的索引值</li><li>arr(可选),数组对象本身</li></ul></li><li>thisArg(可选): 当执行回调函数时 this 绑定对象的值，默认值为<code>undefined</code></li></ul><p>这两个方法都可以识别<code>NaN</code>,弥补了<code>indexOf</code>的不足.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// find</span></span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">-5</span>, <span class="number">10</span>].find(<span class="function"><span class="params">n</span> =&gt;</span> n &lt; <span class="number">0</span>); <span class="comment">// 返回元素-5</span></span><br><span class="line"><span class="keyword">let</span> b = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">-5</span>, <span class="number">10</span>, <span class="literal">NaN</span>].find(<span class="function"><span class="params">n</span> =&gt;</span> <span class="built_in">Object</span>.is(<span class="literal">NaN</span>, n)); <span class="comment">// 返回元素NaN</span></span><br><span class="line"><span class="comment">// findIndex</span></span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">-5</span>, <span class="number">10</span>].findIndex(<span class="function"><span class="params">n</span> =&gt;</span> n &lt; <span class="number">0</span>); <span class="comment">// 返回索引2</span></span><br><span class="line"><span class="keyword">let</span> b = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">-5</span>, <span class="number">10</span>, <span class="literal">NaN</span>].findIndex(<span class="function"><span class="params">n</span> =&gt;</span> <span class="built_in">Object</span>.is(<span class="literal">NaN</span>, n)); <span class="comment">// 返回索引4</span></span><br></pre></td></tr></table></figure><p>浏览器兼容(MDN):<code>Chrome 45</code>,<code>Firefox 25</code>,<code>Opera 32</code>, <code>Safari 8</code>, <code>Edge</code> yes,</p><h4 id="ES6-keys-amp-values-amp-entries-遍历键名、遍历键值、遍历键名-键值"><a href="#ES6-keys-amp-values-amp-entries-遍历键名、遍历键值、遍历键名-键值" class="headerlink" title="ES6 keys() &amp; values() &amp; entries() 遍历键名、遍历键值、遍历键名+键值"></a>ES6 keys() &amp; values() &amp; entries() 遍历键名、遍历键值、遍历键名+键值</h4><p>定义: 三个方法都返回一个新的 Array Iterator 对象，对象根据方法不同包含不同的值。</p><p>语法:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array.keys();</span><br><span class="line">array.values();</span><br><span class="line">array.entries();</span><br></pre></td></tr></table></figure><p>参数: 无。</p><p>遍历例子(摘自<a href="http://es6.ruanyifeng.com/#docs/array#%E6%95%B0%E7%BB%84%E5%AE%9E%E4%BE%8B%E7%9A%84-entries%EF%BC%8Ckeys-%E5%92%8C-values" target="_blank" rel="noopener">ECMAScript 6 入门</a>):</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> index <span class="keyword">of</span> [<span class="string">"a"</span>, <span class="string">"b"</span>].keys()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> elem <span class="keyword">of</span> [<span class="string">"a"</span>, <span class="string">"b"</span>].values()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(elem);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 'a'</span></span><br><span class="line"><span class="comment">// 'b'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [index, elem] <span class="keyword">of</span> [<span class="string">"a"</span>, <span class="string">"b"</span>].entries()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(index, elem);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0 "a"</span></span><br><span class="line"><span class="comment">// 1 "b"</span></span><br></pre></td></tr></table></figure><p>在<code>for..of</code>中如果遍历中途要退出，可以使用<code>break</code>退出循环。<br>如果不使用<code>for...of</code>循环，可以手动调用遍历器对象的<code>next</code>方法，进行遍历。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> letter = [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>];</span><br><span class="line"><span class="keyword">let</span> entries = letter.entries();</span><br><span class="line"><span class="built_in">console</span>.log(entries.next().value); <span class="comment">// [0, 'a']</span></span><br><span class="line"><span class="built_in">console</span>.log(entries.next().value); <span class="comment">// [1, 'b']</span></span><br><span class="line"><span class="built_in">console</span>.log(entries.next().value); <span class="comment">// [2, 'c']</span></span><br></pre></td></tr></table></figure><blockquote><p>entries()浏览器兼容性(MDN):<code>Chrome 38</code>,<code>Firefox 28</code>,<code>Opera 25</code>,<code>Safari 7.1</code><br>keys()浏览器兼容性(MDN):<code>Chrome 38</code>, <code>Firefox 28</code>,<code>Opera 25</code>,<code>Safari 8</code></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;创建一个数组&quot;&gt;&lt;a href=&quot;#创建一个数组&quot; class=&quot;headerlink&quot; title=&quot;创建一个数组&quot;&gt;&lt;/a&gt;创建一个数组&lt;/h2&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 字面量方式:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 这个方法也是我们最常用的，在初始化数组的时候 相当方便&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; a = [&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;]; &lt;span class=&quot;comment&quot;&gt;// [3,11,8];&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 构造器:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 实际上 new Array === Array,加不加new 一点影响都没有。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; a = &lt;span class=&quot;built_in&quot;&gt;Array&lt;/span&gt;(); &lt;span class=&quot;comment&quot;&gt;// []&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; a = &lt;span class=&quot;built_in&quot;&gt;Array&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;); &lt;span class=&quot;comment&quot;&gt;// [undefined,undefined,undefined]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; a = &lt;span class=&quot;built_in&quot;&gt;Array&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;); &lt;span class=&quot;comment&quot;&gt;// [ 3,11,8 ]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&quot;ES6-Array-of-返回由所有参数值组成的数组&quot;&gt;&lt;a href=&quot;#ES6-Array-of-返回由所有参数值组成的数组&quot; class=&quot;headerlink&quot; title=&quot;ES6 Array.of() 返回由所有参数值组成的数组&quot;&gt;&lt;/a&gt;ES6 Array.of() 返回由所有参数值组成的数组&lt;/h3&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://csjiabin.github.io/categories/JavaScript/"/>
    
    
      <category term="js" scheme="https://csjiabin.github.io/tags/js/"/>
    
      <category term="学习笔记" scheme="https://csjiabin.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>JS中的内存管理</title>
    <link href="https://csjiabin.github.io/2018/11/18/JS%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>https://csjiabin.github.io/2018/11/18/JS%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</id>
    <published>2018-11-18T10:41:32.000Z</published>
    <updated>2020-11-02T09:26:56.673Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>像 C 语言这样的高级语言一般都有底层的内存管理接口,比如 malloc()和 free().另一方面,JavaScript 创建变量（对象,字符串等）时分配内存,并且在不再使用它们时“自动”释放. 后一个过程称为垃圾回收.这个“自动”是混乱的根源,并让 JavaScript（和其他高级语言）开发者感觉他们可以不关心内存管理. 这是错误的,所以可以通过平时多了解一些 JS 中内存管理问题, 在写代码中通过一些习惯, 避免内存泄露的问题.</p><h2 id="内存生命周期"><a href="#内存生命周期" class="headerlink" title="内存生命周期"></a>内存生命周期</h2><p><img data-src="/uploads/post/js-memory-management.jpg" alt="生命周期"></p><p>不管什么程序语言,内存生命周期基本是一致的：</p><ol><li>分配你所需要的内存</li><li>使用分配到的内存（读、写）</li><li>不需要时将其释放\归还</li></ol><p>所有语言第二部分都是明确的.第一和第三部分在底层语言中是明确的,但在像 JavaScript 这些高级语言中,大部分都是隐含的.</p><h3 id="JavaScript-的内存分配"><a href="#JavaScript-的内存分配" class="headerlink" title="JavaScript 的内存分配"></a>JavaScript 的内存分配</h3><h4 id="值的初始化"><a href="#值的初始化" class="headerlink" title="值的初始化"></a>值的初始化</h4><p>为了不让程序员费心分配内存,JavaScript 在定义变量时就完成了内存分配.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="number">123</span>; <span class="comment">// 给数值变量分配内存</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="string">"azerty"</span>; <span class="comment">// 给字符串分配内存</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="literal">null</span></span><br><span class="line">&#125;; <span class="comment">// 给对象及其包含的值分配内存</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 给数组及其包含的值分配内存（就像对象一样）</span></span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="literal">null</span>, <span class="string">"abra"</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + <span class="number">2</span>;</span><br><span class="line">&#125; <span class="comment">// 给函数（可调用的对象）分配内存</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数表达式也能分配一个对象</span></span><br><span class="line">someElement.addEventListener(</span><br><span class="line">  <span class="string">"click"</span>,</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    someElement.style.backgroundColor = <span class="string">"blue"</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="通过函数调用分配内存"><a href="#通过函数调用分配内存" class="headerlink" title="通过函数调用分配内存"></a>通过函数调用分配内存</h4><p>有些函数调用结果是分配对象内存：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>(); <span class="comment">// 分配一个 Date 对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> e = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>); <span class="comment">// 分配一个 DOM 元素</span></span><br></pre></td></tr></table></figure><p>有些方法分配新变量或者新对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">"azerty"</span>;</span><br><span class="line"><span class="keyword">var</span> s2 = s.substr(<span class="number">0</span>, <span class="number">3</span>); <span class="comment">// s2 是一个新的字符串</span></span><br><span class="line"><span class="comment">// 因为字符串是不变量,</span></span><br><span class="line"><span class="comment">// JavaScript 可能决定不分配内存,</span></span><br><span class="line"><span class="comment">// 只是存储了 [0-3] 的范围.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = [<span class="string">"ouais ouais"</span>, <span class="string">"nan nan"</span>];</span><br><span class="line"><span class="keyword">var</span> a2 = [<span class="string">"generation"</span>, <span class="string">"nan nan"</span>];</span><br><span class="line"><span class="keyword">var</span> a3 = a.concat(a2);</span><br><span class="line"><span class="comment">// 新数组有四个元素,是 a 连接 a2 的结果</span></span><br></pre></td></tr></table></figure><h3 id="使用值"><a href="#使用值" class="headerlink" title="使用值"></a>使用值</h3><p>的过程实际上是对分配内存进行读取与写入的操作.读取与写入可能是写入一个变量或者一个对象的属性值,甚至传递函数的参数.</p><h3 id="当内存不再需要使用时释放"><a href="#当内存不再需要使用时释放" class="headerlink" title="当内存不再需要使用时释放"></a>当内存不再需要使用时释放</h3><p>大多数内存管理的问题都在这个阶段.在这里最艰难的任务是找到“所分配的内存确实已经不再需要了”.它往往要求开发人员来确定在程序中哪一块内存不再需要并且释放它.</p><h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><p>如上所述自动寻找是否一些内存“不再需要”的问题是无法判定的.因此,垃圾回收实现只能有限制的解决一般问题.</p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>垃圾回收算法主要依赖于引用的概念.在内存管理的环境中,一个对象如果有访问另一个对象的权限（隐式或者显式）,叫做一个对象引用另一个对象.例如,一个 Javascript 对象具有对它原型的引用（隐式引用）和对它属性的引用（显式引用）.<br>在这里,“对象”的概念不仅特指 JavaScript 对象,还包括函数作用域（或者全局词法作用域）.</p><h3 id="引用计数垃圾收集"><a href="#引用计数垃圾收集" class="headerlink" title="引用计数垃圾收集"></a>引用计数垃圾收集</h3><p>在下面的例子中, 此算法把“对象是否不再需要”简化定义为“对象有没有其他对象引用到它”.如果没有引用指向该对象（零引用）,对象将被垃圾回收机制回收.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  a: &#123;</span><br><span class="line">    b: <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 两个对象被创建,一个作为另一个的属性被引用,另一个被分配给变量o</span></span><br><span class="line"><span class="comment">// 很显然,没有一个可以被垃圾收集</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o2 = o; <span class="comment">// o2变量是第二个对“这个对象”的引用</span></span><br><span class="line"></span><br><span class="line">o = <span class="number">1</span>; <span class="comment">// 现在,“这个对象”的原始引用o被o2替换了</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> oa = o2.a; <span class="comment">// 引用“这个对象”的a属性</span></span><br><span class="line"><span class="comment">// 现在,“这个对象”有两个引用了,一个是o2,一个是oa</span></span><br><span class="line"></span><br><span class="line">o2 = <span class="string">"yo"</span>; <span class="comment">// 最初的对象现在已经是零引用了</span></span><br><span class="line"><span class="comment">// 他可以被垃圾回收了</span></span><br><span class="line"><span class="comment">// 然而它的属性a的对象还在被oa引用,所以还不能回收</span></span><br><span class="line"></span><br><span class="line">oa = <span class="literal">null</span>; <span class="comment">// a属性的那个对象现在也是零引用了</span></span><br><span class="line"><span class="comment">// 它可以被垃圾回收了</span></span><br></pre></td></tr></table></figure><h3 id="限制：循环引用"><a href="#限制：循环引用" class="headerlink" title="限制：循环引用"></a>限制：循环引用</h3><p>该算法有个限制：无法处理循环引用.在下面的例子中,两个对象被创建,并互相引用,形成了一个循环.它们被调用之后会离开函数作用域,所以它们已经没有用了,可以被回收了.然而,引用计数算法考虑到它们互相都有至少一次引用,所以它们不会被回收.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> o = &#123;&#125;;</span><br><span class="line">  <span class="keyword">var</span> o2 = &#123;&#125;;</span><br><span class="line">  o.a = o2; <span class="comment">// o 引用 o2</span></span><br><span class="line">  o2.a = o; <span class="comment">// o2 引用 o</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="string">"azerty"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f();</span><br></pre></td></tr></table></figure><p><img data-src="/uploads/post/js-loop-memory-management.jpg" alt="限制：循环引用"><br><strong>实际例子:</strong><br>IE 6, 7 使用引用计数方式对 DOM 对象进行垃圾回收.该方式常常造成对象被循环引用时内存发生泄漏：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div;</span><br><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  div = <span class="built_in">document</span>.getElementById(<span class="string">"myDivElement"</span>);</span><br><span class="line">  div.circularReference = div;</span><br><span class="line">  div.lotsOfData = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">10000</span>).join(<span class="string">"*"</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在上面的例子里,myDivElement 这个 DOM 元素里的 circularReference 属性引用了 myDivElement,造成了循环引用.如果该属性没有显示移除或者设为 null,引用计数式垃圾收集器将总是且至少有一个引用,并将一直保持在内存里的 DOM 元素,即使其从 DOM 树中删去了.如果这个 DOM 元素拥有大量的数据 (如上的 lotsOfData 属性),而这个数据占用的内存将永远不会被释放.</p><h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><p>这个算法把“对象是否不再需要”简化定义为“对象是否可以获得”.</p><p>这个算法假定设置一个叫做根（root）的对象（在 Javascript 里,根是全局对象）.垃圾回收器将定期从根开始,找所有从根开始引用的对象,然后找这些对象引用的对象……从根开始,垃圾回收器将找到所有可以获得的对象和收集所有不能获得的对象.</p><p>这个算法比前一个要好,因为“有零引用的对象”总是不可获得的,但是相反却不一定,参考“循环引用”.</p><p>从 2012 年起,所有现代浏览器都使用了标记-清除垃圾回收算法.所有对 JavaScript 垃圾回收算法的改进都是基于标记-清除算法的改进,并没有改进标记-清除算法本身和它对“对象是否不再需要”的简化定义.<br><img data-src="/uploads/post/3.gif" alt="标记-清除算法"></p><h3 id="自动-GC-的问题"><a href="#自动-GC-的问题" class="headerlink" title="自动 GC 的问题"></a>自动 GC 的问题</h3><p>尽管自动 GC 很方便, 但是我们不知道 GC 什么时候会进行. 这意味着如果我们在使用过程中使用了大量的内存, 而 GC 没有运行的情况下, 或者 GC 无法回收这些内存的情况下, 程序就有可能假死, 这个就需要我们在程序中手动做一些操作来触发内存回收.</p><h2 id="什么是内存泄露"><a href="#什么是内存泄露" class="headerlink" title="什么是内存泄露?"></a>什么是内存泄露?</h2><p>本质上讲, 内存泄露就是不再被需要的内存, 由于某种原因, 无法被释放.<br><img data-src="/uploads/post/4.jpg" alt="标记-清除算法"></p><h2 id="常见的内存泄露案例"><a href="#常见的内存泄露案例" class="headerlink" title="常见的内存泄露案例"></a>常见的内存泄露案例</h2><h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">  bar = <span class="string">"some text"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 JS 中处理未被声明的变量, 上述范例中的 bar 时, 会把 bar, 定义到全局对象中, 在浏览器中就是 window 上. 在页面中的全局变量, 只有当页面被关闭后才会被销毁.所以这种写法就会造成内存泄露, 当然在这个例子中泄露的只是一个简单的字符串, 但是在实际的代码中, 往往情况会更加糟糕.</p><p>另外一种意外创建全局变量的情况.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.var1 = <span class="string">"potential accidental global"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Foo 被调用时, this 指向全局变量(window)</span></span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><p>在这种情况下调用 foo, this 被指向了全局变量 window, 意外的创建了全局变量.</p><p>我们谈到了一些意外情况下定义的全局变量, 代码中也有一些我们明确定义的全局变量. 如果使用这些全局变量用来暂存大量的数据, 记得在使用后, 对其重新赋值为 null.</p><h3 id="未销毁的定时器和回调函数"><a href="#未销毁的定时器和回调函数" class="headerlink" title="未销毁的定时器和回调函数"></a>未销毁的定时器和回调函数</h3><p>在很多库中, 如果使用了观察着模式, 都会提供回调方法, 来调用一些回调函数. 要记得回收这些回调函数. 举一个 setInterval 的例子.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> serverData = loadData();</span><br><span class="line">setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> renderer = <span class="built_in">document</span>.getElementById(<span class="string">"renderer"</span>);</span><br><span class="line">  <span class="keyword">if</span> (renderer) &#123;</span><br><span class="line">    renderer.innerHTML = <span class="built_in">JSON</span>.stringify(serverData);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, <span class="number">5000</span>); <span class="comment">// 每 5 秒调用一次</span></span><br></pre></td></tr></table></figure><p>如果后续 renderer 元素被移除, 整个定时器实际上没有任何作用. 但如果你没有回收定时器, 整个定时器依然有效, 不但定时器无法被内存回收, 定时器函数中的依赖也无法回收. 在这个案例中的 serverData 也无法被回收.</p><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>在 JS 开发中, 我们会经常用到闭包, 一个内部函数, 有权访问包含其的外部函数中的变量. 下面这种情况下, 闭包也会造成内存泄露.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> theThing = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">var</span> replaceThing = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> originalThing = theThing;</span><br><span class="line">  <span class="keyword">var</span> unused = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (originalThing)</span><br><span class="line">      <span class="comment">// 对于 'originalThing'的引用</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"hi"</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  theThing = &#123;</span><br><span class="line">    longStr: <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1000000</span>).join(<span class="string">"*"</span>),</span><br><span class="line">    someMethod: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"message"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">setInterval(replaceThing, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>这段代码, 每次调用 replaceThing 时, theThing 获得了包含一个巨大的数组和一个对于新闭包 someMethod 的对象. 同时 unused 是一个引用了 originalThing 的闭包.</p><p>这个范例的关键在于, 闭包之间是共享作用域的, 尽管 unused 可能一直没有被调用, 但是 someMethod 可能会被调用, 就会导致内存无法对其进行回收. 当这段代码被反复执行时, 内存会持续增长.</p><p>该问题的更多描述阅读<a href="https://blog.meteor.com/an-interesting-kind-of-javascript-memory-leak-8b47d2e7f156" target="_blank" rel="noopener">这篇文章</a>.</p><h3 id="DOM-引用"><a href="#DOM-引用" class="headerlink" title="DOM 引用"></a>DOM 引用</h3><p>很多时候, 我们对 Dom 的操作, 会把 Dom 的引用保存在一个数组或者 Map 中.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> elements = &#123;</span><br><span class="line">  image: <span class="built_in">document</span>.getElementById(<span class="string">"image"</span>)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doStuff</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  elements.image.src = <span class="string">"http://example.com/image_name.png"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeImage</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">document</span>.body.removeChild(<span class="built_in">document</span>.getElementById(<span class="string">"image"</span>));</span><br><span class="line">  <span class="comment">// 这个时候我们对于 #image 仍然有一个引用, Image 元素, 仍然无法被内存回收.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述案例中, 即使我们对于 image 元素进行了移除, 但是仍然有对 image 元素的引用, 依然无法对齐进行内存回收.</p><p>另外需要注意的一个点是, 对于一个 Dom 树的叶子节点的引用. 举个例子: 如果我们引用了一个表格中的 td 元素, 一旦在 Dom 中删除了整个表格, 我们直观的觉得内存回收应该回收除了被引用的 td 外的其他元素. 但是事实上, 这个 td 元素是整个表格的一个子元素, 并保留对于其父元素的引用. 这就会导致对于整个表格, 都无法进行内存回收. 所以我们要小心处理对于 Dom 元素的引用.</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>ES6 中引入 <code>WeakSet</code> 和 <code>WeakMap</code> 两个新的概念, 来解决引用造成的内存回收问题. <code>WeakSet</code> 和 <code>WeakMap</code> 对于值的引用可以忽略不计, 他们对于值的引用是弱引用,内存回收机制, 不会考虑这种引用. 当其他引用被消除后, 引用就会从内存中被释放.</p><p>JS 这类高级语言，隐藏了内存管理功能。但无论开发人员是否注意，内存管理都在那，所有编程语言最终要与操作系统打交道，在内存大小固定的硬件上工作。不幸的是，即使不考虑垃圾回收对性能的影响，2017 年最新的垃圾回收算法，也无法智能回收所有极端的情况。</p><p>唯有程序员自己才知道何时进行垃圾回收，而 JS 由于没有暴露显示内存管理接口，导致触发垃圾回收的代码看起来像“垃圾”，或者优化垃圾回收的代码段看起来不优雅、甚至不可读。</p><p>所以在 JS 这类高级语言中，有必要掌握基础内存分配原理，在对内存敏感的场景，比如 nodejs 代码做严格检查与优化。谨慎使用 dom 操作、主动删除没有业务意义的变量、避免提前优化、过度优化，在保证代码可读性的前提下，利用性能监控工具，通过调用栈定位问题代码。</p><p>即便在 JS 中, 我们很少去直接去做内存管理. 但是我们在写代码的时候, 也要有内存管理的意识, 谨慎的处理可能会造成内存泄露的场景.</p><p>同时对于如何利用 chrome 调试工具, 分析内存泄露的方法和技巧.</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;像 C 语言这样的高级语言一般都有底层的内存管理接口,比如 malloc()和 free().另一方面,JavaScript 创建变量（对象,字符串等）时分配内存,并且在不再使用它们时“自动”释放. 后一个过程称为垃圾回收.这个“自动”是混乱的根源,并让 JavaScript（和其他高级语言）开发者感觉他们可以不关心内存管理. 这是错误的,所以可以通过平时多了解一些 JS 中内存管理问题, 在写代码中通过一些习惯, 避免内存泄露的问题.&lt;/p&gt;
&lt;h2 id=&quot;内存生命周期&quot;&gt;&lt;a href=&quot;#内存生命周期&quot; class=&quot;headerlink&quot; title=&quot;内存生命周期&quot;&gt;&lt;/a&gt;内存生命周期&lt;/h2&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://csjiabin.github.io/categories/JavaScript/"/>
    
    
      <category term="js" scheme="https://csjiabin.github.io/tags/js/"/>
    
      <category term="内存管理" scheme="https://csjiabin.github.io/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
      <category term="垃圾回收" scheme="https://csjiabin.github.io/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    
  </entry>
  
  <entry>
    <title>ES6的Set和Map,以及WeakSet和WeakMap</title>
    <link href="https://csjiabin.github.io/2018/11/18/ES6%E7%9A%84Set%E5%92%8CMap-%E4%BB%A5%E5%8F%8AWeakSet%E5%92%8CWeakMap/"/>
    <id>https://csjiabin.github.io/2018/11/18/ES6%E7%9A%84Set%E5%92%8CMap-%E4%BB%A5%E5%8F%8AWeakSet%E5%92%8CWeakMap/</id>
    <published>2018-11-18T03:43:39.000Z</published>
    <updated>2020-11-02T09:26:56.672Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Set"><a href="#一、Set" class="headerlink" title="一、Set"></a>一、Set</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>ES6 提供了新的数据结构 Set，它类似数组，但是成员的值都是唯一的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>].forEach(<span class="function"><span class="params">x</span> =&gt;</span> s.add(x));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> s) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i); <span class="comment">// 2，3，5，4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码，通过 add 方法向 Set 结构假如成员，输出为：2，3，5，4<br>Set 函数可以接受一个数组（或类似数组的对象）作为参数，用来初始化</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例一</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">set</span> = new Set([1, 2, 3, 4, 4]);</span><br><span class="line">console.log([...<span class="keyword">set</span>]);</span><br><span class="line">// [1, 2, 3, 4]</span><br><span class="line"></span><br><span class="line">// 例二</span><br><span class="line">const items = new Set([1, 2, 3, 4, 5, 5, 5, 5]);</span><br><span class="line">console.log(items.size); // 5</span><br><span class="line"></span><br><span class="line">// 例三</span><br><span class="line">function divs() &#123;</span><br><span class="line">  <span class="keyword">return</span> [...document.querySelectorAll(<span class="string">"div"</span>)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">set</span> = new Set(divs());</span><br><span class="line">console.log(<span class="keyword">set</span>.size); // 127</span><br><span class="line"></span><br><span class="line">// 类似于</span><br><span class="line">divs().forEach(div =&gt; <span class="keyword">set</span>.add(div));</span><br><span class="line">console.log(<span class="keyword">set</span>.size); // 127</span><br></pre></td></tr></table></figure><p>上面代码，例一和二都是数组作为参数，例三是接受类似数组的对象作为参数。<br>去除数组重复成员的方法:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[...new <span class="built_in">Set</span>(array)];</span><br></pre></td></tr></table></figure><p>向 set 里加入值的时候，不会发生类型转化，所以 5 和“5”是两个不同的值，Set 内部判断两个值是否不同，使用的算法叫做“Same-value equality” 类似于精确相等运算符(===)，而区别是，NaN 等于自身，而精确相等运算符认为 NaN 不等于自身。此外两个对象总是不相等。</p><h3 id="Set-实例的属性和方法"><a href="#Set-实例的属性和方法" class="headerlink" title="Set 实例的属性和方法"></a>Set 实例的属性和方法</h3><p>Set 结构的实例有以下属性:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Set</span>.prototype.constructor; <span class="comment">// 构造函数，默认就是 Set 函数。</span></span><br><span class="line"><span class="built_in">Set</span>.prototype.size; <span class="comment">// 返回 Set 实例的成员总数。</span></span><br></pre></td></tr></table></figure><p><strong>Set 实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。下面先介绍四个操作方法。</strong></p><blockquote><p>add(value)：添加某个值，返回 Set 结构本身。<br>delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。<br>has(value)：返回一个布尔值，表示该值是否为 Set 的成员。<br>clear()：清除所有成员，没有返回值。</p></blockquote><p>下面是一个对比，判断是否包括在一个键上面，Object 结构和 Set 结构的写法不同。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对象的写法s</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  width: <span class="number">1</span>,</span><br><span class="line">  height: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (obj[someName]) &#123;</span><br><span class="line">  <span class="comment">//....</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set的写法</span></span><br><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">obj.add(<span class="string">"width"</span>);</span><br><span class="line">obj.add(<span class="string">"height"</span>);</span><br><span class="line"><span class="keyword">if</span> (obj.has(someName)) &#123;</span><br><span class="line">  <span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Array.from 方法可以将 Set 结构转为数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> items = <span class="keyword">new</span> <span class="built_in">Set</span>（[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]）;</span><br><span class="line"><span class="keyword">const</span> array = <span class="built_in">Array</span>.from(items);</span><br></pre></td></tr></table></figure><p>这也就提供了去除数组重复成员的另一种方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dedupe</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(array));</span><br><span class="line">&#125;</span><br><span class="line">dedupe([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]); <span class="comment">//[1,2,3]</span></span><br></pre></td></tr></table></figure><h3 id="遍历操作"><a href="#遍历操作" class="headerlink" title="遍历操作"></a>遍历操作</h3><p>Set 结构的实例有四个遍历方法，可以用于遍历成员。<br><strong>Set 的遍历顺序就是插入顺序</strong></p><blockquote><p>.keys()：返回键名的遍历器<br>.values()：返回键值的遍历器<br>.entries()：返回键值对的遍历器<br>.forEach()：使用回调函数遍历每个成员</p></blockquote><p><strong>遍历</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set(["red", "green", "blue"]);</span><br><span class="line">for (let x of <span class="keyword">set</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//red //green //blue</span></span><br></pre></td></tr></table></figure><p><code>forEach()</code>方法，用于对每个成员执行某种操作，没有返回值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set([1, 2, 3]);</span><br><span class="line"><span class="keyword">set</span>.forEach((value, key) =&gt; console.log(value * 2)); // 2 // 4 // 6</span><br></pre></td></tr></table></figure><p><strong>遍历的应用</strong><br>扩展运算符(…)内部使用 <code>for...of</code>循环，所以也可以用于<code>Set</code>结构</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set(["red", "green", "blue"]);</span><br><span class="line">let arr = [...<span class="keyword">set</span>]; // ['red', 'green', 'blue']</span><br></pre></td></tr></table></figure><p>扩展运算符和 Set 结构相结合，就可以去除数组的重复成员。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> unique = [...new <span class="built_in">Set</span>(arr)]; <span class="comment">// [3, 5, 2]</span></span><br></pre></td></tr></table></figure><p>而且数组的<code>map</code>和<code>filter</code> 方法也可以用于 Set 了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set([1, 2, 3]);</span><br><span class="line"><span class="keyword">set</span> = new Set([...<span class="keyword">set</span>].map(x =&gt; x * 2)); // 返回Set结构：&#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set([1, 2, 3, 4, 5]);</span><br><span class="line"><span class="keyword">set</span> = new Set([...<span class="keyword">set</span>].filter(x =&gt; x % 2 == 0)); // 返回Set结构：&#123;<span class="number">2</span>, <span class="number">4</span>&#125;</span><br></pre></td></tr></table></figure><p>综上 Set 可以很容易地实现并集(Union)、交集(Intersect)和差集（Difference）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并集</span></span><br><span class="line"><span class="keyword">let</span> union = <span class="keyword">new</span> <span class="built_in">Set</span>([...a, ...b]); <span class="comment">// Set &#123;1, 2, 3, 4&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 交集</span></span><br><span class="line"><span class="keyword">let</span> intersect = <span class="keyword">new</span> <span class="built_in">Set</span>([...a].filter(<span class="function"><span class="params">x</span> =&gt;</span> b.has(x))); <span class="comment">// set &#123;2, 3&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 差集</span></span><br><span class="line"><span class="keyword">let</span> difference = <span class="keyword">new</span> <span class="built_in">Set</span>([...a].filter(<span class="function"><span class="params">x</span> =&gt;</span> !b.has(x))); <span class="comment">// Set &#123;1&#125;</span></span><br></pre></td></tr></table></figure><p>如果像在遍历操作中，同步改变原来的 Set 结构，目前没有直接的方法，但是有两种变通方法。一种是利用原 Set 结构映射出一个新的结构，然后赋值给原来的 Set 结构；另一种是利用 Array.from 方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set([1, 2, 3]);</span><br><span class="line"><span class="keyword">set</span> = new Set([...<span class="keyword">set</span>].map(val =&gt; val * 2)); // <span class="keyword">set</span>的值是2, 4, 6</span><br><span class="line"></span><br><span class="line">// 方法二</span><br><span class="line">let <span class="keyword">set</span> = new Set([1, 2, 3]);</span><br><span class="line"><span class="keyword">set</span> = new Set(Array.from(<span class="keyword">set</span>, val =&gt; val * 2)); // <span class="keyword">set</span>的值是2, 4, 6</span><br></pre></td></tr></table></figure><h2 id="二、WeakSet"><a href="#二、WeakSet" class="headerlink" title="二、WeakSet"></a>二、WeakSet</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>WeakSet 结构与 Set 类似，也是不重复的值的集合，但是，它与 Set 有两个区别。首先，WeakSet 的成员只能是对象，而不能是其他类型的值，其次，WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用<br>** 垃圾回收机制依赖引用技术 **<br>WeakSet 是一个构造函数，可以使用 new 命令，创建 WeakSet 数据结构: <code>const set = new WeakSet()</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]];</span><br><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> <span class="built_in">WeakSet</span>(a); <span class="comment">// 正确</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> b = [<span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> <span class="built_in">WeakSet</span>(b); <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure><p><strong>WeakSet 结构有以下三个方法:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">WeakSet</span>.prototype.add(value); <span class="comment">// 向 WeakSet 实例添加一个新成员。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">WeakSet</span>.prototype.delete(value); <span class="comment">// 清除 WeakSet 实例的指定成员。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">WeakSet</span>.prototype.has(value); <span class="comment">// 返回一个布尔值，表示某个值是否在</span></span><br></pre></td></tr></table></figure><p>WeakSet 没有 size 属性，没有办法遍历它的成员。因此 forEach 的方法也用不了。</p><blockquote><p>WeakSet 的一个用处，是储存 DOM 节点，而不用担心这些节点从文档移除时，会引发内存泄漏。</p></blockquote><p>WeakSet 例子:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foos = <span class="keyword">new</span> <span class="built_in">WeakSet</span>();</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    foos.add(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  method() &#123;</span><br><span class="line">    <span class="keyword">if</span> (!foos.has(<span class="keyword">this</span>)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"Foo.prototype.method 只能在Foo的实例上调用"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码保证了 Foo 的实例方法，只能在 Foo 的实例上调用。这里使用 WeakSet 的好处是，foos 对实例的引用，不会被记入内存回收机制，所以删除实例的时候，不用考虑 foos，也不会出现内存泄露。</p><h2 id="三、Map"><a href="#三、Map" class="headerlink" title="三、Map"></a>三、Map</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><p>Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>map 在增加成员的时候，用 set 例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">m.set(<span class="number">0</span>, <span class="string">"content"</span>);</span><br><span class="line">m.get(<span class="number">0</span>);</span><br><span class="line">m.delete(<span class="number">0</span>);</span><br><span class="line">m.has(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p><strong>map 同样接受一个数组作为参数</strong>,该数组的成员是一个个表示键值对的数组。<br>事实上，不仅仅是数组，任何具有 Iterator 接口的数据结构都可以当做 Map 构造函数的参数，这就是说，Set 和 Map 都可以用来生成新的 Map。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">set</span> = new Set([["foo", 1], ["bar", 2]]);</span><br><span class="line">const m1 = new Map(<span class="keyword">set</span>);</span><br><span class="line">m1.<span class="keyword">get</span>("foo"); // 1</span><br></pre></td></tr></table></figure><p>上面代码中，我们分别使用 Set 对象和 Map 对象，当作 Map 构造函数的参数，结果都生成了新的 Map 对象</p><h3 id="实例的属性和操作方法"><a href="#实例的属性和操作方法" class="headerlink" title="实例的属性和操作方法"></a>实例的属性和操作方法</h3><p><strong>Map 结构的实例有一下属性和操作方法</strong></p><blockquote><p>size<br>set(key,value)<br>get(key),<br>has(key)<br>delete(key)<br>clear()</p></blockquote><p><strong>遍历方法(Map 的遍历顺序就是插入的顺序)</strong><br>Map 结构提供三个遍历起生成函数和一个遍历方法。</p><blockquote><p>keys()：返回键名的遍历器。<br>values()：返回键值的遍历器。<br>entries()：返回所有成员的遍历器。<br>forEach()：遍历 Map 的所有成员。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> map.keys()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> map.entries()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item[<span class="number">0</span>], item[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Map-结构转为数组结构，比较快速的方法是使用扩展运算符"><a href="#Map-结构转为数组结构，比较快速的方法是使用扩展运算符" class="headerlink" title="Map 结构转为数组结构，比较快速的方法是使用扩展运算符(...)"></a>Map 结构转为数组结构，比较快速的方法是使用扩展运算符<code>(...)</code></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([ [<span class="number">1</span>, <span class="string">'one'</span>], [<span class="number">2</span>, <span class="string">'two'</span>], [<span class="number">3</span>, <span class="string">'three'</span>], ]);</span><br><span class="line"></span><br><span class="line">[...map.keys()]</span><br><span class="line">[...map.values()]</span><br><span class="line">[...map.entries()]</span><br><span class="line">[...map]</span><br></pre></td></tr></table></figure><p>结合数组的 map 方法、filter 方法，可以实现 Map 的遍历和过滤(Map 本身没有 map 和 filter 方法)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map0 = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">  .set(<span class="number">1</span>, <span class="string">"a"</span>)</span><br><span class="line">  .set(<span class="number">2</span>, <span class="string">"b"</span>)</span><br><span class="line">  .set(<span class="number">3</span>, <span class="string">"c"</span>);</span><br><span class="line"><span class="keyword">const</span> map1 = <span class="keyword">new</span> <span class="built_in">Map</span>([...map0].filter(<span class="function">(<span class="params">[k, v]</span>) =&gt;</span> k &lt; <span class="number">3</span>));</span><br><span class="line"><span class="comment">// 产生 Map 结构 &#123;1 =&gt; 'a', 2 =&gt; 'b'&#125;</span></span><br><span class="line"><span class="keyword">const</span> map2 = <span class="keyword">new</span> <span class="built_in">Map</span>([...map0].map(<span class="function">(<span class="params">[k, v]</span>) =&gt;</span> [k * <span class="number">2</span>, <span class="string">"_"</span> + v])); <span class="comment">// 产生 Map 结构 &#123;2 =&gt; '_a', 4 =&gt; '_b', 6 =&gt; '_c'&#125;</span></span><br></pre></td></tr></table></figure><h3 id="与其他数据结构的互相转换"><a href="#与其他数据结构的互相转换" class="headerlink" title="与其他数据结构的互相转换"></a>与其他数据结构的互相转换</h3><h4 id="Map-转为数组"><a href="#Map-转为数组" class="headerlink" title="Map 转为数组"></a>Map 转为数组</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用扩展运算符，|| <span class="built_in">Array</span>.form</span><br></pre></td></tr></table></figure><h4 id="数组-转为-Map"><a href="#数组-转为-Map" class="headerlink" title="数组 转为 Map"></a>数组 转为 Map</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将数组传入Map构造函数，就可以转为Map</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="literal">true</span>, <span class="number">7</span>], [&#123; <span class="attr">foo</span>: <span class="number">3</span> &#125;, [<span class="string">"abc"</span>]]]);</span><br></pre></td></tr></table></figure><h4 id="Map-转为对象"><a href="#Map-转为对象" class="headerlink" title="Map 转为对象"></a>Map 转为对象</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">strMapToObj</span>(<span class="params">strMap</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> obj = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> [k, v] <span class="keyword">of</span> strMap) &#123;</span><br><span class="line">    obj[k] = v;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> myMap = <span class="keyword">new</span> <span class="built_in">Map</span>().set(<span class="string">"yes"</span>, <span class="literal">true</span>).set(<span class="string">"no"</span>, <span class="literal">false</span>);</span><br><span class="line">strMapToObj(myMap);</span><br></pre></td></tr></table></figure><h4 id="对象转为-Map"><a href="#对象转为-Map" class="headerlink" title="对象转为 Map"></a>对象转为 Map</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">objToStrMap</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> strMap = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> k <span class="keyword">of</span> <span class="built_in">Object</span>.keys(obj)) &#123;</span><br><span class="line">    strMap.set(k, obj[k]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> strMap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">objToStrMap(&#123; <span class="attr">yes</span>: <span class="literal">true</span>, <span class="attr">no</span>: <span class="literal">false</span> &#125;);</span><br></pre></td></tr></table></figure><h4 id="Map-转为-JSON"><a href="#Map-转为-JSON" class="headerlink" title="Map 转为 JSON"></a>Map 转为 JSON</h4><p>Map 转为 JSON 要区分两种情况。一种情况是，Map 的键名都是字符串，这时可以选择转为对象 JSON。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">strMapToJson</span>(<span class="params">strMap</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">JSON</span>.stringify(strMapToObj(strMap));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myMap = <span class="keyword">new</span> <span class="built_in">Map</span>().set(<span class="string">"yes"</span>, <span class="literal">true</span>).set(<span class="string">"no"</span>, <span class="literal">false</span>);</span><br><span class="line">strMapToJson(myMap);</span><br><span class="line"><span class="comment">// '&#123;"yes":true,"no":false&#125;'</span></span><br></pre></td></tr></table></figure><p>另一种情况是，Map 的键名有非字符串，这时可以选择转为数组 JSON。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapToArrayJson</span>(<span class="params">map</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">JSON</span>.stringify([...map]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myMap = <span class="keyword">new</span> <span class="built_in">Map</span>().set(<span class="literal">true</span>, <span class="number">7</span>).set(&#123; <span class="attr">foo</span>: <span class="number">3</span> &#125;, [<span class="string">"abc"</span>]);</span><br><span class="line">mapToArrayJson(myMap);</span><br><span class="line"><span class="comment">// '[[true,7],[&#123;"foo":3&#125;,["abc"]]]'</span></span><br></pre></td></tr></table></figure><h4 id="JSON-转为-Map"><a href="#JSON-转为-Map" class="headerlink" title="JSON 转为 Map"></a>JSON 转为 Map</h4><p>JSON 转为 Map，正常情况下，所有键名都是字符串。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsonToStrMap</span>(<span class="params">jsonStr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> objToStrMap(<span class="built_in">JSON</span>.parse(jsonStr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jsonToStrMap(<span class="string">'&#123;"yes": true, "no": false&#125;'</span>);</span><br><span class="line"><span class="comment">// Map &#123;'yes' =&gt; true, 'no' =&gt; false&#125;</span></span><br></pre></td></tr></table></figure><p>但是，有一种特殊情况，整个 JSON 就是一个数组，且每个数组成员本身，又是一个有两个成员的数组。这时，它可以一一对应地转为 Map。这往往是数组转为 JSON 的逆操作。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsonToMap</span>(<span class="params">jsonStr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Map</span>(<span class="built_in">JSON</span>.parse(jsonStr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jsonToMap(<span class="string">'[[true,7],[&#123;"foo":3&#125;,["abc"]]]'</span>);</span><br><span class="line"><span class="comment">// Map(2) &#123;true =&gt; 7, &#123;…&#125; =&gt; Array(1)&#125;</span></span><br></pre></td></tr></table></figure><h2 id="四、WeakMap"><a href="#四、WeakMap" class="headerlink" title="四、WeakMap"></a>四、WeakMap</h2><h3 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h3><p>WeakMap 结构与 Map 结构类似，也是用于生成键值对的。</p><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>首先，WeakMap 只接受对象作为键名（null 除外），不接受其他类型的值作为键名<br>其次，WeakMap 的键名所指向的对象，不计入垃圾回收机制</p><h3 id="WeakMap-语法"><a href="#WeakMap-语法" class="headerlink" title="WeakMap 语法"></a>WeakMap 语法</h3><p>WeakMap 与 Map 在 API 上的区别主要是两个，一是没有遍历操作（即没有 key()、values()和 entries()方法），也没有 size 属性。因为没有办法列出所有键名，这个键名是否存在完全不可预测，跟垃圾回收机制是否运行相关。二是无法清空，即不支持 clear 方法。因此，<strong>WeakMap 只有四个方法可用：get()、set()、has()、delete()</strong>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、Set&quot;&gt;&lt;a href=&quot;#一、Set&quot; class=&quot;headerlink&quot; title=&quot;一、Set&quot;&gt;&lt;/a&gt;一、Set&lt;/h2&gt;&lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;p&gt;ES6 提供了新的数据结构 Set，它类似数组，但是成员的值都是唯一的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://csjiabin.github.io/categories/JavaScript/"/>
    
    
      <category term="es6" scheme="https://csjiabin.github.io/tags/es6/"/>
    
      <category term="js" scheme="https://csjiabin.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 易错知识点整理</title>
    <link href="https://csjiabin.github.io/2018/10/18/JavaScript%E6%98%93%E9%94%99%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/"/>
    <id>https://csjiabin.github.io/2018/10/18/JavaScript%E6%98%93%E9%94%99%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/</id>
    <published>2018-10-18T04:16:07.000Z</published>
    <updated>2020-11-02T09:26:56.673Z</updated>
    
    <content type="html"><![CDATA[<h3 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line">test();</span><br></pre></td></tr></table></figure><p>上面的 test 函数作用域中声明并赋值了 a，且在 console 之上，所以遵循就近原则输出 a 等于 2。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">// undefined</span></span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">test2();</span><br></pre></td></tr></table></figure><p>上方的函数作用域中虽然声明并赋值了 a，但位于 console 之下，a 变量被提升，输出时已声明但尚未被赋值，所以输出 undefined。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test3</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br><span class="line">  a = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">test3();</span><br></pre></td></tr></table></figure><p>上方的函数作用域中 a 被重新赋值，未被重新声明，且位于 console 之下，所以输出全局作用域中的 a。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> b = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test4</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(b); <span class="comment">// b is not undefined</span></span><br><span class="line">  <span class="keyword">let</span> b = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">test4();</span><br></pre></td></tr></table></figure><p>上方的函数作用域中使用了 ES6 的 let 重新声明了变量 b，而 let 不同于 var 其不存在变量提升的功能，所以输出报错<code>b is not undefined</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test5</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br><span class="line">test5();</span><br></pre></td></tr></table></figure><p>上方的函数作用域中用 let 声明了 a 为 1，并在块级作用域中声明了 a 为 2，因为 console 并不在函数内的块级作用域中，所以输出 1。</p><h3 id="类型比较"><a href="#类型比较" class="headerlink" title="类型比较"></a>类型比较</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [],</span><br><span class="line">  arr2 = [<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr === arr2); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>上方两个不同的数组比较，console 为 false。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [],</span><br><span class="line">  arr2 = [];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr === arr2); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>上方两个相同的数组比较，因为两个单独的数组永不相等，所以 console 为 false。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [],</span><br><span class="line">  obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> arr === <span class="keyword">typeof</span> obj); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上方利用 typeof 比较数组和对象，因为 typeof 获取<code>null</code>、<code>数组</code>、<code>对象</code>的类型都为<code>object</code>，所以 console 为 true。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line"><span class="built_in">console</span>.log(arr <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(arr <span class="keyword">instanceof</span> <span class="built_in">Array</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上方利用 instanceof 判断一个变量是否属于某个对象的实例，因为在 JavaScript 中数组也是对象的一种，所以两个 console 都为 true。</p><h3 id="this-指向"><a href="#this-指向" class="headerlink" title="this 指向"></a>this 指向</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">"xiaoming"</span>,</span><br><span class="line">  getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj.getName()); <span class="comment">// xiaoming</span></span><br></pre></td></tr></table></figure><p>上方对象方法中的 this 指向对象本身，所以输出 xiaoming</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">"xiaoming"</span>,</span><br><span class="line">  getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> nameFn = obj.getName;</span><br><span class="line"><span class="built_in">console</span>.log(nameFn()); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>上方将对象中的方法赋值给了一个变量，此时方法中的 this 也将不再指向 obj 对象，从而指向 window 对象，所以 console 为 undefined。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">"xiaoming"</span>,</span><br><span class="line">  getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">  name: <span class="string">"xiaohua"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> nameFn = obj.getName;</span><br><span class="line"><span class="built_in">console</span>.log(nameFn.apply(obj2)); <span class="comment">// xiaohua</span></span><br></pre></td></tr></table></figure><p>上方同样将 obj 对象中的方法赋值给了变量 nameFn，但是通过 apply 方法将 this 指向了 obj2 对象，所以最终 console 为 xiaohua。</p><h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test6</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)); <span class="comment">// [1,2]</span></span><br><span class="line">&#125;</span><br><span class="line">test6(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>上方利用函数中的 arguments 类数组对象获取传入函数的参数数组，所以输出数组[1, 2]。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test7</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)); <span class="comment">// 未执行到此，无输出</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">test7(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>上方同样利用 arguments 获取参数，但因 test7(1, 2)未执行 return 中的函数，所以无输出。若执行 test7(1, 2)(3, 4)则会输出[3, 4]。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> args = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test8</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)); <span class="comment">// [1,2,3,4]</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Array</span>.prototype.push.call(args,<span class="number">3</span>, <span class="number">4</span>));</span><br><span class="line">test8(...args);</span><br></pre></td></tr></table></figure><p>上方利用 Array.prototype.push.call()方法向 args 数组中插入了 3 和 4，并利用 ES6 延展操作符(…)将数组展开并传入 test9，所以 console 为[1, 2, 3, 4]。</p><h3 id="闭包问题"><a href="#闭包问题" class="headerlink" title="闭包问题"></a>闭包问题</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> elem = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"div"</span>); <span class="comment">// 如果页面上有5个div</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; elem.length; i++) &#123;</span><br><span class="line">  elem[i].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(i); <span class="comment">//总是5</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上方是一个很常见闭包问题，点击任何 div 弹出的值总是 5，因为当你触发点击事件的时候 i 的值早已是 5，可以用下面方式解决：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> elem = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"div"</span>); <span class="comment">// 如果页面上有5个div</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; elem.length; i++) &#123;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params">j</span>) </span>&#123;</span><br><span class="line">    elem[j].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      alert(j); <span class="comment">// 依次为 0，1，2，3，4</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;)(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在绑定点击事件外部封装一个立即执行函数，并将 i 传入该函数即可。</p><h3 id="对象拷贝与赋值"><a href="#对象拷贝与赋值" class="headerlink" title="对象拷贝与赋值"></a>对象拷贝与赋值</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">"xiaoming"</span>,</span><br><span class="line">  age: <span class="number">23</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> newObj = obj;</span><br><span class="line">newObj.name = <span class="string">"xiaohua"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj.name); <span class="comment">// xiaohua</span></span><br><span class="line"><span class="built_in">console</span>.log(newObj.name); <span class="comment">// xiaohua</span></span><br></pre></td></tr></table></figure><p>上方我们将 obj 对象赋值给了 newObj 对象，从而改变 newObj 的 name 属性，但是 obj 对象的 name 属性也被篡改，这是因为实际上 newObj 对象获得的只是一个内存地址，而不是真正的拷贝，所以 obj 对象被篡改。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">  name: <span class="string">"xiaoming"</span>,</span><br><span class="line">  age: <span class="number">23</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> newObj2 = <span class="built_in">Object</span>.assign(&#123;&#125;, obj2, &#123; <span class="attr">color</span>: <span class="string">"blue"</span> &#125;);</span><br><span class="line">newObj2.name = <span class="string">"xiaohua"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj2.name); <span class="comment">// xiaoming</span></span><br><span class="line"><span class="built_in">console</span>.log(newObj2.name); <span class="comment">// xiaohua</span></span><br><span class="line"><span class="built_in">console</span>.log(newObj2.color); <span class="comment">// blue</span></span><br></pre></td></tr></table></figure><p>上方利用 Object.assign()方法进行对象的深拷贝可以避免源对象被篡改的可能。因为 Object.assign() 方法可以把任意多个的源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj3 = &#123;</span><br><span class="line">  name: <span class="string">"xiaoming"</span>,</span><br><span class="line">  age: <span class="number">23</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> newObj3 = <span class="built_in">Object</span>.create(obj3);</span><br><span class="line">newObj3.name = <span class="string">"xiaohua"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj3.name); <span class="comment">// xiaoming</span></span><br><span class="line"><span class="built_in">console</span>.log(newObj3.name); <span class="comment">// xiaohua</span></span><br></pre></td></tr></table></figure><p>我们也可以使用 Object.create()方法进行对象的拷贝，Object.create()方法可以创建一个具有指定原型对象和属性的新对象。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;变量作用域&quot;&gt;&lt;a href=&quot;#变量作用域&quot; class=&quot;headerlink&quot; title=&quot;变量作用域&quot;&gt;&lt;/a&gt;变量作用域&lt;/h3&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; a = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;test&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; a = &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(a); &lt;span class=&quot;comment&quot;&gt;// 2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;test();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;上面的 test 函数作用域中声明并赋值了 a，且在 console 之上，所以遵循就近原则输出 a 等于 2。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://csjiabin.github.io/categories/JavaScript/"/>
    
    
      <category term="js" scheme="https://csjiabin.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>Mathjax与KaTex渲染数学公式</title>
    <link href="https://csjiabin.github.io/2018/09/16/Mathjax%E4%B8%8EKaTex%E6%B8%B2%E6%9F%93%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/"/>
    <id>https://csjiabin.github.io/2018/09/16/Mathjax%E4%B8%8EKaTex%E6%B8%B2%E6%9F%93%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/</id>
    <published>2018-09-16T12:39:09.000Z</published>
    <updated>2020-11-02T09:26:56.674Z</updated>
    
    <content type="html"><![CDATA[<p>我们经常会用 Office Word 在文档中插入数学公式，有没有想过，如何在你的网页上渲染数学公式呢？让我们走进数学，欣赏一下公式渲染的美妙之处。</p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>我们先来看看都有哪些场景应用到了数学公式，有个整体的印象。此外，可以扩展技术面，让你可以在做技术选型的时候游刃有余：</p><p><strong>大数据分析</strong><br>当你要做一些大数据分析的时候，可能会用到很多的算法公式。如何让读者更好的理解内容，你可能需要用到公式渲染。</p><p><strong>在线教育的数学试卷渲染</strong><br>毋庸置疑，数学包含了很多公式，很难想象一张试卷没有包含任何数学公式。</p><p><strong>富文本编辑器</strong><br>这个可能是最多的场景，甚至你一直在用，却未曾感知。例如：Word 中插入公式，CKeditor 中的公式组件。</p><p><strong>学术论文</strong><br>如果你是一个严谨的学者，肯定不会在自己论文中粘贴图片的公式，你可能需要用到公式渲染。</p><p><strong>印刷出版</strong><br>刊物印刷出版，数学公式必不可少，没有人可以忍受印在书上的图片公式。因为它可能会失真。</p><h3 id="多种选择"><a href="#多种选择" class="headerlink" title="多种选择"></a>多种选择</h3><p>这里主要介绍两个<code>JS</code>数学公式渲染的类库：</p><ol><li><a href="https://www.mathjax.org/" target="_blank" rel="noopener">Mathjax</a>: A JavaScript display engine for mathematics that works in all browsers. No more setup for readers. It just works.</li><li><a href="https://khan.github.io/KaTeX/" target="_blank" rel="noopener">KaTex</a>: The fastest math typesetting library for the web.</li></ol><h4 id="Mathjax-示例"><a href="#Mathjax-示例" class="headerlink" title="Mathjax 示例"></a>Mathjax 示例</h4><p>先来看看 <code>Mathjax</code> 的例子，使用方式非常简单，我们引入类库文件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML'</span> <span class="attr">async</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>一个简单的例子可能如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Jartto's MathJax Demo <span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">async</span></span></span><br><span class="line"><span class="tag">  <span class="attr">src</span>=<span class="string">"https://example.com/mathjax/MathJax.js?config=AM_CHTML"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>When `a != 0`, there are two solutions to `ax^2 + bx + c = 0` and</span><br><span class="line">they are<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">"text-align:center"</span>&gt;</span></span><br><span class="line">  `x = (-b +- sqrt(b^2-4ac))/(2a) .`</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>再比如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">When $a \ne 0$, there are two solutions to \(ax^2 + bx + c = 0\) and they are</span><br><span class="line">$$x = &#123;-b \pm \sqrt&#123;b^2-4ac&#125; \over 2a&#125;.$$</span><br></pre></td></tr></table></figure><p>渲染后的结果如下：<br>When $a \ne 0$, there are two solutions to (ax^2 + bx + c = 0) and they are<br>$$x = {-b \pm \sqrt{b^2-4ac} \over 2a}.$$<br>我们可以把表达式放到引号里，如下</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`ax^2 + bx + c = 0`</span><br></pre></td></tr></table></figure><p>或者 <code>$</code> 中</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ax^2 + bx + c = 0$</span><br></pre></td></tr></table></figure><p>使用很简单，详情可以看看<a href="https://docs.mathjax.org/en/latest/mathjax.html" target="_blank" rel="noopener">文档</a>。</p><h4 id="KaTex-示例"><a href="#KaTex-示例" class="headerlink" title="KaTex 示例"></a>KaTex 示例</h4><p>看完 <code>Mathjax</code> 之后，我们再来了解一下 <code>KaTex</code>:</p><p><strong>1.安装</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># npm</span></span><br><span class="line">npm install katex</span><br><span class="line">npm install -g katex</span><br><span class="line"><span class="comment"># yarn</span></span><br><span class="line">yarn add katex</span><br><span class="line">yarn global add katex</span><br><span class="line"><span class="comment"># Browser</span></span><br><span class="line">&lt;link rel=<span class="string">"stylesheet"</span> href=<span class="string">"https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.css"</span> integrity=<span class="string">"sha384-JwmmMju6Z7M9jiY4RXeJLoNb3aown2QCC/cI7JPgmOLsn3n33pdwAj0Ml/CMMd1W"</span> crossorigin=<span class="string">"anonymous"</span>&gt;</span><br><span class="line">&lt;script defer src=<span class="string">"https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.js"</span> integrity=<span class="string">"sha384-atIluo+2Hixq8HCazSQWa1JjeC5L0CQeWAx74Q+EbqgAW4UixbrBQF4+1jvBX01b"</span> crossorigin=<span class="string">"anonymous"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><blockquote><p>KaTex 支持大部分的浏览器：Chrome, Safari, Firefox, Opera, Edge, and IE 9–11</p></blockquote><p><strong>2.使用 Dom 渲染 TeX 表达式</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">katex.render(<span class="string">"c = \\pm\\sqrt&#123;a^2 + b^2&#125;"</span>, element, &#123;</span><br><span class="line">  throwOnError: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>3.反斜线需要特殊处理</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">katex.render(<span class="built_in">String</span>.raw<span class="string">`c = \pm\sqrt&#123;a^2 + b^2&#125;`</span>, element, &#123;</span><br><span class="line">  throwOnError: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>4.服务端渲染</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> html = katex.renderToString(<span class="string">"c = \\pm\\sqrt&#123;a^2 + b^2&#125;"</span>, &#123;</span><br><span class="line">  throwOnError: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// '&lt;span class="katex"&gt;...&lt;/span&gt;'</span></span><br></pre></td></tr></table></figure><p><strong>5.处理自动渲染</strong></p><ul><li>首先加载 js 和 css</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.css"</span> <span class="attr">integrity</span>=<span class="string">"sha384-D+9gmBxUQogRLqvARvNLmA9hS2x//eK1FhVb9PiU86gmcrBrJAQT8okdJ4LMp2uv"</span> <span class="attr">crossorigin</span>=<span class="string">"anonymous"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.js"</span> <span class="attr">integrity</span>=<span class="string">"sha384-483A6DwYfKeDa0Q52fJmxFXkcPCFfnXMoXblOkJ4JcA8zATN6Tm78UNL72AKk+0O"</span> <span class="attr">crossorigin</span>=<span class="string">"anonymous"</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>额外引入</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/contrib/auto-render.min.js"</span> <span class="attr">integrity</span>=<span class="string">"sha384-yACMu8JWxKzSp/C1YV86pzGiQ/l1YUfE8oPuahJQxzehAjEt2GiQuy/BIvl9KyeF"</span> <span class="attr">crossorigin</span>=<span class="string">"anonymous"</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>使用方式</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.addEventListener(<span class="string">"DOMContentLoaded"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        renderMathInElement(<span class="built_in">document</span>.body, &#123;</span></span><br><span class="line"><span class="actionscript">            <span class="comment">// jartto's demo</span></span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>当然，我们也可以这么使用：window.renderMathInElement(elem, options);</p></blockquote><p><strong>6.可用参数</strong></p><blockquote><p>KaTex 能支持很多的场景，缘于它可以灵活的配置。</p></blockquote><ul><li>displayMode</li><li>throwOnError</li><li>errorColor</li><li>macros</li><li>colorIsTextColor</li><li>maxSize</li><li>maxExpand</li><li>allowedProtocols</li><li>strict</li></ul><p>参数定义可以看<a href="https://katex.org/docs/options.html" target="_blank" rel="noopener">这里</a>，我们可以根据场景来配置参数。那么如何使用呢，一个简单的例如可能如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">katex.render(<span class="string">"c = \\pm\\sqrt&#123;a^2 + b^2&#125;\\in\\RR"</span>, element, &#123;</span><br><span class="line">  displayMode: <span class="literal">true</span>,</span><br><span class="line">  macros: &#123;</span><br><span class="line">    <span class="string">"\\RR"</span>: <span class="string">"\\mathbb&#123;R&#125;"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>7.异常处理</strong></p><blockquote><p>公式排版很细致，但是疏漏不可避免，这时候你可能需要了解一下公式的异常处理。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> html = katex.renderToString(texString);</span><br><span class="line">  <span class="comment">// '&lt;span class="katex"&gt;...&lt;/span&gt;'</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="keyword">if</span> (e <span class="keyword">instanceof</span> katex.ParseError) &#123;</span><br><span class="line">    <span class="comment">// KaTeX can't parse the expression</span></span><br><span class="line">    html = (<span class="string">"Error in LaTeX '"</span> + texString + <span class="string">"': "</span> + e.message)</span><br><span class="line">      .replace(<span class="regexp">/&amp;/g</span>, <span class="string">"&amp;amp;"</span>)</span><br><span class="line">      .replace(<span class="regexp">/&lt;/g</span>, <span class="string">"&amp;lt;"</span>)</span><br><span class="line">      .replace(<span class="regexp">/&gt;/g</span>, <span class="string">"&amp;gt;"</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> e; <span class="comment">// other error</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>8.在线尝试</strong></p><p>公式排版不是一件容易的事，为了达到更好的渲染效果，调试必不可少。还好，KaTex 为我们提供了<a href="https://katex.org/#demo" target="_blank" rel="noopener">在线调试</a>工具</p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><ul><li><code>Mathjax</code> 有着更全面的解析，但却丧失了体积轻量这一优势；</li><li><code>KaTex</code> 则更加灵活，以高速渲染为优势；</li></ul><blockquote><p>所以，按照使用场景选择合适的类库吧。</p></blockquote><h3 id="万变不离其宗"><a href="#万变不离其宗" class="headerlink" title="万变不离其宗"></a>万变不离其宗</h3><p>不管是 <code>Mathjax</code> 还是 <code>KaTex</code> 其实都依赖了底层协议，也就是我们常说的 <code>TEX</code>。<br><a href="https://zh.wikipedia.org/wiki/TeX" target="_blank" rel="noopener">TEX</a>（希腊语：/tɛx/[1]，音译“泰赫”，文本模式下写作 TeX ），是一个由美国计算机教授高德纳（Donald Ervin Knuth）编写的功能强大的排版软件。它在学术界十分流行，特别是数学、物理学和计算机科学界。</p><blockquote><p><code>TEX</code> 被普遍认为是一个优秀的排版工具，特别是在处理复杂的数学公式时。<br>利用诸如是 <code>LATEX</code> 等终端软件，<code>TEX</code> 就能够排版出精美的文本以帮助人们辨认和查找。<code>LATEX</code> 是一套以 <code>TEX</code> 描述的宏软件。<code>LATEX</code> 有很多预设的模版、样式。它比 <code>TEX</code> 更为结构化，如包含了供创建索引、表格、列表等的宏和公用软件。</p></blockquote><h3 id="掌握语法"><a href="#掌握语法" class="headerlink" title="掌握语法"></a>掌握语法</h3><p>既然大家都遵守 <code>TEX</code> 协议，那么就好办了。我们只要掌握底层语法，不管多少个类库都只是包了一层语法糖。那么我们就从语法开始吧，这里我稍作整理，大概如下：</p><p><strong>1.换行 <code>\\</code></strong><br><strong>2.求和</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\displaystyle\sum_0^n</span><br></pre></td></tr></table></figure><p><strong>3.比较</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a \gt b</span><br></pre></td></tr></table></figure><p><strong>4.分数</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\frac&#123;2&#125;&#123;9&#125;</span><br></pre></td></tr></table></figure><p><strong>5.圆弧</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\overgroup&#123;AC&#125;</span><br></pre></td></tr></table></figure><p><strong>6.表格</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;array&#125;&#123;|c|c|c|c|c|c|&#125;\hline年龄\left(岁\right)&amp;12&amp;13&amp;14&amp;15&amp;16\\\hline人数&amp;1&amp;4&amp;3&amp;7&amp;5\\\hline\end&#123;array&#125;</span><br></pre></td></tr></table></figure><p><strong>7.矩阵</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;matrix&#125;</span><br><span class="line">   a &amp; b \\</span><br><span class="line">   c &amp; d</span><br><span class="line">\end&#123;matrix&#125;</span><br></pre></td></tr></table></figure><p><strong>8.条件判断</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;cases&#125;</span><br><span class="line">   a &amp;\text&#123;if &#125; b \\</span><br><span class="line">   c &amp;\text&#123;if &#125; d</span><br><span class="line">\end&#123;cases&#125;</span><br></pre></td></tr></table></figure><p>如果感兴趣，可以看这里的<a href="https://katex.org/docs/support_table.html" target="_blank" rel="noopener">文档</a>。</p><h3 id="实用技巧"><a href="#实用技巧" class="headerlink" title="实用技巧"></a>实用技巧</h3><p><strong>1.公式太长，如何换行?</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\frac&#123;a^&#123;2&#125;-1&#125;&#123;a&#125;÷\frac&#123;(a-1)^&#123;2&#125;&#125;&#123;a&#125;=\frac&#123;(a+1)(a-1)&#125;&#123;a&#125;×\frac&#123;a&#125;&#123;(a-1)^&#123;2&#125;&#125;=\frac&#123;a+1&#125;&#123;a-1&#125;</span><br></pre></td></tr></table></figure><p>像这样的公式，渲染出来会特别长，甚至超出了屏幕边界，大大影响用户体验。</p><p>那我们改一下，使用折行：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;alignedat&#125;&#123;2&#125;</span><br><span class="line">   \frac&#123;a^&#123;2&#125;-1&#125;&#123;a&#125;÷\frac&#123;(a-1)^&#123;2&#125;&#125;&#123;a&#125;= \\</span><br><span class="line">   \frac&#123;(a+1)(a-1)&#125;&#123;a&#125;×\frac&#123;a&#125;&#123;(a-1)^&#123;2&#125;&#125;=\frac&#123;a+1&#125;&#123;a-1&#125;</span><br><span class="line">\end&#123;alignedat&#125;</span><br></pre></td></tr></table></figure><p>这样就完美了～</p><p><strong>2.一定要使用异常捕获</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> katex.renderToString(jarttoLatex, &#123; <span class="attr">displayMode</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="comment">// TODO log error latex</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"katex error"</span>, e);</span><br><span class="line">  <span class="keyword">return</span> jarttoLatex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>公式语法还是比较复杂，稍有不慎很容易出错，所以一定要 <code>try catch</code>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们经常会用 Office Word 在文档中插入数学公式，有没有想过，如何在你的网页上渲染数学公式呢？让我们走进数学，欣赏一下公式渲染的美妙之处。&lt;/p&gt;
&lt;h3 id=&quot;应用场景&quot;&gt;&lt;a href=&quot;#应用场景&quot; class=&quot;headerlink&quot; title=&quot;应用场景&quot;&gt;&lt;/a&gt;应用场景&lt;/h3&gt;&lt;p&gt;我们先来看看都有哪些场景应用到了数学公式，有个整体的印象。此外，可以扩展技术面，让你可以在做技术选型的时候游刃有余：&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://csjiabin.github.io/categories/JavaScript/"/>
    
    
      <category term="js" scheme="https://csjiabin.github.io/tags/js/"/>
    
      <category term="Mathjax" scheme="https://csjiabin.github.io/tags/Mathjax/"/>
    
      <category term="KaTex" scheme="https://csjiabin.github.io/tags/KaTex/"/>
    
      <category term="TEX" scheme="https://csjiabin.github.io/tags/TEX/"/>
    
  </entry>
  
  <entry>
    <title>使用vue-worker轻松使用Vue.js</title>
    <link href="https://csjiabin.github.io/2018/09/05/%E4%BD%BF%E7%94%A8vue-worker%E8%BD%BB%E6%9D%BE%E4%BD%BF%E7%94%A8VueJs/"/>
    <id>https://csjiabin.github.io/2018/09/05/%E4%BD%BF%E7%94%A8vue-worker%E8%BD%BB%E6%9D%BE%E4%BD%BF%E7%94%A8VueJs/</id>
    <published>2018-09-05T07:56:03.000Z</published>
    <updated>2020-11-02T09:26:56.677Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>像许多开发人员一样，当Web Workers首次出现在Web开发环境中时，我非常热情，并且对我可以用它们完成的各种惊人事情感到厌烦。然而，当我意识到工作人员必须从托管在Web服务器上的单独文件加载时，我的热情很快就受到了打击。这似乎是一个巨大的痛苦，不值得努力。结合API开销，自从我第一次尝试到现在为止，我还没有真正再次使用过工作者。看着<code>vue-worker</code>，我突然惊讶于我的Vue.js应用程序可以通过一个简单的API和没有外部文件来完成什么。</p></blockquote><p><a href="https://github.com/israelss/vue-worker" target="_blank" rel="noopener">vue-worker</a>（或者说是同一 <a href="https://github.com/israelss" target="_blank" rel="noopener">作者</a> 的 <a href="https://github.com/israelss/simple-web-worker" target="_blank" rel="noopener">simple-web-worker</a> ）的核心前提是Web Workers可以从Data URI初始化，它可以只是一个字符串化的函数。</p><p><code>vue-worker</code>通过一个简单易懂的API来解决其中涉及的复杂性，允许您像promises一样轻松执行多头函数。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>通过 <strong>Yarn</strong> 或 <strong>NPM</strong> 安装<code>vue-worker</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Yarn</span></span><br><span class="line">yarn add vue-worker</span><br><span class="line"></span><br><span class="line"><span class="comment"># NPM</span></span><br><span class="line">npm install vue-worker --save</span><br></pre></td></tr></table></figure><p>现在，启用<code>VueWorker</code>插件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/main.js</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"><span class="keyword">import</span> VueWorker <span class="keyword">from</span> <span class="string">'vue-worker'</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'App.vue'</span>;</span><br><span class="line"></span><br><span class="line">Vue.use(VueWorker);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这使您的组件能够访问<code>this.$worker</code>。</p><h3 id="在Worker中运行函数"><a href="#在Worker中运行函数" class="headerlink" title="在Worker中运行函数"></a>在Worker中运行函数</h3><p>现在，您可以在组件内部使用<code>this.$worker.run(function, args[])</code>。</p><p>这运行一个输出 <strong>Hello，World</strong> 的函数！在组件安装时的工作线程中：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">  mounted() &#123;</span><br><span class="line"><span class="javascript">    <span class="keyword">this</span>.$worker.run(<span class="function">(<span class="params">arg</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> <span class="string">`Hello, <span class="subst">$&#123;arg&#125;</span>!`</span></span></span><br><span class="line"><span class="actionscript">    &#125;, [<span class="string">'World'</span>])</span></span><br><span class="line"><span class="javascript">    .then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(result)</span></span><br><span class="line">    &#125;)</span><br><span class="line"><span class="javascript">    .catch(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.error(e)</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="可重复使用-Workers"><a href="#可重复使用-Workers" class="headerlink" title="可重复使用 Workers"></a>可重复使用 Workers</h3><p>您可以创建可重复使用的<code>worker</code> 代理 <code>this.$worker.create([{message, func}])</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">  data() &#123;</span><br><span class="line"><span class="actionscript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="actionscript">      myWorker: <span class="literal">null</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  created() &#123;</span><br><span class="line"><span class="actionscript">    <span class="keyword">this</span>.myWorker = <span class="keyword">this</span>.$worker.create([</span></span><br><span class="line"><span class="javascript">      &#123;<span class="attr">message</span>: <span class="string">'message1'</span>, <span class="attr">func</span>: <span class="function">(<span class="params">arg</span>) =&gt;</span> <span class="string">`Output 1 <span class="subst">$&#123;arg&#125;</span>`</span>&#125;,</span></span><br><span class="line"><span class="javascript">      &#123;<span class="attr">message</span>: <span class="string">'message2'</span>, <span class="attr">func</span>: <span class="function"><span class="params">()</span> =&gt;</span> <span class="string">'Output 2'</span>&#125;</span></span><br><span class="line">    ])</span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="keyword">this</span>.myWorker.postMessage(<span class="string">'message1'</span>, [<span class="string">'Boop!'</span>])</span></span><br><span class="line"><span class="javascript">    .then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(result)</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>你还可以做更多的事情，看看<code>vue-worker</code>和<code>simple-worker</code>文档。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;像许多开发人员一样，当Web Workers首次出现在Web开发环境中时，我非常热情，并且对我可以用它们完成的各种惊人事情感到厌烦。然而，当我意识到工作人员必须从托管在Web服务器上的单独文件加载时，我的热情很快就受到了打击。这似乎是一个巨大的痛苦，不值得努力。结合API开销，自从我第一次尝试到现在为止，我还没有真正再次使用过工作者。看着&lt;code&gt;vue-worker&lt;/code&gt;，我突然惊讶于我的Vue.js应用程序可以通过一个简单的API和没有外部文件来完成什么。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/israelss/vue-worker&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;vue-worker&lt;/a&gt;（或者说是同一 &lt;a href=&quot;https://github.com/israelss&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;作者&lt;/a&gt; 的 &lt;a href=&quot;https://github.com/israelss/simple-web-worker&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;simple-web-worker&lt;/a&gt; ）的核心前提是Web Workers可以从Data URI初始化，它可以只是一个字符串化的函数。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;vue-worker&lt;/code&gt;通过一个简单易懂的API来解决其中涉及的复杂性，允许您像promises一样轻松执行多头函数。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://csjiabin.github.io/categories/JavaScript/"/>
    
    
      <category term="js" scheme="https://csjiabin.github.io/tags/js/"/>
    
      <category term="vue" scheme="https://csjiabin.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>HTML5与HTML4的区别</title>
    <link href="https://csjiabin.github.io/2018/09/01/HTML5%E4%B8%8EHTML4%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://csjiabin.github.io/2018/09/01/HTML5%E4%B8%8EHTML4%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2018-09-01T13:28:14.000Z</published>
    <updated>2020-11-02T09:26:56.672Z</updated>
    
    <content type="html"><![CDATA[<h3 id="HTML5-推出的理由"><a href="#HTML5-推出的理由" class="headerlink" title="HTML5 推出的理由"></a>HTML5 推出的理由</h3><p><strong>解决 Web 上存在的问题：</strong></p><p><strong>Web 浏览器间的兼容性低:</strong> 在一个浏览器中可以运行的 HTML、Css、Javascript，在另一个浏览器中不能运行。</p><p><strong>原因：</strong> 各浏览器规范不统一，没有被标准化。</p><p><strong>解决方案：</strong> 使各浏览器的功能符合通用标准。</p><p><strong>文档结构不够明确：</strong> HTML4 中元素不能把文档结构表示清楚。</p><p><strong>解决方案：</strong> 增加与结构相关的元素。</p><p><strong>Web 应用程序的功能受到限制：</strong> HTMLL4 对 Web 应用程序的贡献很小，比如：不允许同时上传多个文件。</p><p><strong>解决方案：</strong> 提供供 Web 应用程序使用的 API。</p><h3 id="HTML5-语法的改变"><a href="#HTML5-语法的改变" class="headerlink" title="HTML5 语法的改变"></a>HTML5 语法的改变</h3><p><strong>内容类型不变</strong><br>HTML5 的文件扩展符（html 或.htm）与内容类型（text/html）保持不变。<br><strong>DOCTYPE 声明变化</strong></p><p>HTML4 中需要指明是 HTML 的哪个版本，HTML5 不需要，只使用<code>&lt;!DOCTYPE html&gt;</code>即可。</p><p><strong>指定字符编码变化</strong></p><p>HTML4：<code>&lt;meta http-equiv=‶content-type″ content=‶text/html; charset=UTF-8″&gt;</code></p><p>HTML5:<code>&lt;meta charset=‶UTF-8″&gt;</code></p><p><strong>可以省略元素的标记</strong></p><p>HTML5 中很多元素标记可以省略</p><p><strong>具有 boolean 值的属性调整</strong></p><p>不指定属性值、属性名设定为属性值、字符串设为空时表示属性值为 true；</p><p>不写该属性表示属性值为 false。</p><p>例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">‶checkbox″</span> <span class="attr">checked</span>&gt;</span>                    <span class="comment">&lt;!--表示checked值为true--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">‶checkbox″</span> <span class="attr">checked</span>=<span class="string">‶checked″</span>&gt;</span>          <span class="comment">&lt;!-- 表示checked值为true --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">‶checkbox″</span> <span class="attr">checked</span>=<span class="string">‶″</span>&gt;</span>                 <span class="comment">&lt;!-- 表示checked值为true --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">‶checkbox″</span>&gt;</span>                            <span class="comment">&lt;!-- 表示checked值为false --&gt;</span></span><br></pre></td></tr></table></figure><p><strong>可省略引号</strong></p><p>HTML5 可省略指定属性值时的引号。</p><h3 id="新增的元素和废除的元素"><a href="#新增的元素和废除的元素" class="headerlink" title="新增的元素和废除的元素"></a>新增的元素和废除的元素</h3><p><strong>新增元素</strong></p><p><strong>新增的结构元素</strong></p><p><strong>section：</strong> 表示页面中内容块，比如章节、页眉、页脚或页面中的其他部分，可与<code>&lt;h1&gt;</code>到<code>&lt;h6&gt;</code>结合使用表示文档结构。</p><p><strong>article：</strong> 表示页面中一块与上下文不相关的独立内容，比如博客中的一篇文章或报纸中的一篇文章。</p><p><strong>aside：</strong> 表示 article 内容之外，与 article 内容相关的辅助信息。</p><p><strong>header：</strong> 表示页面中的区域块，通常用它表示标题。</p><p><strong>hgroup：</strong> 用于对整个页面或页面中标题进行整合。</p><p><strong>footer：</strong> 表示页面中的区域块，通常表示区域快的脚部或底部，用于承载作者姓名、创作日期等与作者的元素。</p><p><strong>nav:</strong> 表示页面中导航部分。</p><p><strong>figure：</strong>表示一段独立的流内容，一般表示主体流内容的一个独立单元。</p><p><strong>新增的其他元素</strong></p><p><strong>video：</strong> 定义电影片段、视频流等视频。</p><p><strong>audio：</strong> 定义音乐或音频流。</p><p><strong>canvas：</strong> 画布，本身没有行为，仅提供一块画布，但它的 API 展现给 JavaScript 及脚本，能够把想绘制的东西绘制在 canvas 上。</p><p><strong>embed mark progress meter time ruby rt rp wbr command details detalist</strong><br><strong>datagrid keygen output source menu</strong></p><p><strong>新增的 input 元素的类型</strong></p><p><strong>email：</strong> 表示必须输的 email 地址</p><p><strong>url：</strong> 表示文本框输入的一个地址</p><p><strong>number：</strong> 表示数字</p><p><strong>range：</strong> 表示数字范围值</p><p><strong>DataPickers：</strong>表示日历的日期、时间</p><p><strong>废除的元素</strong></p><p><strong>能使用 css 代替的元素</strong></p><p>basefont big center font s tt u 等</p><p><strong>不再使用 frame 框架</strong></p><p>由于 <code>frame</code> 框架对网页可用性存在负面影响，<strong>HTML5</strong> 中已不支持 <code>frame</code> 框架，只支持 <code>iframe</code> 框架或者用服务器方式创建的由多个页面组成的复合页面的形式，同时将 <code>frameset</code> 元素、<code>frame</code> 元素、<code>noframes</code> 元素废除。</p><p><strong>只有部分浏览器支持的元素</strong></p><p><strong>其他被废除的元素</strong></p><h3 id="全局属性"><a href="#全局属性" class="headerlink" title="全局属性"></a>全局属性</h3><p>HTML5中新增全局属性的概念，全局属性指可以对任何元素都使用的属性。</p><p><strong>contentEditable属性</strong></p><p>允许用户编辑元素中内容，使用该属性的元素必须为可以获得鼠标焦点的元素，而且在点击鼠标后向用户提供一个插入符号，提示用户该元素允许进行编辑。</p><p>是boolean值类型，可以设为true、false或继承状态。其中，true代表可编辑，false代表不可编辑，当未指定true或false时与父元素的继承状态相同。</p><p><strong>designMode属性</strong></p><p>用来指定整个页面是否可编辑，当页面可编辑时，页面中所有支持contentEditable属性的元素都变为可编辑状况。designMode属性只能在JavaScript脚本中被修改、编辑。属性值可取on（可编辑）或off（不可编辑）。</p><p><strong>hidden属性</strong></p><p>HTML5中所有元素都允许使用hidden属性，该属性类似于input元素中hidden元素，boolean值，可设为true（不可见）、false（可见）。当某元素的hidden属性值为true时，浏览器不渲染该元素，使该元素处于不可见状态，但浏览器创建该元素内容，即页面加载后允许使用JavaScript脚本将该属性值取消，使该元素可见。</p><p><strong>spellcheck属性</strong></p><p>针对input（type=text）与textarea这两个文本输入框提供的一个新属性，主要对用户输入内容进行拼写与语法检查。属性值为boolean值，可取true或false。</p><p><strong>tableindex属性</strong></p><p>当点击Tab键时，让窗口或页面中可获得焦点的链接元素或表单元素进行遍历，tableindex表示该元素第几个被访问到。</p><p>若tableindex值为”-1”时表示无法获取该元素.</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;HTML5-推出的理由&quot;&gt;&lt;a href=&quot;#HTML5-推出的理由&quot; class=&quot;headerlink&quot; title=&quot;HTML5 推出的理由&quot;&gt;&lt;/a&gt;HTML5 推出的理由&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;解决 Web 上存在的问题：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Web 浏览器间的兼容性低:&lt;/strong&gt; 在一个浏览器中可以运行的 HTML、Css、Javascript，在另一个浏览器中不能运行。&lt;/p&gt;
    
    </summary>
    
    
      <category term="html" scheme="https://csjiabin.github.io/categories/html/"/>
    
    
      <category term="html4" scheme="https://csjiabin.github.io/tags/html4/"/>
    
      <category term="html5" scheme="https://csjiabin.github.io/tags/html5/"/>
    
  </entry>
  
  <entry>
    <title>Markdown使用指南</title>
    <link href="https://csjiabin.github.io/2018/08/26/Markdown%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    <id>https://csjiabin.github.io/2018/08/26/Markdown%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</id>
    <published>2018-08-26T05:37:29.000Z</published>
    <updated>2020-11-02T09:26:56.674Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>什么是 Markdown？Markdown 是一种轻量级的「标记语言」，通常为程序员群体所用，目前它已是全球最大的技术分享网站 GitHub 和技术问答网站 StackOverFlow 的御用书写格式。<br>非技术类笔记用户，千万不要被「标记」、「语言」吓到，Markdown 的语法十分简单，常用的标记符号不超过十个，用于日常写作记录绰绰有余，不到半小时就能完全掌握。<br>就是这十个不到的标记符号，却能让人优雅地沉浸式记录，专注内容而不是纠结排版，达到「心中无尘，码字入神」的境界。</p><h2 id="利用-Markdown-可以做什么？"><a href="#利用-Markdown-可以做什么？" class="headerlink" title="利用 Markdown 可以做什么？"></a>利用 Markdown 可以做什么？</h2><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><p>标题是每篇文章必备而且最常用的格式。<br>在 Markdown 中，如果想将一段文字定义为标题，只需要在这段文字前面加上 #，再在 # 后加一个空格即可。还可增加二、三、四、五、六级标题，总共六级，只需要增加 # ，增加一个 # ，标题字号相应降低一级。<br>代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">#### 四级标题</span><br><span class="line">##### 五级标题</span><br><span class="line">###### 六级标题</span><br></pre></td></tr></table></figure><div style="text-align:center;color:gray;">效果如下：</div><p><img data-src="/uploads/post/WX20180826-152410@2x.png" alt="效果"></p><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>列表格式也很常用，它可以让你的文稿变得井井有条。在 Markdown 中，你只需要在文字前面加上 - 就可以了；如果你希望是有序列表，在文字前面加上 1. 2. 3. 即可。</p><blockquote><p>注：-、1.和文字之间要保留一个字符的空格。</p></blockquote><p><strong>无序列表</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 代码</span></span><br><span class="line">- 列表 <span class="number">1</span></span><br><span class="line">  - 列表 <span class="number">1.1</span></span><br><span class="line">  - 列表 <span class="number">1.2</span></span><br><span class="line">- 列表 <span class="number">2</span></span><br><span class="line">- 列表 <span class="number">3</span></span><br></pre></td></tr></table></figure><div style="text-align:center;color:gray;">效果如下：</div><ul><li>列表 1<ul><li>列表 1.1</li><li>列表 1.2</li></ul></li><li>列表 2</li><li>列表 3</li></ul><blockquote><p>无序列表可以用* ， + ， — 来创建，用在线编辑器看，实际上是转换成了 ul&gt;li ，所以使用哪个都可以。</p></blockquote><hr><p><strong>有序列表</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 代码</span></span><br><span class="line"><span class="number">1.</span> 列表 <span class="number">1</span></span><br><span class="line"><span class="number">2.</span> 列表 <span class="number">2</span></span><br><span class="line"><span class="number">3.</span> 列表 <span class="number">3</span></span><br></pre></td></tr></table></figure><div style="text-align:center;color:gray;">效果如下：</div>1. 列表 12. 列表 23. 列表 3<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>如果你需要在文稿中引用一段别处的句子，那么就要用到「引用」格式。</p><p>在引用文字前加上 <code>&gt;</code> 并与文字保留一个字符的空格，即可。代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; - 前方高能</span><br><span class="line">&gt; &gt; 注意：这里是为了提醒前面有很刺激的事情发生，请做好准备。</span><br><span class="line">&gt; &gt; 城市套路深，我要回农村。</span><br></pre></td></tr></table></figure><div style="text-align:center;color:gray;">效果如下：</div><blockquote><ul><li>前方高能<blockquote><p> 注意：这里是为了提醒前面有很刺激的事情发生，请做好准备。<br>城市套路深，我要回农村。</p></blockquote></li></ul></blockquote><blockquote><p>注：符号与文本之间必须空格。</p></blockquote><p>由上面例子可以看出，想要在上一次引用中嵌套一层引用，只需多加一个&gt;，理论上可以无限嵌套，我就不整那么多了，注意：多层嵌套的<code>&gt;</code>是不需要连续在一起的，只要在一行就可以了，中间允许有空格，但是为了好看，还是把排版搞好吧。</p><h3 id="代码框"><a href="#代码框" class="headerlink" title="代码框"></a>代码框</h3><p>这个就比较重要了，很多时候都需要展示出一些代码<br>如果代码量比较少，只有单行的话，可以用单反引号包起来，如下：<br><strong>单行用</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">`</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:;"</span>&gt;</span>气宇轩昂<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">`</span><br></pre></td></tr></table></figure><div style="text-align:center;color:gray;">效果如下：</div><p><code>&lt;p&gt;&lt;a href=&quot;javascript:;&quot;&gt;气宇轩昂&lt;/a&gt;&lt;/p&gt;</code></p><p>要是多行这个就不行了，多行可以用这个：<br><img data-src="/uploads/post/WX20180826-181515@2x.png" alt=""></p><div style="text-align:center;color:gray;">效果如下：</div><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>这是title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>我的第一个标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>我的第一个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>多行用三个反引号，如果要写注释，可以在反引号后面写</p><h3 id="链接与图片"><a href="#链接与图片" class="headerlink" title="链接与图片"></a>链接与图片</h3><p>链接：在 Markdown 中，插入链接只需要使用 <code>[显示文本](链接地址)</code> 即可。</p><p>图片：在 Markdown 中，插入图片只需要使用 <code>![显示文本](图片链接地址)</code>即可。</p><blockquote><p>注：插入图片的语法和链接的语法很像，只是前面多了一个 <code>!</code></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">**插入链接：**</span><br><span class="line">[气宇轩昂](http:&#x2F;&#x2F;example.com&#x2F;)</span><br><span class="line"></span><br><span class="line">**插入图片：**</span><br><span class="line">![这是一张图](&#x2F;uploads&#x2F;post&#x2F;home-bg-o.jpg)</span><br></pre></td></tr></table></figure><div style="text-align:center;color:gray;">效果如下：</div><p><strong>插入链接：</strong><br><a href="http://example.com/" target="_blank" rel="noopener">气宇轩昂</a></p><p><strong>插入图片：</strong><br><img data-src="/uploads/post/home-bg-o.jpg" alt="这是一张图"></p><p>上述方法只是单纯把图片显示出来，无法自定义设置图片大小，如果图片很大的话就会铺满屏幕或者超高，排版上不好看。</p><p><strong>通过 <code>img</code> 标签控制宽高:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span></span></span><br><span class="line"><span class="tag">  <span class="attr">src</span>=<span class="string">"http://pic15.photophoto.cn/20100615/0006019058815826_b.jpg"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">height</span>=<span class="string">"330"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">width</span>=<span class="string">"400"</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 或者 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"/uploads/post/home-bg-o.jpg"</span> <span class="attr">style</span>=<span class="string">"height:200px;width:400px"</span> /&gt;</span></span><br></pre></td></tr></table></figure><div style="text-align:center;color:gray;">效果如下：</div><img data-src="/uploads/post/home-bg-o.jpg" style="height:200px;width:400px;"><p><strong>通过 <code>&lt;div&gt;</code> 标签和 <code>align</code> 属性控制对齐方式:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"display:flex;justify-content:center;"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"/uploads/post/home-bg-o.jpg"</span> <span class="attr">style</span>=<span class="string">"width:300px;"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"/uploads/post/home-bg.jpg"</span> <span class="attr">style</span>=<span class="string">"width:300px;"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><div style="text-align:center;color:gray;">效果如下：</div><div class="img-content" style="display:flex;justify-content:center;">  <img data-src="/uploads/post/home-bg-o.jpg" style="width:350px;height:200px;display:inline-block !important;margin:0;"><img data-src="/uploads/post/home-bg.jpg" style="width:350px;height:200px;display:inline-block !important;margin:0 20px;"></div><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><p>当你需要在 Markdown 文稿中键入表格，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 第一种写法</span><br><span class="line">| name | age | sex |</span><br><span class="line">| :--: | :-- | --: |</span><br><span class="line">| tony | 18  | 男  |</span><br><span class="line"></span><br><span class="line"># 第二种写法</span><br><span class="line">表头1 | 表头2</span><br><span class="line">---- | ----</span><br><span class="line">Cell | Cell</span><br><span class="line">|</span><br><span class="line"># 第三种写法</span><br><span class="line"></span><br><span class="line">学号|姓名|分数</span><br><span class="line">-|-|-</span><br><span class="line">001|小明|90</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">name</th><th align="left">age</th><th align="right">sex</th></tr></thead><tbody><tr><td align="center">tony</td><td align="left">18</td><td align="right">男</td></tr></tbody></table><table><thead><tr><th>表头 1</th><th>表头 2</th></tr></thead><tbody><tr><td>Cell</td><td>Cell</td></tr></tbody></table><table><thead><tr><th>学号</th><th>姓名</th><th>分数</th></tr></thead><tbody><tr><td>001</td><td>小明</td><td>90</td></tr></tbody></table><p>从这 3 种不同写法看，表格的格式不一定要对的非常齐，但是为了好看，对齐肯定是最好的，第一种的分割线后面的冒号表示对齐方式，写在左边表示左对齐，右边为右对齐，两边都写表示居中，还是有点意思的。</p><h3 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*字体倾斜*</span><br><span class="line">_字体倾斜_</span><br><span class="line">**字体加粗**</span><br><span class="line">__字体加粗__</span><br></pre></td></tr></table></figure><div style="text-align:center;color:gray;">效果如下：</div><p><em>字体倾斜</em><br><em>字体倾斜</em><br><strong>字体加粗</strong><br><strong>字体加粗</strong></p><p>一个星号或者是一个下划线包起来，会转换为<code>&lt;em&gt;</code>倾斜，如果是 2 个，会转换为<code>&lt;strong&gt;</code>加粗。</p><h3 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h3><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">* </span>\\</span><br><span class="line"><span class="bullet">* </span>\`</span><br><span class="line"><span class="bullet">* </span>\~</span><br><span class="line"><span class="bullet">* </span>\_</span><br><span class="line"><span class="bullet">* </span>\-</span><br><span class="line"><span class="bullet">* </span>\+</span><br><span class="line"><span class="bullet">* </span>\.</span><br><span class="line"><span class="bullet">* </span>\!</span><br></pre></td></tr></table></figure><div style="text-align:center;color:gray;">效果如下：</div><ol><li>\</li><li>`</li><li>~</li><li>_</li><li>-</li><li>+</li><li>.</li><li>!</li></ol><p>就不一一列举了，基本上跟 js 转义是一样的</p><h3 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~~请删掉我吧~~</span><br></pre></td></tr></table></figure><div style="text-align:center;color:gray;">效果如下：</div><p><del>请删掉我吧</del></p><h3 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h3><p>分割线的语法只需要另起一行，分割线可以由* - _（星号，减号，底线）这 3 个符号的至少 3 个符号表示，注意至少要 3 个，且不需要连续，有空格也可以。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">这是第一段内容</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">这是第二段内容</span><br></pre></td></tr></table></figure><div style="text-align:center;color:gray;">效果如下：</div>这是第一段内容<hr><p>这是第二段内容</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;什么是 Markdown？Markdown 是一种轻量级的「标记语言」，通常为程序员群体所用，目前它已是全球最大的技术分享网站 GitHub 和技术问答网站 StackOverFlow 的御用书写格式。&lt;br&gt;非技术类笔记用户，千万不要被「标记」、「语言」吓到，Markdown 的语法十分简单，常用的标记符号不超过十个，用于日常写作记录绰绰有余，不到半小时就能完全掌握。&lt;br&gt;就是这十个不到的标记符号，却能让人优雅地沉浸式记录，专注内容而不是纠结排版，达到「心中无尘，码字入神」的境界。&lt;/p&gt;
&lt;h2 id=&quot;利用-Markdown-可以做什么？&quot;&gt;&lt;a href=&quot;#利用-Markdown-可以做什么？&quot; class=&quot;headerlink&quot; title=&quot;利用 Markdown 可以做什么？&quot;&gt;&lt;/a&gt;利用 Markdown 可以做什么？&lt;/h2&gt;
    
    </summary>
    
    
      <category term="other" scheme="https://csjiabin.github.io/categories/other/"/>
    
    
      <category term="Markdown" scheme="https://csjiabin.github.io/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript有用的代码片段和trick</title>
    <link href="https://csjiabin.github.io/2018/08/22/JavaScript%E6%9C%89%E7%94%A8%E7%9A%84%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5%E5%92%8Ctrick/"/>
    <id>https://csjiabin.github.io/2018/08/22/JavaScript%E6%9C%89%E7%94%A8%E7%9A%84%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5%E5%92%8Ctrick/</id>
    <published>2018-08-22T13:51:29.000Z</published>
    <updated>2020-11-02T09:26:56.674Z</updated>
    
    <content type="html"><![CDATA[<h4 id="浮点数取整"><a href="#浮点数取整" class="headerlink" title="浮点数取整"></a>浮点数取整</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> x = <span class="number">123.4545</span>;</span><br><span class="line">x &gt;&gt; <span class="number">0</span>; <span class="comment">// 123</span></span><br><span class="line">~~x; <span class="comment">// 123</span></span><br><span class="line">x | <span class="number">0</span>; <span class="comment">// 123</span></span><br><span class="line"><span class="built_in">Math</span>.floor(x); <span class="comment">// 123</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：前三种方法只适用于32个位整数，对于负数的处理上和 Math.floor是不同的。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.floor(<span class="number">-12.53</span>); <span class="comment">// -13</span></span><br><span class="line"><span class="number">-12.53</span> | <span class="number">0</span>; <span class="comment">// -12</span></span><br></pre></td></tr></table></figure><h4 id="生成6位数字验证码"><a href="#生成6位数字验证码" class="headerlink" title="生成6位数字验证码"></a>生成6位数字验证码</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一</span></span><br><span class="line">(<span class="string">'000000'</span> + <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() *  <span class="number">999999</span>)).slice(<span class="number">-6</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line"><span class="built_in">Math</span>.random().toString().slice(<span class="number">-6</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法三</span></span><br><span class="line"><span class="built_in">Math</span>.random().toFixed(<span class="number">6</span>).slice(<span class="number">-6</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法四</span></span><br><span class="line"><span class="string">''</span> + <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">999999</span>);</span><br></pre></td></tr></table></figure><h4 id="16进制颜色代码生成"><a href="#16进制颜色代码生成" class="headerlink" title="16进制颜色代码生成"></a>16进制颜色代码生成</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'#'</span>+(<span class="string">'00000'</span>+</span><br><span class="line">    (<span class="built_in">Math</span>.random()*<span class="number">0x1000000</span>&lt;&lt;<span class="number">0</span>).toString(<span class="number">16</span>)).slice(<span class="number">-6</span>);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h4 id="驼峰命名转下划线"><a href="#驼峰命名转下划线" class="headerlink" title="驼峰命名转下划线"></a>驼峰命名转下划线</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'componentMapModelRegistry'</span>.match(<span class="regexp">/^[a-z][a-z0-9]+|[A-Z][a-z0-9]*/g</span>).join(<span class="string">'_'</span>).toLowerCase(); <span class="comment">// component_map_model_registry</span></span><br></pre></td></tr></table></figure><h4 id="url查询参数转json格式"><a href="#url查询参数转json格式" class="headerlink" title="url查询参数转json格式"></a>url查询参数转json格式</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES6</span></span><br><span class="line"><span class="keyword">const</span> query = <span class="function">(<span class="params">search = <span class="string">''</span></span>) =&gt;</span> <span class="function">(<span class="params">(querystring = <span class="string">''</span></span>) =&gt;</span> (<span class="function"><span class="params">q</span> =&gt;</span> (querystring.split(<span class="string">'&amp;'</span>).forEach(<span class="function"><span class="params">item</span> =&gt;</span> (<span class="function"><span class="params">kv</span> =&gt;</span> kv[<span class="number">0</span>] &amp;&amp; (q[kv[<span class="number">0</span>]] = kv[<span class="number">1</span>]))(item.split(<span class="string">'='</span>))), q))(&#123;&#125;))(search.split(<span class="string">'?'</span>)[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对应ES5实现</span></span><br><span class="line"><span class="keyword">var</span> query = <span class="function"><span class="keyword">function</span>(<span class="params">search</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (search === <span class="keyword">void</span> <span class="number">0</span>) &#123; search = <span class="string">''</span>; &#125;</span><br><span class="line">  <span class="keyword">return</span> (<span class="function"><span class="keyword">function</span>(<span class="params">querystring</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (querystring === <span class="keyword">void</span> <span class="number">0</span>) &#123; querystring = <span class="string">''</span>; &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="function"><span class="keyword">function</span>(<span class="params">q</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> (querystring.split(<span class="string">'&amp;'</span>).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="function"><span class="keyword">function</span>(<span class="params">kv</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> kv[<span class="number">0</span>] &amp;&amp; (q[kv[<span class="number">0</span>]] = kv[<span class="number">1</span>]);</span><br><span class="line">        &#125;)(item.split(<span class="string">'='</span>));</span><br><span class="line">      &#125;), q);</span><br><span class="line">    &#125;)(&#123;&#125;);</span><br><span class="line">  &#125;)(search.split(<span class="string">'?'</span>)[<span class="number">1</span>]);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">query(<span class="string">'?key1=value1&amp;key2=value2'</span>); <span class="comment">// es6.html:14 &#123;key1: "value1", key2: "value2"&#125;</span></span><br></pre></td></tr></table></figure><h4 id="获取URL参数"><a href="#获取URL参数" class="headerlink" title="获取URL参数"></a>获取URL参数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getQueryString</span>(<span class="params">key</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"(^|&amp;)"</span>+ key +<span class="string">"=([^&amp;]*)(&amp;|$)"</span>);</span><br><span class="line">  <span class="keyword">var</span> r = <span class="built_in">window</span>.location.search.substr(<span class="number">1</span>).match(reg);</span><br><span class="line">  <span class="keyword">if</span>(!!r)&#123;</span><br><span class="line">      <span class="keyword">return</span>  <span class="built_in">unescape</span>(r[<span class="number">2</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="n维数组展开成一维数组"><a href="#n维数组展开成一维数组" class="headerlink" title="n维数组展开成一维数组"></a>n维数组展开成一维数组</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>], [<span class="string">'4'</span>, <span class="number">5</span>, [<span class="string">'6'</span>,<span class="number">7</span>,[<span class="number">8</span>]]], [<span class="number">9</span>], <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法一</span></span><br><span class="line"><span class="comment">// 限制：数组项不能出现`,`，同时数组项全部变成了字符数字</span></span><br><span class="line">foo.toString().split(<span class="string">','</span>); <span class="comment">// ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10"]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line"><span class="comment">// 转换后数组项全部变成数字了</span></span><br><span class="line"><span class="built_in">eval</span>(<span class="string">'['</span> + foo + <span class="string">']'</span>); <span class="comment">// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法三，使用ES6展开操作符</span></span><br><span class="line"><span class="comment">// 写法太过麻烦，太过死板</span></span><br><span class="line">[<span class="number">1</span>, ...[<span class="number">2</span>, <span class="number">3</span>], ...[<span class="string">'4'</span>, <span class="number">5</span>, ...[<span class="string">'6'</span>,<span class="number">7</span>,...[<span class="number">8</span>]]], ...[<span class="number">9</span>], <span class="number">10</span>]; <span class="comment">// [1, 2, 3, "4", 5, "6", 7, 8, 9, 10]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法四</span></span><br><span class="line"><span class="built_in">JSON</span>.parse(<span class="string">`[<span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(foo).replace(<span class="regexp">/\[|]/g</span>, <span class="string">''</span>)&#125;</span>]`</span>); <span class="comment">// [1, 2, 3, "4", 5, "6", 7, 8, 9, 10]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法五</span></span><br><span class="line"><span class="keyword">const</span> flatten = <span class="function">(<span class="params">ary</span>) =&gt;</span> ary.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a.concat(<span class="built_in">Array</span>.isArray(b) ? flatten(b) : b), []);</span><br><span class="line">flatten(foo); <span class="comment">// [1, 2, 3, "4", 5, "6", 7, 8, 9, 10]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法六</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.isArray(a) ? [].concat(...a.map(flatten)) : a;</span><br><span class="line">&#125;</span><br><span class="line">flatten(foo); <span class="comment">// [1, 2, 3, "4", 5, "6", 7, 8, 9, 10]</span></span><br></pre></td></tr></table></figure><blockquote><p>注：更多方法请参考《How to flatten nested array in JavaScript?》</p></blockquote><h4 id="日期格式化"><a href="#日期格式化" class="headerlink" title="日期格式化"></a>日期格式化</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">format1</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> z = &#123;</span><br><span class="line">    y: x.getFullYear(),</span><br><span class="line">    M: x.getMonth() + <span class="number">1</span>,</span><br><span class="line">    d: x.getDate(),</span><br><span class="line">    h: x.getHours(),</span><br><span class="line">    m: x.getMinutes(),</span><br><span class="line">    s: x.getSeconds()</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> y.replace(<span class="regexp">/(y+|M+|d+|h+|m+|s+)/g</span>, <span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((v.length &gt; <span class="number">1</span> ? <span class="string">"0"</span> : <span class="string">""</span>) + <span class="built_in">eval</span>(<span class="string">'z.'</span> + v.slice(<span class="number">-1</span>))).slice(-(v.length &gt; <span class="number">2</span> ? v.length : <span class="number">2</span>))</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">format1(<span class="keyword">new</span> <span class="built_in">Date</span>(), <span class="string">'yy-M-d h:m:s'</span>); <span class="comment">// 17-10-14 22:14:41</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line"><span class="built_in">Date</span>.prototype.format = <span class="function"><span class="keyword">function</span> (<span class="params">fmt</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">var</span> o = &#123;</span><br><span class="line">    <span class="string">"M+"</span>: <span class="keyword">this</span>.getMonth() + <span class="number">1</span>, <span class="comment">//月份 </span></span><br><span class="line">    <span class="string">"d+"</span>: <span class="keyword">this</span>.getDate(), <span class="comment">//日 </span></span><br><span class="line">    <span class="string">"h+"</span>: <span class="keyword">this</span>.getHours(), <span class="comment">//小时 </span></span><br><span class="line">    <span class="string">"m+"</span>: <span class="keyword">this</span>.getMinutes(), <span class="comment">//分 </span></span><br><span class="line">    <span class="string">"s+"</span>: <span class="keyword">this</span>.getSeconds(), <span class="comment">//秒 </span></span><br><span class="line">    <span class="string">"q+"</span>: <span class="built_in">Math</span>.floor((<span class="keyword">this</span>.getMonth() + <span class="number">3</span>) / <span class="number">3</span>), <span class="comment">//季度 </span></span><br><span class="line">    <span class="string">"S"</span>: <span class="keyword">this</span>.getMilliseconds() <span class="comment">//毫秒 </span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">if</span> (<span class="regexp">/(y+)/</span>.test(fmt))&#123;</span><br><span class="line">    fmt = fmt.replace(<span class="built_in">RegExp</span>.$<span class="number">1</span>, (<span class="keyword">this</span>.getFullYear() + <span class="string">""</span>).substr(<span class="number">4</span> - <span class="built_in">RegExp</span>.$<span class="number">1.</span>length));</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> k <span class="keyword">in</span> o)&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"("</span> + k + <span class="string">")"</span>).test(fmt))&#123;</span><br><span class="line">      fmt = fmt.replace(<span class="built_in">RegExp</span>.$<span class="number">1</span>, (<span class="built_in">RegExp</span>.$<span class="number">1.</span>length == <span class="number">1</span>) ? (o[k]) : ((<span class="string">"00"</span> + o[k]).substr((<span class="string">""</span> + o[k]).length)));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;     </span><br><span class="line">  <span class="keyword">return</span> fmt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>().format(<span class="string">'yy-M-d h:m:s'</span>); <span class="comment">// 17-10-14 22:18:17</span></span><br></pre></td></tr></table></figure><h4 id="统计文字个数"><a href="#统计文字个数" class="headerlink" title="统计文字个数"></a>统计文字个数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wordCount</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> pattern = <span class="regexp">/[a-zA-Z0-9_\u0392-\u03c9]+|[\u4E00-\u9FFF\u3400-\u4dbf\uf900-\ufaff\u3040-\u309f\uac00-\ud7af]+/g</span>;</span><br><span class="line">  <span class="keyword">var</span> m = data.match(pattern);</span><br><span class="line">  <span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>( m === <span class="literal">null</span> ) <span class="keyword">return</span> count;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; m.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (m[i].charCodeAt(<span class="number">0</span>) &gt;= <span class="number">0x4E00</span>) &#123;</span><br><span class="line">      count += m[i].length;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      count += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> text = <span class="string">'贷款买房，也意味着你能给自己的资产加杠杆，能够撬动更多的钱，来孳生更多的财务性收入。'</span>;</span><br><span class="line">wordCount(text); <span class="comment">// 38</span></span><br></pre></td></tr></table></figure><h4 id="特殊字符转义"><a href="#特殊字符转义" class="headerlink" title="特殊字符转义"></a>特殊字符转义</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">htmlspecialchars</span> (<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> str = str.toString().replace(<span class="regexp">/&amp;/g</span>, <span class="string">"&amp;amp;"</span>).replace(<span class="regexp">/&lt;/g</span>, <span class="string">"&amp;lt;"</span>).replace(<span class="regexp">/&gt;/g</span>, <span class="string">"&amp;gt;"</span>).replace(<span class="regexp">/"/g</span>, <span class="string">'&amp;quot;'</span>);</span><br><span class="line">  <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">htmlspecialchars(<span class="string">'&amp;jfkds&lt;&gt;'</span>); <span class="comment">// "&amp;amp;jfkds&amp;lt;&amp;gt;"</span></span><br></pre></td></tr></table></figure><h4 id="动态插入js"><a href="#动态插入js" class="headerlink" title="动态插入js"></a>动态插入js</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">injectScript</span>(<span class="params">src</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> s, t;</span><br><span class="line">    s = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">    s.type = <span class="string">'text/javascript'</span>;</span><br><span class="line">    s.async = <span class="literal">true</span>;</span><br><span class="line">    s.src = src;</span><br><span class="line">    t = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'script'</span>)[<span class="number">0</span>];</span><br><span class="line">    t.parentNode.insertBefore(s, t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="格式化数量"><a href="#格式化数量" class="headerlink" title="格式化数量"></a>格式化数量</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">formatNum</span> (<span class="params">num, n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> num == <span class="string">"number"</span>) &#123;</span><br><span class="line">    num = <span class="built_in">String</span>(num.toFixed(n || <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">var</span> re = <span class="regexp">/(-?\d+)(\d&#123;3&#125;)/</span>;</span><br><span class="line">    <span class="keyword">while</span> (re.test(num)) num = num.replace(re, <span class="string">"$1,$2"</span>);</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">formatNum(<span class="number">2313123</span>, <span class="number">3</span>); <span class="comment">// "2,313,123.000"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line"><span class="string">'2313123'</span>.replace(<span class="regexp">/\B(?=(\d&#123;3&#125;)+(?!\d))/g</span>, <span class="string">','</span>); <span class="comment">// "2,313,123"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法三</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">formatNum</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str.split(<span class="string">''</span>).reverse().reduce(<span class="function">(<span class="params">prev, next, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ((index % <span class="number">3</span>) ? next : (next + <span class="string">','</span>)) + prev</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">formatNum(<span class="string">'2313323'</span>); <span class="comment">// "2,313,323"</span></span><br></pre></td></tr></table></figure><h4 id="身份证验证"><a href="#身份证验证" class="headerlink" title="身份证验证"></a>身份证验证</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">chechCHNCardId</span>(<span class="params">sNo</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>.regExpTest(sNo, /^[<span class="number">0</span><span class="number">-9</span>]&#123;<span class="number">17</span>&#125;[X0<span class="number">-9</span>]$/)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  sNo = sNo.toString();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> a, b, c;</span><br><span class="line">  a = <span class="built_in">parseInt</span>(sNo.substr(<span class="number">0</span>, <span class="number">1</span>)) * <span class="number">7</span> + <span class="built_in">parseInt</span>(sNo.substr(<span class="number">1</span>, <span class="number">1</span>)) * <span class="number">9</span> + <span class="built_in">parseInt</span>(sNo.substr(<span class="number">2</span>, <span class="number">1</span>)) * <span class="number">10</span>;</span><br><span class="line">  a = a + <span class="built_in">parseInt</span>(sNo.substr(<span class="number">3</span>, <span class="number">1</span>)) * <span class="number">5</span> + <span class="built_in">parseInt</span>(sNo.substr(<span class="number">4</span>, <span class="number">1</span>)) * <span class="number">8</span> + <span class="built_in">parseInt</span>(sNo.substr(<span class="number">5</span>, <span class="number">1</span>)) * <span class="number">4</span>;</span><br><span class="line">  a = a + <span class="built_in">parseInt</span>(sNo.substr(<span class="number">6</span>, <span class="number">1</span>)) * <span class="number">2</span> + <span class="built_in">parseInt</span>(sNo.substr(<span class="number">7</span>, <span class="number">1</span>)) * <span class="number">1</span> + <span class="built_in">parseInt</span>(sNo.substr(<span class="number">8</span>, <span class="number">1</span>)) * <span class="number">6</span>;</span><br><span class="line">  a = a + <span class="built_in">parseInt</span>(sNo.substr(<span class="number">9</span>, <span class="number">1</span>)) * <span class="number">3</span> + <span class="built_in">parseInt</span>(sNo.substr(<span class="number">10</span>, <span class="number">1</span>)) * <span class="number">7</span> + <span class="built_in">parseInt</span>(sNo.substr(<span class="number">11</span>, <span class="number">1</span>)) * <span class="number">9</span>;</span><br><span class="line">  a = a + <span class="built_in">parseInt</span>(sNo.substr(<span class="number">12</span>, <span class="number">1</span>)) * <span class="number">10</span> + <span class="built_in">parseInt</span>(sNo.substr(<span class="number">13</span>, <span class="number">1</span>)) * <span class="number">5</span> + <span class="built_in">parseInt</span>(sNo.substr(<span class="number">14</span>, <span class="number">1</span>)) * <span class="number">8</span>;</span><br><span class="line">  a = a + <span class="built_in">parseInt</span>(sNo.substr(<span class="number">15</span>, <span class="number">1</span>)) * <span class="number">4</span> + <span class="built_in">parseInt</span>(sNo.substr(<span class="number">16</span>, <span class="number">1</span>)) * <span class="number">2</span>;</span><br><span class="line">  b = a % <span class="number">11</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (b == <span class="number">2</span>) &#123;</span><br><span class="line">    c = sNo.substr(<span class="number">17</span>, <span class="number">1</span>).toUpperCase();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    c = <span class="built_in">parseInt</span>(sNo.substr(<span class="number">17</span>, <span class="number">1</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (b) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">      <span class="keyword">if</span> (c != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">      <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">      <span class="keyword">if</span> (c != <span class="string">"X"</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">      <span class="keyword">if</span> (c != <span class="number">9</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">      <span class="keyword">if</span> (c != <span class="number">8</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">      <span class="keyword">if</span> (c != <span class="number">7</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">      <span class="keyword">if</span> (c != <span class="number">6</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">      <span class="keyword">if</span> (c != <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">      <span class="keyword">if</span> (c != <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">      <span class="keyword">if</span> (c != <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">      <span class="keyword">if</span> (c != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试质数"><a href="#测试质数" class="headerlink" title="测试质数"></a>测试质数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPrime</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> !(<span class="regexp">/^.?$|^(..+?)\1+$/</span>).test(<span class="string">'1'</span>.repeat(n))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="统计字符串中相同字符出现的次数"><a href="#统计字符串中相同字符出现的次数" class="headerlink" title="统计字符串中相同字符出现的次数"></a>统计字符串中相同字符出现的次数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="string">'abcdaabc'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> info = arr</span><br><span class="line">    .split(<span class="string">''</span>)</span><br><span class="line">    .reduce(<span class="function">(<span class="params">p, k</span>) =&gt;</span> (p[k]++ || (p[k] = <span class="number">1</span>), p), &#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(info); <span class="comment">//&#123; a: 3, b: 2, c: 2, d: 1 &#125;</span></span><br></pre></td></tr></table></figure><h4 id="使用void-0来解决undefined被污染问题"><a href="#使用void-0来解决undefined被污染问题" class="headerlink" title="使用void 0来解决undefined被污染问题"></a>使用<code>void 0</code>来解决<code>undefined</code>被污染问题</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">undefined</span> = <span class="number">1</span>;</span><br><span class="line">!!<span class="literal">undefined</span>; <span class="comment">// true</span></span><br><span class="line">!!<span class="keyword">void</span>(<span class="number">0</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h4 id="单行写一个评级组件"><a href="#单行写一个评级组件" class="headerlink" title="单行写一个评级组件"></a>单行写一个评级组件</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"★★★★★☆☆☆☆☆"</span>.slice(<span class="number">5</span> - rate, <span class="number">10</span> - rate);</span><br></pre></td></tr></table></figure><h4 id="JavaScript-错误处理的方式的正确姿势"><a href="#JavaScript-错误处理的方式的正确姿势" class="headerlink" title="JavaScript 错误处理的方式的正确姿势"></a>JavaScript 错误处理的方式的正确姿势</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    something</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">window</span>.location.href =</span><br><span class="line">        <span class="string">"http://stackoverflow.com/search?q=[js]+"</span> +</span><br><span class="line">        e.message;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="匿名函数自执行写法"><a href="#匿名函数自执行写法" class="headerlink" title="匿名函数自执行写法"></a>匿名函数自执行写法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">( <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;() );</span><br><span class="line">( <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125; )();</span><br><span class="line">[ <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;() ];</span><br><span class="line"></span><br><span class="line">~ <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;();</span><br><span class="line">! <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;();</span><br><span class="line">+ <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;();</span><br><span class="line">- <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;();</span><br><span class="line"><span class="keyword">typeof</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;();</span><br><span class="line"><span class="keyword">void</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;();</span><br><span class="line"><span class="keyword">new</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;();</span><br><span class="line"><span class="keyword">new</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;();</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;();</span><br><span class="line"><span class="number">1</span> ^ <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;();</span><br><span class="line"><span class="number">1</span> &gt; <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;();</span><br></pre></td></tr></table></figure><h4 id="两个整数交换数值"><a href="#两个整数交换数值" class="headerlink" title="两个整数交换数值"></a>两个整数交换数值</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">20</span>, b = <span class="number">30</span>;</span><br><span class="line">a ^= b;</span><br><span class="line">b ^= a;</span><br><span class="line">a ^= b;</span><br><span class="line"></span><br><span class="line">a; <span class="comment">// 30</span></span><br><span class="line">b; <span class="comment">// 20</span></span><br></pre></td></tr></table></figure><h4 id="数字字符转数字"><a href="#数字字符转数字" class="headerlink" title="数字字符转数字"></a>数字字符转数字</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">'1'</span>;</span><br><span class="line">+a; <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h4 id="最短的代码实现数组去重"><a href="#最短的代码实现数组去重" class="headerlink" title="最短的代码实现数组去重"></a>最短的代码实现数组去重</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[...new <span class="built_in">Set</span>([<span class="number">1</span>, <span class="string">"1"</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>])]; <span class="comment">// [1, "1", 2, 3]</span></span><br></pre></td></tr></table></figure><h4 id="用最短的代码实现一个长度为m-6-且值都n-8-的数组"><a href="#用最短的代码实现一个长度为m-6-且值都n-8-的数组" class="headerlink" title="用最短的代码实现一个长度为m(6)且值都n(8)的数组"></a>用最短的代码实现一个长度为m(6)且值都n(8)的数组</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>(<span class="number">6</span>).fill(<span class="number">8</span>); <span class="comment">// [8, 8, 8, 8, 8, 8]</span></span><br></pre></td></tr></table></figure><h4 id="将argruments对象转换成数组"><a href="#将argruments对象转换成数组" class="headerlink" title="将argruments对象转换成数组"></a>将argruments对象转换成数组</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> argArray = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6：</span></span><br><span class="line"><span class="keyword">var</span> argArray = <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="keyword">var</span> argArray = [...arguments];</span><br></pre></td></tr></table></figure><h4 id="获取日期时间缀"><a href="#获取日期时间缀" class="headerlink" title="获取日期时间缀"></a>获取日期时间缀</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取指定时间的时间缀</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">(<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime();</span><br><span class="line">(<span class="keyword">new</span> <span class="built_in">Date</span>).getTime();</span><br><span class="line"><span class="comment">// 获取当前的时间缀</span></span><br><span class="line"><span class="built_in">Date</span>.now();</span><br><span class="line"><span class="comment">// 日期显示转换为数字</span></span><br><span class="line">+<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br></pre></td></tr></table></figure><h4 id="使用-x-indexOf-39-y-39-来简化x-indexOf-39-y-39-gt"><a href="#使用-x-indexOf-39-y-39-来简化x-indexOf-39-y-39-gt" class="headerlink" title="使用~x.indexOf(&#39;y&#39;)来简化x.indexOf(&#39;y&#39;) &gt; -"></a>使用<code>~x.indexOf(&#39;y&#39;)</code>来简化<code>x.indexOf(&#39;y&#39;) &gt; -</code></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'hello world'</span>;</span><br><span class="line"><span class="keyword">if</span> (str.indexOf(<span class="string">'lo'</span>) &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (~str.indexOf(<span class="string">'lo'</span>)) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="parseInt-or-Number"><a href="#parseInt-or-Number" class="headerlink" title="parseInt() or Number()"></a><code>parseInt()</code> or <code>Number()</code></h4><p>两者的差别之处在于<strong>解析</strong>和<strong>转换</strong>两者之间的理解。</p><p>解析<strong>允许</strong>字符串中含有非数字字符，解析按从左到右的顺序，如果遇到非数字字符就停止。而转换<strong>不允许</strong>出现非数字字符，否者会失败并返回NaN。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">'520'</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="string">'520px'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>(a); <span class="comment">// 520</span></span><br><span class="line"><span class="built_in">parseInt</span>(a); <span class="comment">// 520</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>(b); <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(b); <span class="comment">// 520</span></span><br></pre></td></tr></table></figure><p><code>parseInt</code>方法第二个参数用于指定转换的基数，ES5默认为10进制。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">'10'</span>, <span class="number">2</span>); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'10'</span>, <span class="number">8</span>); <span class="comment">// 8</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'10'</span>, <span class="number">10</span>); <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'10'</span>, <span class="number">16</span>);  <span class="comment">// 16</span></span><br></pre></td></tr></table></figure><p>对于网上<code>parseInt(0.0000008)</code>的结果为什么为8，原因在于0.0000008转换成字符为”8e-7”，然后根据<code>parseInt</code>的解析规则自然得到”8”这个结果。</p><h4 id="拼接操作，-x-or-String-x-？"><a href="#拼接操作，-x-or-String-x-？" class="headerlink" title="+拼接操作，+x or String(x)？"></a><code>+</code>拼接操作，<code>+x</code> or <code>String(x)</code>？</h4><p>+运算符可用于数字加法，同时也可以用于字符串拼接。如果+的其中一个操作符是字符串(或者通过 隐式强制转换可以得到字符串)，则执行字符串拼接；否者执行数字加法。</p><p>需要注意的时对于数组而言，不能通过<code>valueOf()</code>方法得到简单基本类型值，于是转而调用<code>toString()</code>方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>] + [<span class="number">3</span>, <span class="number">4</span>]; <span class="comment">// "1,23,4"</span></span><br></pre></td></tr></table></figure><p>对于对象同样会先调用<code>valueOf()</code>方法，然后通过<code>toString()</code>方法返回对象的字符串表示。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;&#125;;</span><br><span class="line">a + <span class="number">123</span>; <span class="comment">// "[object Object]123"</span></span><br></pre></td></tr></table></figure><p>对于<code>a + &quot;&quot;</code>隐式转换和<code>String(a)</code>显示转换有一个细微的差别：<code>a + &#39;&#39;</code>会对a调用<code>valueOf()</code>方法，而<code>String()</code>直接调用<code>toString()</code>方法。大多数情况下我们不会考虑这个问题，除非真遇到。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a  = &#123;</span><br><span class="line">  valueOf: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">42</span>; &#125;,</span><br><span class="line">  toString: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">4</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a + <span class="string">''</span>; <span class="comment">// 42</span></span><br><span class="line"><span class="built_in">String</span>(a); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><h4 id="判断对象的实例"><a href="#判断对象的实例" class="headerlink" title="判断对象的实例"></a>判断对象的实例</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一: ES3</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!(<span class="keyword">this</span> <span class="keyword">instanceof</span> Person)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Person(name, age);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二: ES5</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span> <span class="keyword">instanceof</span> Person ? <span class="keyword">this</span> : <span class="built_in">Object</span>.create(Person.prototype);</span><br><span class="line">  self.name = name;</span><br><span class="line">  self.age = age;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法三：ES6</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">new</span>.target) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">'Peron must called with new'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="数据安全类型检查"><a href="#数据安全类型检查" class="headerlink" title="数据安全类型检查"></a>数据安全类型检查</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isObject</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(value).slice(<span class="number">8</span>, <span class="number">-1</span>) === <span class="string">'Object'</span><span class="string">';</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// 数组</span></span><br><span class="line"><span class="string">function isArray(value) &#123;</span></span><br><span class="line"><span class="string">  return Object.prototype.toString.call(value).slice(8, -1) === '</span><span class="built_in">Array</span><span class="string">';</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// 函数</span></span><br><span class="line"><span class="string">function isFunction(value) &#123;</span></span><br><span class="line"><span class="string">  return Object.prototype.toString.call(value).slice(8, -1) === '</span><span class="built_in">Function</span><span class="string">';</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="让数字的字面值看起来像对象"><a href="#让数字的字面值看起来像对象" class="headerlink" title="让数字的字面值看起来像对象"></a>让数字的字面值看起来像对象</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2.</span>toString(); <span class="comment">// Uncaught SyntaxError: Invalid or unexpected token</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>.toString(); <span class="comment">// 第二个点号可以正常解析</span></span><br><span class="line"><span class="number">2</span> .toString(); <span class="comment">// 注意点号前面的空格</span></span><br><span class="line">(<span class="number">2</span>).toString(); <span class="comment">// 2先被计算</span></span><br></pre></td></tr></table></figure><h4 id="对象可计算属性名-仅在ES6中"><a href="#对象可计算属性名-仅在ES6中" class="headerlink" title="对象可计算属性名(仅在ES6中)"></a>对象可计算属性名(仅在ES6中)</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> suffix = <span class="string">' name'</span>;</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  [<span class="string">'first'</span> + suffix]: <span class="string">'Nicholas'</span>,</span><br><span class="line">  [<span class="string">'last'</span> + suffix]: <span class="string">'Zakas'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">person[<span class="string">'first name'</span>]; <span class="comment">// "Nicholas"</span></span><br><span class="line">person[<span class="string">'last name'</span>]; <span class="comment">// "Zakas"</span></span><br></pre></td></tr></table></figure><h4 id="数字四舍五入"><a href="#数字四舍五入" class="headerlink" title="数字四舍五入"></a>数字四舍五入</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// v: 值，p: 精度</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">v, p</span>) </span>&#123;</span><br><span class="line">  p = <span class="built_in">Math</span>.pow(<span class="number">10</span>, p &gt;&gt;&gt; <span class="number">31</span> ? <span class="number">0</span> : p | <span class="number">0</span>)</span><br><span class="line">  v *= p;</span><br><span class="line">  <span class="keyword">return</span> (v + <span class="number">0.5</span> + (v &gt;&gt; <span class="number">31</span>) | <span class="number">0</span>) / p</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">round(<span class="number">123.45353</span>, <span class="number">2</span>); <span class="comment">// 123.45</span></span><br></pre></td></tr></table></figure><h4 id="在浏览器中根据url下载文件"><a href="#在浏览器中根据url下载文件" class="headerlink" title="在浏览器中根据url下载文件"></a>在浏览器中根据url下载文件</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">download</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> isChrome = navigator.userAgent.toLowerCase().indexOf(<span class="string">'chrome'</span>) &gt; <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">var</span> isSafari = navigator.userAgent.toLowerCase().indexOf(<span class="string">'safari'</span>) &gt; <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isChrome || isSafari) &#123;</span><br><span class="line">    <span class="keyword">var</span> link = <span class="built_in">document</span>.createElement(<span class="string">'a'</span>);</span><br><span class="line">    link.href = url;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (link.download !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> fileName = url.substring(url.lastIndexOf(<span class="string">'/'</span>) + <span class="number">1</span>, url.length);</span><br><span class="line">      link.download = fileName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">document</span>.createEvent) &#123;</span><br><span class="line">      <span class="keyword">var</span> e = <span class="built_in">document</span>.createEvent(<span class="string">'MouseEvents'</span>);</span><br><span class="line">      e.initEvent(<span class="string">'click'</span>, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line">      link.dispatchEvent(e);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (url.indexOf(<span class="string">'?'</span>) === <span class="number">-1</span>) &#123;</span><br><span class="line">    url += <span class="string">'?download'</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">window</span>.open(url, <span class="string">'_self'</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="快速生成UUID"><a href="#快速生成UUID" class="headerlink" title="快速生成UUID"></a>快速生成UUID</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">uuid</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">  <span class="keyword">var</span> uuid = <span class="string">'xxxxxxxxxxxx-4xxx-yxxx-xxxxxxxxxxxx'</span>.replace(<span class="regexp">/[xy]/g</span>, <span class="function"><span class="keyword">function</span>(<span class="params">c</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> r = (d + <span class="built_in">Math</span>.random() * <span class="number">16</span>) % <span class="number">16</span> | <span class="number">0</span>;</span><br><span class="line">    d = <span class="built_in">Math</span>.floor(d / <span class="number">16</span>);</span><br><span class="line">    <span class="keyword">return</span> (c == <span class="string">'x'</span> ? r : (r &amp; <span class="number">0x3</span> | <span class="number">0x8</span>)).toString(<span class="number">16</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> uuid;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">uuid(); <span class="comment">// "33f7f26656cb-499b-b73e-89a921a59ba6"</span></span><br></pre></td></tr></table></figure><h4 id="JavaScript浮点数精度问题"><a href="#JavaScript浮点数精度问题" class="headerlink" title="JavaScript浮点数精度问题"></a>JavaScript浮点数精度问题</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isEqual</span>(<span class="params">n1, n2, epsilon</span>) </span>&#123;</span><br><span class="line">  epsilon = epsilon == <span class="literal">undefined</span> ? <span class="number">10</span> : epsilon; <span class="comment">// 默认精度为10</span></span><br><span class="line">  <span class="keyword">return</span> n1.toFixed(epsilon) === n2.toFixed(epsilon);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">0.1</span> + <span class="number">0.2</span>; <span class="comment">// 0.30000000000000004</span></span><br><span class="line">isEqual(<span class="number">0.1</span> + <span class="number">0.2</span>, <span class="number">0.3</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="number">0.7</span> + <span class="number">0.1</span> + <span class="number">99.1</span> + <span class="number">0.1</span>; <span class="comment">// 99.99999999999999</span></span><br><span class="line">isEqual(<span class="number">0.7</span> + <span class="number">0.1</span> + <span class="number">99.1</span> + <span class="number">0.1</span>, <span class="number">100</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h4 id="格式化表单数据"><a href="#格式化表单数据" class="headerlink" title="格式化表单数据"></a>格式化表单数据</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">formatParam</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> query = <span class="string">''</span>, name, value, fullSubName, subName, subValue, innerObj, i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(name <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    value = obj[name];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(value <span class="keyword">instanceof</span> <span class="built_in">Array</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;value.length; ++i) &#123;</span><br><span class="line">        subValue = value[i];</span><br><span class="line">        fullSubName = name + <span class="string">'['</span> + i + <span class="string">']'</span>;</span><br><span class="line">        innerObj = &#123;&#125;;</span><br><span class="line">        innerObj[fullSubName] = subValue;</span><br><span class="line">        query += formatParam(innerObj) + <span class="string">'&amp;'</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(value <span class="keyword">instanceof</span> <span class="built_in">Object</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span>(subName <span class="keyword">in</span> value) &#123;</span><br><span class="line">        subValue = value[subName];</span><br><span class="line">        fullSubName = name + <span class="string">'['</span> + subName + <span class="string">']'</span>;</span><br><span class="line">        innerObj = &#123;&#125;;</span><br><span class="line">        innerObj[fullSubName] = subValue;</span><br><span class="line">        query += formatParam(innerObj) + <span class="string">'&amp;'</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(value !== <span class="literal">undefined</span> &amp;&amp; value !== <span class="literal">null</span>)</span><br><span class="line">      query += <span class="built_in">encodeURIComponent</span>(name) + <span class="string">'='</span> + <span class="built_in">encodeURIComponent</span>(value) + <span class="string">'&amp;'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> query.length ? query.substr(<span class="number">0</span>, query.length - <span class="number">1</span>) : query;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> param = &#123;</span><br><span class="line">  name: <span class="string">'jenemy'</span>,</span><br><span class="line">  likes: [<span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>],</span><br><span class="line">  memberCard: [</span><br><span class="line">    &#123; <span class="attr">title</span>: <span class="string">'1'</span>, <span class="attr">id</span>: <span class="number">1</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">title</span>: <span class="string">'2'</span>, <span class="attr">id</span>: <span class="number">2</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">formatParam(param); <span class="comment">// "name=12&amp;likes%5B0%5D=0&amp;likes%5B1%5D=1&amp;likes%5B2%5D=3&amp;memberCard%5B0%5D%5Btitle%5D=1&amp;memberCard%5B0%5D%5Bid%5D=1&amp;memberCard%5B1%5D%5Btitle%5D=2&amp;memberCard%5B1%5D%5Bid%5D=2"</span></span><br></pre></td></tr></table></figure><h4 id="创建指定长度非空数组"><a href="#创建指定长度非空数组" class="headerlink" title="创建指定长度非空数组"></a>创建指定长度非空数组</h4><p>在JavaScript中可以通过<code>new Array(3)</code>的形式创建一个长度为3的空数组。在老的Chrome中其值为[undefined x 3]，在最新的Chrome中为[empty x 3]，即空单元数组。在老Chrome中，相当于显示使用<code>[undefined, undefined, undefined]</code>的方式创建长度为3的数组。</p><p>但是，两者在调用<code>map()</code>方法的结果是明显不同的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">var</span> b = [<span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>];</span><br><span class="line"></span><br><span class="line">a.map(<span class="function">(<span class="params">v, i</span>) =&gt;</span> i); <span class="comment">// [empty × 3]</span></span><br><span class="line">b.map(<span class="function">(<span class="params">v, i</span>) =&gt;</span> i); <span class="comment">// [0, 1, 2]</span></span><br></pre></td></tr></table></figure><p>多数情况我们期望创建的是包含<code>undefined</code>值的指定长度的空数组，可以通过下面这种方法来达到目的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="built_in">Array</span>.apply(<span class="literal">null</span>, &#123; <span class="attr">length</span>: <span class="number">3</span> &#125;);</span><br><span class="line"></span><br><span class="line">a; <span class="comment">// [undefined, undefined, undefined]</span></span><br><span class="line">a.map(<span class="function">(<span class="params">v, i</span>) =&gt;</span> i); <span class="comment">// [0, 1, 2]</span></span><br></pre></td></tr></table></figure><p>总之，尽量不要创建和使用空单元数组。</p><h4 id="debounce方法"><a href="#debounce方法" class="headerlink" title="debounce方法"></a>debounce方法</h4><p><code>debounce()</code>方法用来延迟执行函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> debounce = <span class="function"><span class="keyword">function</span> (<span class="params">func, threshold, execAsap</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> timeout;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">debounced</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> obj = <span class="keyword">this</span>, args = <span class="built_in">arguments</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">delayed</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (!execAsap)</span><br><span class="line">        func.apply(obj, args);</span><br><span class="line">      timeout = <span class="literal">null</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (timeout)</span><br><span class="line">      clearTimeout(timeout);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (execAsap)</span><br><span class="line">      func.apply(obj, args);</span><br><span class="line"></span><br><span class="line">    timeout = setTimeout(delayed, threshold || <span class="number">100</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="判断客户端"><a href="#判断客户端" class="headerlink" title="判断客户端"></a>判断客户端</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> browser = &#123;</span><br><span class="line">    v: (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> u = navigator.userAgent,</span><br><span class="line">            app = navigator.appVersion,</span><br><span class="line">            p = navigator.platform;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            trident: u.indexOf(<span class="string">'Trident'</span>) &gt; <span class="number">-1</span>, <span class="comment">//IE内核</span></span><br><span class="line">            presto: u.indexOf(<span class="string">'Presto'</span>) &gt; <span class="number">-1</span>, <span class="comment">//opera内核</span></span><br><span class="line">            webKit: u.indexOf(<span class="string">'AppleWebKit'</span>) &gt; <span class="number">-1</span>, <span class="comment">//苹果、谷歌内核</span></span><br><span class="line">            gecko: u.indexOf(<span class="string">'Gecko'</span>) &gt; <span class="number">-1</span> &amp;&amp; u.indexOf(<span class="string">'KHTML'</span>) == <span class="number">-1</span>, <span class="comment">//火狐内核</span></span><br><span class="line">            mobile: !!u.match(<span class="regexp">/AppleWebKit.*Mobile.*/</span>), <span class="comment">//是否为移动终端</span></span><br><span class="line">            ios: !!u.match(<span class="regexp">/i[^;]+;( U;)? CPU.+Mac OS X/</span>), <span class="comment">//ios终端</span></span><br><span class="line">            android: u.indexOf(<span class="string">'Android'</span>) &gt; <span class="number">-1</span> || u.indexOf(<span class="string">'Linux'</span>) &gt; <span class="number">-1</span>, <span class="comment">//android终端或uc浏览器</span></span><br><span class="line">            iPhone: u.indexOf(<span class="string">'iPhone'</span>) &gt; <span class="number">-1</span>, <span class="comment">//是否为iPhone或者QQHD浏览器</span></span><br><span class="line">            iPad: u.indexOf(<span class="string">'iPad'</span>) &gt; <span class="number">-1</span>, <span class="comment">//是否iPad</span></span><br><span class="line">            weixin: u.indexOf(<span class="string">'MicroMessenger'</span>) &gt; <span class="number">-1</span>, <span class="comment">//是否微信</span></span><br><span class="line">            webApp: u.indexOf(<span class="string">'Safari'</span>) == <span class="number">-1</span>, <span class="comment">//是否web应该程序，没有头部与底部</span></span><br><span class="line">            UCB: u.match(<span class="regexp">/UCBrowser/i</span>) == <span class="string">"UCBrowser"</span>,</span><br><span class="line">            QQB: u.match(<span class="regexp">/MQQBrowser/i</span>) == <span class="string">"MQQBrowser"</span>,</span><br><span class="line">            win: p.indexOf(<span class="string">'Win'</span>) &gt; <span class="number">-1</span>, <span class="comment">//判断是否是WIN操作系统</span></span><br><span class="line">            mac: p.indexOf(<span class="string">'Mac'</span>) &gt; <span class="number">-1</span> <span class="comment">//判断是否是Mac操作系统</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;)()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;浮点数取整&quot;&gt;&lt;a href=&quot;#浮点数取整&quot; class=&quot;headerlink&quot; title=&quot;浮点数取整&quot;&gt;&lt;/a&gt;浮点数取整&lt;/h4&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; x = &lt;span class=&quot;number&quot;&gt;123.4545&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;x &amp;gt;&amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// 123&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;~~x; &lt;span class=&quot;comment&quot;&gt;// 123&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;x | &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// 123&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;Math&lt;/span&gt;.floor(x); &lt;span class=&quot;comment&quot;&gt;// 123&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;blockquote&gt;
&lt;p&gt;注意：前三种方法只适用于32个位整数，对于负数的处理上和 Math.floor是不同的。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://csjiabin.github.io/categories/JavaScript/"/>
    
    
      <category term="js" scheme="https://csjiabin.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>用图标和示例解释Await和Async</title>
    <link href="https://csjiabin.github.io/2018/08/18/%E7%94%A8%E5%9B%BE%E6%A0%87%E5%92%8C%E7%A4%BA%E4%BE%8B%E8%A7%A3%E9%87%8AAwait%E5%92%8CAsync/"/>
    <id>https://csjiabin.github.io/2018/08/18/%E7%94%A8%E5%9B%BE%E6%A0%87%E5%92%8C%E7%A4%BA%E4%BE%8B%E8%A7%A3%E9%87%8AAwait%E5%92%8CAsync/</id>
    <published>2018-08-18T12:58:31.000Z</published>
    <updated>2020-11-02T09:26:56.677Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>JavaScript ES7 中的 async / await 让多个异步 promise 协同工作起来更容易。如果要按一定顺序从多个数据库或者 API 异步获取数据，你可能会以一堆乱七八糟的 promise 和回调函数而告终。而 async / await 结构让我们能用可读性强、易维护的代码更加简洁地实现这些逻辑。</p><p>本教程用图表和简单示例讲解了 JavaScript 中 async / await 的语法和语义。</p><p>在深入之前，我们先简单回顾一下 promise. 如果你已经对 JS 的 promise 有所了解，可放心大胆地跳过这一部分。</p><h2 id="Promises"><a href="#Promises" class="headerlink" title="Promises"></a>Promises</h2><p>在 JavaScript 中，promise 代表非阻塞异步执行的抽象概念。如果你熟悉 Java 的 Future、C# 的 Task, 你会发现 promise 跟它们很像。</p><p>Promise 一般用于网络和 I/O 操作，比如读取文件，或者创建 HTTP 请求。我们可以创建异步 promise，然后用 then 添加一个回调函数，当 promise 结束后会触发这个回调函数，而非阻塞住当前“线程”。回调函数本身也可以返回一个 promise 对象，所以我们能够链式调用 promise。</p><p>为了简单起见，我们假设后面所有示例都已经像这样安装并加载了 request-promise 类库：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rp = <span class="built_in">require</span>(<span class="string">"request-promise"</span>);</span><br></pre></td></tr></table></figure><p>现在我们就可以像这样创建一个返回 promise 对象的简易 HTTP GET 请求：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = rp(<span class="string">"http://example.com/"</span>);</span><br></pre></td></tr></table></figure><p>我们现在来看个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">"Starting Execution"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promise = rp(<span class="string">"http://example.com/"</span>);</span><br><span class="line">promise.then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result));</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"Can't know if promise has finished yet..."</span>);</span><br></pre></td></tr></table></figure><p>我们在第 3 行创建了一个 promise 对象，在第 4 行给它加了个回调函数。Promise 是异步的，所以当执行到第 6 行时，我们并不知道 promise 是否已完成。如果把段这代码多执行几次，可能每次都得到不同的结果。一般地说，就是 promise 创建后的代码和 promise 是同时运行的。</p><p>直到 promise 执行完，才有办法阻塞当前操作序列。这不同于 Java 的 Future.get, 它让我们能够在 Future 结束之前就阻塞当前线程。对于 JavaScript，我们没法等待 promise 执行完。在 promise 后面编排代码的唯一方法是用 then 给它添加回调函数。</p><p>下图描述了本例的计算过程：</p><p><img data-src="/uploads/post/post-async-await-0.jpg" alt=""></p><p>Promise 的计算过程。正在执行的“线程”无法等待 promise 执行完成。在 promise 后面编排代码的唯一方法是用 then 给它添加回调函数。</p><p>通过 then 添加的回调函数只有当 promise 成功时才会执行。如果它失败了（比如由于网络错误），回调函数不会执行。你可以用 catch 再附加一个回调函数来处理失败的 promise:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rp(<span class="string">"http://example.com/"</span>)</span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">"Success"</span>))</span><br><span class="line">  .catch(<span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`Failed: <span class="subst">$&#123;e&#125;</span>`</span>));</span><br></pre></td></tr></table></figure><p>最后，为了测试，我们可以用 Promise.resolve 和 Promise.reject 很容易地创建执行成功或失败的“傻瓜” promise:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> success = <span class="built_in">Promise</span>.resolve(<span class="string">"Resolved"</span>);</span><br><span class="line"><span class="comment">// 打印 "Successful result: Resolved"</span></span><br><span class="line">success</span><br><span class="line">  .then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`Successful result: <span class="subst">$&#123;result&#125;</span>`</span>))</span><br><span class="line">  .catch(<span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`Failed with: <span class="subst">$&#123;e&#125;</span>`</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fail = <span class="built_in">Promise</span>.reject(<span class="string">"Err"</span>);</span><br><span class="line"><span class="comment">// 打印 "Failed with: Err"</span></span><br><span class="line">fail</span><br><span class="line">  .then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`Successful result: <span class="subst">$&#123;result&#125;</span>`</span>))</span><br><span class="line">  .catch(<span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`Failed with: <span class="subst">$&#123;e&#125;</span>`</span>));</span><br></pre></td></tr></table></figure><p>想要更详细的 promise 教程，可以参考这篇文章。</p><h2 id="问题来了——组合-promise"><a href="#问题来了——组合-promise" class="headerlink" title="问题来了——组合 promise"></a>问题来了——组合 promise</h2><p>只用一个 promise 很容易搞定。但是，当需要针对复杂异步逻辑编程时，我们很可能最后要同时用好几个 promise 对象。写一堆 then 语句和匿名回调很容易搞得难以控制。</p><p>例如，假设我们需要编程解决如下需求：</p><ol><li>创建 HTTP 请求，等待请求结束并打印出结果；</li><li>再创建两个并行 HTTP 请求；</li><li>等这两个请求结束后，打印出它们的结果。</li></ol><p>下面这段代码示范了如何解决此问题：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一次调用</span></span><br><span class="line"><span class="keyword">const</span> call1Promise = rp(<span class="string">"http://example.com/"</span>);</span><br><span class="line"></span><br><span class="line">call1Promise</span><br><span class="line">  .then(<span class="function"><span class="params">result1</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 第一个请求完成后会执行</span></span><br><span class="line">    <span class="built_in">console</span>.log(result1);</span><br><span class="line">    <span class="keyword">const</span> call2Promise = rp(<span class="string">"http://example.com/"</span>);</span><br><span class="line">    <span class="keyword">const</span> call3Promise = rp(<span class="string">"http://example.com/"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.all([call2Promise, call3Promise]);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">arr</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 两个 promise 都结束后会执行</span></span><br><span class="line">    <span class="built_in">console</span>.log(arr[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">console</span>.log(arr[<span class="number">1</span>]);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>我们开头创建了第一个 HTTP 请求，并且加了个完成时候运行的回调（1-3 行）。在这个回调函数里，我们为随后的 HTTP 请求创建了另外两个 promise（8-9 行）。这两个 promise 同时执行，我们需要加一个能等它们都完成后才执行的回调函数。因此，我们需要用 Promise.all 将它们组合到同一个 promise 中（11 行），它们都结束后这个 promise 才算完成。这个回调返回的是 promise 对象，所以我们要再加一个 then 回调函数来打印结果（12-16 行）。</p><p>下图描述了这一计算流程：</p><p><img data-src="/uploads/post/post-async-await-1.jpg" alt=""></p><p>Promise 组合的计算过程。我们用 Promise.all 将两个并行的 promise 组合到一个 promise 中。</p><p>对于这个简单的例子，我们最后用了两个 then 回调方法，并且不得不用 Promise.all 来让两个并行的 promise 同时执行。如果我们必须执行更多异步操作，或者加上错误处理会怎么样呢？这种方法最后很容易产生一堆乱七八糟的 then, Promise.all 和回调函数。</p><h2 id="Async-方法"><a href="#Async-方法" class="headerlink" title="Async 方法"></a>Async 方法</h2><p>Async 是定义返回 promise 对象函数的快捷方法。</p><p>例如，下面这两种定义是等价的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="string">"TEST"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// asyncF 和 f 是等价的</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncF</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"TEST"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类似地，抛出异常的 async 方法等价于返回拒绝 promise 的方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="string">"Error"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// asyncF 和 f 是等价的</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncF</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="string">"Error"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Await"><a href="#Await" class="headerlink" title="Await"></a>Await</h2><p>我们创建了 promise 但不能同步等待它执行完成。我们只能通过 then 传一个回调函数。不允许等待 promise 是为了鼓励开发非阻塞代码。否则，开发者们总会忍不住执行阻塞操作，因为那比使用 promise 和回调更简单。</p><p>然而，为了让 promise 能同步执行，我们需要让他们等待彼此完成。换句话说，如果一个操作是异步的（即封装在 promise 中），它应该能够等待另一个异步操作执行完。但是 JavaScript 解释器怎么能知道一个操作是否在 promise 中运行呢？</p><p>答案就在 async 这个关键词中。每个 async 方法都返回一个 promise 对象。因此，JavaScript 解释器就明白所有 async 方法中的操作都被封装在 promise 里异步执行。所以解释器能够允许它们等待其他 promise 执行完。</p><p>下面引入 await 关键词。它只能被用在 async 方法中，让我们能同步等待 promise 执行完。如果在 async 函数外使用 promise, 我们仍然需要用 then 回调函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// response 就是 promise 执行成功的值</span></span><br><span class="line">  <span class="keyword">const</span> response = <span class="keyword">await</span> rp(<span class="string">"http://example.com/"</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(response);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不能在 async 方法外面用 await</span></span><br><span class="line"><span class="comment">// 需要使用 then 回调函数……</span></span><br><span class="line">f().then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">"Finished"</span>));</span><br></pre></td></tr></table></figure><p>现在我们来看如何解决上一节的问题：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将解决方法封装到 async 函数中</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">solution</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 等待第一个 HTTP 请求并打印出结果</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">await</span> rp(<span class="string">"http://example.com/"</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建两个 HTTP 请求，不等它们执行完 —— 让他们同时执行</span></span><br><span class="line">  <span class="keyword">const</span> call2Promise = rp(<span class="string">"http://example.com/"</span>); <span class="comment">// Does not wait!</span></span><br><span class="line">  <span class="keyword">const</span> call3Promise = rp(<span class="string">"http://example.com/"</span>); <span class="comment">// Does not wait!</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建完以后 —— 等待它们都执行完</span></span><br><span class="line">  <span class="keyword">const</span> response2 = <span class="keyword">await</span> call2Promise;</span><br><span class="line">  <span class="keyword">const</span> response3 = <span class="keyword">await</span> call3Promise;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(response2);</span><br><span class="line">  <span class="built_in">console</span>.log(response3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用这一 async 函数</span></span><br><span class="line">solution().then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">"Finished"</span>));</span><br></pre></td></tr></table></figure><p>上面这段代码中，我们把解决方法封装到 async 函数中。这让我们能直接对里面的 promise 使用 await 关键字，所以不再需要使用 then 回调函数。最后，调用这个 async 函数，它简单地创建了一个 promise 对象, 这个 promise 封装了调用其他 promise 的逻辑。</p><p>当然，在第一个例子（没有用 async / await）中，两个 promise 会被同时触发。这段代码也一样（7-8 行）。注意，直到第 11-12 行我们才使用 await, 将程序一直阻塞到两个 promise 执行完成。然后我们就能断定上例中两个 promise 都成功执行了（和使用 Promise.all(…).then(…) 类似）。</p><p>这背后的计算过程跟上一节给出的基本相当。但是代码可读性更强、更易于理解。</p><p>实际上，async / await 在底层转换成了 promise 和 then 回调函数。也就是说，这是使用 promise 的语法糖。每次我们使用 await, 解释器都创建一个 promise 对象，然后把剩下的 async 函数中的操作放到 then 回调函数中。</p><p>我们再看看下面的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Starting F"</span>);</span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">await</span> rp(<span class="string">"http://example.com/"</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面给出了函数 f 底层运算过程。由于 f 是 async 的，所以它会跟它的调用方同时执行：</p><p><img data-src="/uploads/post/post-async-await-2.jpg" alt=""></p><div style="text-align:center;">Await 的计算过程</div><p>函数 f 开始运行并创建了一个 promise 对象。就在那一刻，函数中剩下的部分被封装到一个回调函数中，并在 promise 结束后执行。</p><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>前面大部分例子中，我们都假设 promise 执行成功。因此在 promise 上使用 await 会返回值。如果我们进行 await 的 promise 失败了，async 函数就会发生异常。我们可以用标准的 try / catch 来处理这种情况：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> promiseResult = <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">"Error"</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Async 函数不会处理异常，不管异常是由拒绝的 promise 还是其他 bug 引起的，它都会返回一个拒绝 promise:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Throws an exception</span></span><br><span class="line">  <span class="keyword">const</span> promiseResult = <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">"Error"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Will print "Error"</span></span><br><span class="line">f()</span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">"Success"</span>))</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(err));</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">g</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="string">"Error"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Will print "Error"</span></span><br><span class="line">g()</span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">"Success"</span>))</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(err));</span><br></pre></td></tr></table></figure><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>Async / await 是让 promise 更完美的语言结构。它让我们能用更少的代码使用 promise. 然而，async / await 并没有取代普通 promise. 例如，如果在普通函数中或者全局范围内调用 async 函数，我们就没办法使用 await 而要依赖于普通 promise:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fAsync</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// actual return value is Promise.resolve(5)</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// can't call "await fAsync()". Need to use then/catch</span></span><br><span class="line">fAsync().then(<span class="function"><span class="params">r</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`result is <span class="subst">$&#123;r&#125;</span>`</span>));</span><br></pre></td></tr></table></figure><p>我通常会将大部分异步逻辑封装到一个或者几个 async 函数中，然后在非异步代码中调用。这让我尽可能少地写 try / catch 回调。</p><p>Async / await 结构是让使用 promise 更简练的语法糖。每一个 async / await 结构都可以写成普通 promise. 归根结底，这是一个编码风格和简洁的问题。</p><p>关于说明并发和并行有区别的资料，可以查看 Rob Pike 关于这个问题的讨论，或者我这篇文章。并发是指将独立进程（通常意义上的进程）组合在一起工作，而并行是指真正同时处理多个任务。并发关乎应用设计和架构，而并行关乎实实在在的执行。</p><p>我们拿一个多线程应用来举例。应用程序分离成线程明确了它的并发模型。这些线程在可用内核上的映射定义了其级别或并行性。并发系统可以在单个处理器上高效运行，在这种情况下，它并不是并行的。</p><p><img data-src="/uploads/post/post-async-await-3.jpg" alt=""></p><h2 id="并发-VS-并行"><a href="#并发-VS-并行" class="headerlink" title="并发 VS 并行"></a>并发 VS 并行</h2><p>从这个意义上说，promise 让我们能够将程序分解成并发模块，这些模块可能会也可能不会并行执行。Javascript 实际否并行执行取决于具体实现方法。例如，Node JS 是单线程的，如果 promise 是计算密集型（CPU bound）那就不会有并行处理。但是，如果你用 Nashorn 之类的东西把代码编译成 java 字节码，理论上可能能够将计算密集型的 promise 映射到不同 CPU 核上，从而达到并行效果。所以我认为，promise（不管是普通的还是用了 async / await 的）组成了 JavaScript 应用的并发模块。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;JavaScript ES7 中的 async / await 让多个异步 promise 协同工作起来更容易。如果要按一定顺序从多个数据库或者 API 异步获取数据，你可能会以一堆乱七八糟的 promise 和回调函数而告终。而 async / await 结构让我们能用可读性强、易维护的代码更加简洁地实现这些逻辑。&lt;/p&gt;
&lt;p&gt;本教程用图表和简单示例讲解了 JavaScript 中 async / await 的语法和语义。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://csjiabin.github.io/categories/JavaScript/"/>
    
    
      <category term="js" scheme="https://csjiabin.github.io/tags/js/"/>
    
      <category term="es7" scheme="https://csjiabin.github.io/tags/es7/"/>
    
      <category term="promise" scheme="https://csjiabin.github.io/tags/promise/"/>
    
  </entry>
  
  <entry>
    <title>Hexo,创建属于你自己的博客</title>
    <link href="https://csjiabin.github.io/2018/08/16/Hexo-%E5%88%9B%E5%BB%BA%E5%B1%9E%E4%BA%8E%E4%BD%A0%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/"/>
    <id>https://csjiabin.github.io/2018/08/16/Hexo-%E5%88%9B%E5%BB%BA%E5%B1%9E%E4%BA%8E%E4%BD%A0%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/</id>
    <published>2018-08-16T14:58:09.000Z</published>
    <updated>2020-11-02T09:26:56.672Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>欢迎来到 Hexo！该文章非常适合不懂前端的人搭建自己的博客，接下来我会讲解我为什么会选择<code>hexo</code>和<code>hexo</code>博客搭建步奏。最近想要搞个个人博客，因为不想自己搞站点，所以找到了<code>github pages</code>，它提供给我们域名和空间，多省事啊。那静态页面用什么工具呢？一开始我用的是<code>jekyll</code>,然后我有了那句经典的感受，那句话是从入门到放弃，啊，多么痛的领悟！</p><h4 id="下面我来扒一扒："><a href="#下面我来扒一扒：" class="headerlink" title="下面我来扒一扒："></a>下面我来扒一扒：</h4><ol><li><code>jekyll</code>需要安装<code>ruby</code>,<code>python</code>等，<code>hexo</code>需要<code>nodejs</code>，当然为了 push 到 github 都需要装个<code>git</code>,速度上<code>jekyll</code>生成静态站点的速度比<code>hexo</code>慢多了，如果你时间多。</li><li>便捷性，<code>hexo</code>完爆<code>jekyll</code>，同样是 quick start，虽然都是几个命令，就可以预览效果了，但是效果差了十万八千里。</li><li>插件和样式，你写完 post，想做个 categories？对于<code>hexo</code>就是 so easy，在你的文章前面的使用 category: 分类名，<code>hexo</code>就给你在右边生成，包括分类主页，默认样式，你啥都不用干。而<code>jekyll</code>需要自己写标签语言遍历然后在创建各个分类的主页，在设置页面 css，或者用 ruby 写插件去搞，这下老子要骂娘了，我他妈根本不会 ruby 啊，官方为什么不主动提供好现成的插件？我只是个后端工程师，不是全栈，页面+css 真的玩不来，不知道提供些 theme 供人选择？</li></ol><blockquote><p>废话不多说，接下来会以我的博客为例子搭建一个 hexo 的 github pages！</p></blockquote><h3 id="Hexo-相关命令总结"><a href="#Hexo-相关命令总结" class="headerlink" title="Hexo 相关命令总结"></a>Hexo 相关命令总结</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">hexo init <span class="comment">#初始化一个项目</span></span><br><span class="line"></span><br><span class="line">hexo new page <span class="string">"xxx"</span> <span class="comment">#生成页面</span></span><br><span class="line"></span><br><span class="line">hexo new <span class="string">""</span> <span class="comment">#生成文章</span></span><br><span class="line"></span><br><span class="line">hexo clean <span class="comment">#清除缓存</span></span><br><span class="line"></span><br><span class="line">hexo s  <span class="comment">#启动本地服务</span></span><br><span class="line"></span><br><span class="line">hexo g  <span class="comment">#保存修改，生成文件</span></span><br><span class="line"></span><br><span class="line">hexo d  <span class="comment">#发布到远程</span></span><br><span class="line"></span><br><span class="line">npm install --save xxx  <span class="comment">#安装插件</span></span><br><span class="line"></span><br><span class="line">npm unstall xxx <span class="comment">#卸载插件</span></span><br></pre></td></tr></table></figure><p>上述命令将贯穿于整个博客过程，不难，能动手尽量别复制粘贴</p><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>安装 Hexo 相当简单。然而在安装前，您必须检查电脑中是否已安装下列应用程序：</p><ul><li><a href="http://nodejs.org/" target="_blank" rel="noopener">Node.js</a></li><li><a href="http://git-scm.com/" target="_blank" rel="noopener">Git</a></li></ul><p>如果您的电脑中已经安装上述必备程序，那么恭喜您！接下来只需要使用 npm 即可完成 Hexo 的安装。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>如果您的电脑中尚未安装所需要的程序，请根据以下安装指示完成安装。</p><h4 id="安装-Git"><a href="#安装-Git" class="headerlink" title="安装 Git"></a>安装 Git</h4><ul><li>Windows：下载并安装 <a href="https://git-scm.com/download/win" target="_blank" rel="noopener">git</a>.</li><li>Mac：使用 <a href="http://mxcl.github.com/homebrew/" target="_blank" rel="noopener">Homebrew</a>, <a href="http://www.macports.org/" target="_blank" rel="noopener">MacPorts</a> ：<code>brew install git</code>;或下载 <a href="http://sourceforge.net/projects/git-osx-installer/" target="_blank" rel="noopener">安装程序</a> 安装。</li><li>Linux (Ubuntu, Debian)：<code>sudo apt-get install git-core</code></li><li>Linux (Fedora, Red Hat, CentOS)：<code>sudo yum install git-core</code></li></ul><h4 id="安装-Node-js"><a href="#安装-Node-js" class="headerlink" title="安装 Node.js"></a>安装 Node.js</h4><p>安装 Node.js 的最佳方式是使用 <a href="https://github.com/creationix/nvm" target="_blank" rel="noopener">nvm</a>。</p><p>cURL:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl https://raw.github.com/creationix/nvm/master/install.sh | sh</span><br></pre></td></tr></table></figure><p>Wget:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -qO- https://raw.github.com/creationix/nvm/master/install.sh | sh</span><br></pre></td></tr></table></figure><p>安装完成后，重启终端并执行下列命令即可安装 Node.js。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm install stable</span><br></pre></td></tr></table></figure><p>或者您也可以下载 <a href="http://nodejs.org/" target="_blank" rel="noopener">安装程序</a> 来安装。</p><blockquote><p><strong>Windows 用户</strong><br>对于 windows 用户来说，建议使用安装程序进行安装。安装时，请勾选<strong>Add to PATH</strong>选项。<br>另外，您也可以使用<strong>Git Bash</strong>，这是 git for windows 自带的一组程序，提供了 Linux 风格的 shell，在该环境下，您可以直接用上面提到的命令来安装 Node.js。打开它的方法很简单，在任意位置单击右键，选择“Git Bash Here”即可。由于 Hexo 的很多操作都涉及到命令行，您可以考虑始终使用<strong>Git Bash</strong>来进行操作。</p></blockquote><h4 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h4><p>所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>在这里以<a href="/hux/">HUX 博客</a>主题为例子(也可以按 hexo 官方文档进行搭建)，移植的主题 <a href="https://github.com/Huxpro/huxpro.github.io" target="_blank" rel="noopener">Hux Blog</a>，我为了您的方便而发布整个项目，因此您只需按照下面的说明操作，即可轻松自定义您自己的博客！ 让我们开始！！！</p><ul><li><a href="https://csjiabin.github.io/example/hux"><strong>预览地址</strong></a></li></ul><p><img data-src="/uploads/post/WX20180826-004151@2x.png" alt=""></p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/csjiabin/hexo-theme-hux.git</span><br><span class="line"><span class="built_in">cd</span> hexo-theme-hux</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><h4 id="站点配置"><a href="#站点配置" class="headerlink" title="站点配置"></a>站点配置</h4><p>你可以通用修改 <code>_config.yml</code> 文件来轻松的开始搭建自己的博客:</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="string">xxx</span> <span class="comment"># 博客名，站点名称</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">xxx</span> <span class="comment"># 博客作者名字 #</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">xxx</span> <span class="comment"># 对站点的描述，搜索引擎会抓取，可以自定义</span></span><br><span class="line"><span class="attr">keyword:</span> <span class="string">xxx</span> <span class="comment"># 向搜索引擎说明你的网页的关键词</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">huxblog</span> <span class="comment"># themes目录下的主题目录</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 您可以决定是否显示侧边栏</span></span><br><span class="line"><span class="comment"># Sidebar settings</span></span><br><span class="line"><span class="attr">sidebar:</span> <span class="literal">true</span> <span class="comment"># whether or not using Sidebar.</span></span><br><span class="line"><span class="attr">sidebar-about-description:</span> <span class="string">"Goals determine what you going to be!!"</span></span><br><span class="line"><span class="attr">sidebar-avatar:</span> <span class="string">https://avatars1.githubusercontent.com/u/20592953?s=460&amp;v=4</span> <span class="comment"># use absolute URL, seeing it's used in both `/` and `/about/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 您可以决定是否显示帖子标签。</span></span><br><span class="line"><span class="comment"># Featured Tags</span></span><br><span class="line"><span class="attr">featured-tags:</span> <span class="literal">true</span> <span class="comment"># whether or not using Feature-Tags</span></span><br></pre></td></tr></table></figure><h4 id="撰写博文"><a href="#撰写博文" class="headerlink" title="撰写博文"></a>撰写博文</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new post &lt;post name&gt;  <span class="comment"># 或者`hexo new &lt;post name&gt;`生成文章</span></span><br></pre></td></tr></table></figure><p>要发表的文章一般以 <code>Markdown</code> 的格式放在这里<code>_posts/</code>，你只要看看这篇模板里的文章你就立刻明白该如何设置。</p><blockquote><p>不同<code>Markdown</code>格式语法的可以看这篇 <a href="/2018/08/26/Markdown%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/">文章 &rarr;</a></p></blockquote><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="string">"&lt;post name&gt;"</span></span><br><span class="line"><span class="attr">catalog:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">CSjiabin</span></span><br><span class="line"><span class="attr">header-img:</span> <span class="string">/img/home-bg.jpg</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2018</span><span class="number">-08</span><span class="number">-16</span> <span class="number">22</span><span class="string">:58:09</span></span><br><span class="line"><span class="attr">tags:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">hexo</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><p>启动本地服务调试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s --debug</span><br></pre></td></tr></table></figure><blockquote><p>–debug 调试模式，会监听文件的变动进行重启，但不会监听最外层的<code>_config.yml</code>文件</p></blockquote><h4 id="开启评论功能"><a href="#开启评论功能" class="headerlink" title="开启评论功能"></a>开启评论功能</h4><ul><li>首先，你需要去注册一个 Disqus 帐号。不要直接使用我的啊！</li><li>其次，你只需要在下面的 <code>_config.yml</code> 文件中设置一下就可以了。</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 评论系统</span></span><br><span class="line"><span class="comment"># Disqus（https://disqus.com/)</span></span><br><span class="line"><span class="attr">disqus_username:</span> <span class="string">csjiabin</span></span><br></pre></td></tr></table></figure><blockquote><p>另外你可以其他评论系统使用，例： <code>Gitalk</code>、<code>多说</code> 等</p></blockquote><h3 id="部署到-github"><a href="#部署到-github" class="headerlink" title="部署到 github"></a>部署到 github</h3><p>上面所有的操作完成之后，你就可以将你的 Blog 项目部署到 github 上了。<br>部署之前先修改<code>_config.yml</code>文件。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">https://github.com/&lt;yourAccount&gt;/&lt;repo&gt;</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">&lt;your-branch&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>备注：在 hexo3.x 版本下，这里的 type 应该填 git，不是 github；另外冒号后面都有一个英文的空格，不然会报错的。</p></blockquote><p>配置完<code>_config.yml</code>文件后，在命令后执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo generate(g)   <span class="comment"># 把文章生成页面</span></span><br><span class="line">hexo deploy(d)    <span class="comment"># 部署到github可与hexo g合并为 hexo d -g</span></span><br></pre></td></tr></table></figure><h3 id="Have-fun"><a href="#Have-fun" class="headerlink" title="Have fun ^_^"></a>Have fun ^_^</h3><p>如果你喜欢这个项目请给我点个<a href="https://github.com/csjiabin/csjiabin.github.io/stargazers" target="_blank" rel="noopener">Star</a>吧！<a href="https://github.com/csjiabin" target="_blank" rel="noopener">Following</a> 也将不胜感激!<br>如有其他疑问可以给我留言，我会第一时间为您解答！</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;欢迎来到 Hexo！该文章非常适合不懂前端的人搭建自己的博客，接下来我会讲解我为什么会选择&lt;code&gt;hexo&lt;/code&gt;和&lt;code&gt;hexo&lt;/code&gt;博客搭建步奏。最近想要搞个个人博客，因为不想自己搞站点，所以找到了&lt;code&gt;github pages&lt;/code&gt;，它提供给我们域名和空间，多省事啊。那静态页面用什么工具呢？一开始我用的是&lt;code&gt;jekyll&lt;/code&gt;,然后我有了那句经典的感受，那句话是从入门到放弃，啊，多么痛的领悟！&lt;/p&gt;
&lt;h4 id=&quot;下面我来扒一扒：&quot;&gt;&lt;a href=&quot;#下面我来扒一扒：&quot; class=&quot;headerlink&quot; title=&quot;下面我来扒一扒：&quot;&gt;&lt;/a&gt;下面我来扒一扒：&lt;/h4&gt;
    
    </summary>
    
    
      <category term="hexo" scheme="https://csjiabin.github.io/categories/hexo/"/>
    
    
      <category term="git" scheme="https://csjiabin.github.io/tags/git/"/>
    
      <category term="hexo" scheme="https://csjiabin.github.io/tags/hexo/"/>
    
      <category term="github" scheme="https://csjiabin.github.io/tags/github/"/>
    
      <category term="node" scheme="https://csjiabin.github.io/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://csjiabin.github.io/2018/08/16/hello-world/"/>
    <id>https://csjiabin.github.io/2018/08/16/hello-world/</id>
    <published>2018-08-16T05:30:29.000Z</published>
    <updated>2020-11-02T09:26:56.675Z</updated>
    
    <content type="html"><![CDATA[<!-- <div class="pdfobject-container" data-target="/com.pdf" data-height="500px"></div> --><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;!-- &lt;div class=&quot;pdfobject-container&quot; data-target=&quot;/com.pdf&quot; data-height=&quot;500px&quot;&gt;&lt;/div&gt; --&gt;
&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;Quick-Start&quot;&gt;&lt;a href=&quot;#Quick-Start&quot; class=&quot;headerlink&quot; title=&quot;Quick Start&quot;&gt;&lt;/a&gt;Quick Start&lt;/h2&gt;&lt;h3 id=&quot;Create-a-new-post&quot;&gt;&lt;a href=&quot;#Create-a-new-post&quot; class=&quot;headerlink&quot; title=&quot;Create a new post&quot;&gt;&lt;/a&gt;Create a new post&lt;/h3&gt;
    
    </summary>
    
    
      <category term="other" scheme="https://csjiabin.github.io/categories/other/"/>
    
    
  </entry>
  
</feed>
